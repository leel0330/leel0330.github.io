{"meta":{"title":"PingCoder","subtitle":"","description":"less is more","author":"PingCoder","url":"https://leel0330.github.io","root":"/"},"pages":[{"title":"","date":"2020-11-27T13:37:29.000Z","updated":"2020-12-26T07:21:26.332Z","comments":false,"path":"about/index.html","permalink":"https://leel0330.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-27T13:37:44.000Z","updated":"2020-11-27T13:38:19.224Z","comments":true,"path":"categories/index.html","permalink":"https://leel0330.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-12-26T03:48:15.000Z","updated":"2020-12-26T14:14:46.465Z","comments":false,"path":"friends/index.html","permalink":"https://leel0330.github.io/friends/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-27T13:40:50.000Z","updated":"2020-11-27T13:41:07.414Z","comments":true,"path":"tags/index.html","permalink":"https://leel0330.github.io/tags/index.html","excerpt":"","text":""},{"title":"动态","date":"2020-12-13T14:45:30.000Z","updated":"2021-02-26T12:49:37.740Z","comments":false,"path":"timeline/index.html","permalink":"https://leel0330.github.io/timeline/index.html","excerpt":"","text":"2021年 2月26日 二月的最后一个工作日，雨夜 2021年的第一场雨，让我想起了杜甫的一首诗:好雨知时节，当春乃发生。随风潜入夜，润物细无声。野径云俱黑，江船火独明。晓看红湿处，花重锦官城。春夜喜雨 杜甫 2020年 12月31日 一个有点冷但是阳光灿烂的下午 2020年最后一天了，没想到带了一年口罩😂。网上的年终总结太多了，对于我，不知道总结什么才好。索性还是让周大侠出场吧~最后的最后，想了想还是下面这首歌比较应景。 2020，想说爱你不容易~就是开不了口让她知道，我一定会呵护着你，也逗你笑。你对我有多重要，我后悔没让你知道。整颗心悬在半空，我只能够远远看着。这些我都做得到，但那个人已不是我。 12月26日 一个阳光灿烂的下午 小时候喜欢Jerry的聪明机智，长大了才发现Tom的“无所不能”才更惹人喜爱。感谢Tom给我的童年带来那么多欢乐！ 12月25日 圣诞节晚上 之前博客用的Next主题，可是发现网上用这个主题的人太多了。。。虽然Next简洁大方，但还是有点太简洁了，索性今天花了点时间更新主题到volantis了。volantis可以支持我之前md的语法，几乎不需要修改，这点对我还是挺吸引的，现在的博客相较之前，看起来确实更美观了~ 12月20日 周日面试了字节，项目经历没有答好，自己对以前做的项目思考还不够，看来这块需要加强。面试官出了一道单调栈的算法题(下来搜了一下才知道是单调栈)打算劝退吧，我自己都没想到居然做出来了。可惜没什么用了诶(服了我自己，算法题没做出来的时候前面答的好，算法题做出来了前面却答不好，总是二缺一)，前面的问题回答的不太好，给面试官留下了不好的印象，看来算法和项目得两手抓，希望自己早日能面上大厂，只能祝自己以后好运了。 12月13日 今天开始写一些简单的文字，来记录一下当天的心情。第一天，不知道写什么，那开始按照学习编程语言的惯例，写下大大的Hello World!哆啦A梦祝我好运连连"}],"posts":[{"title":"LeetCode之广度优先遍历","slug":"LeetCode-广度优先遍历","date":"2021-03-14T13:55:04.000Z","updated":"2021-03-14T14:01:54.242Z","comments":false,"path":"posts/160200368.html","link":"","permalink":"https://leel0330.github.io/posts/160200368.html","excerpt":"广度优先遍历的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"广度优先遍历的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 101. 对称二叉树给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 说明: 如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 1234567891011121314151617181920212223class Solution(object): def isSymmetric(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; if root is None: return True queue = [root, root] while queue: t1 = queue.pop(0) t2 = queue.pop(0) if t1 is None and t2 is None: continue if t1 is None or t2 is None: return False if t1.val != t2.val: return False queue.append(t1.left) queue.append(t2.right) queue.append(t1.right) queue.append(t2.left) return True 111. 二叉树的最小深度给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回它的最小深度 2. 123456789101112131415161718192021class Solution(object): def minDepth(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; if root is None: return 0 depth = 0 queue = [root] while queue: sz = len(queue) depth += 1 for i in xrange(sz): node = queue.pop(0) if node.left is None and node.right is None: return depth if node.left: queue.append(node.left) if node.right: queue.append(node.right) 127. 单词接龙 [n]给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则： 每次转换只能改变一个字母。转换过程中的中间单词必须是字典中的单词。 说明: 如果不存在这样的转换序列，返回 0。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。 示例 1: 输入: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"] 输出: 5 解释: 一个最短转换序列是 \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", 返回它的长度 5。 示例 2: 输入: beginWord = \"hit\" endWord = \"cog\" wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"] 输出: 0 解释: endWord \"cog\" 不在字典中，所以无法进行转换。 1234567891011121314151617181920212223242526272829303132333435class Solution(object): def ladderLength(self, beginWord, endWord, wordList): &quot;&quot;&quot; :type beginWord: str :type endWord: str :type wordList: List[str] :rtype: int &quot;&quot;&quot; word_set = set(wordList) if endWord not in word_set: return 0 chrs = [chr(ord(&#x27;a&#x27;) + i) for i in xrange(26)] step = 0 queue = [beginWord] used = &#123;beginWord:True&#125; n = len(beginWord) while queue: sz = len(queue) step += 1 for i in xrange(sz): word = list(queue.pop(0)) for j in xrange(n): original_c = word[j] for c in chrs: word[j] = c tmp = &#x27;&#x27;.join(word) if tmp in used: continue if tmp == endWord: return step + 1 if tmp in word_set: queue.append(tmp) used[tmp] = True word[j] = original_c return 0 130. 被围绕的区域 [n]给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。 找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。 示例: X X X X X O O X X X O X X O X X 运行你的函数后，矩阵变为： X X X X X X X X X X X X X O X X 解释: 被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution(object): def solve(self, board): &quot;&quot;&quot; :type board: List[List[str]] :rtype: None Do not return anything, modify board in-place instead. &quot;&quot;&quot; if board is None or len(board) == 0 or len(board[0]) == 0: return rows, cols = len(board), len(board[0]) for i in xrange(rows): if board[i][0] == &#x27;O&#x27;: self.bfs(board, i, 0, rows, cols) if board[i][cols - 1] == &#x27;O&#x27;: self.bfs(board, i, cols - 1, rows, cols) for j in xrange(cols): if board[0][j] == &#x27;O&#x27;: self.bfs(board, 0, j, rows, cols) if board[rows - 1][j] == &#x27;O&#x27;: self.bfs(board, rows - 1, j, rows, cols) for i in xrange(rows): for j in xrange(cols): if board[i][j] == &#x27;G&#x27;: board[i][j] = &#x27;O&#x27; elif board[i][j] == &#x27;O&#x27;: board[i][j] = &#x27;X&#x27; def bfs(self, board, i, j, rows, cols): board[i][j] = &#x27;G&#x27; queue = [(i, j)] while queue: x, y = queue.pop(0) if x &gt;= 1 and board[x - 1][y] == &#x27;O&#x27;: board[x - 1][y] = &#x27;G&#x27; queue.append((x - 1, y)) if x &lt; rows - 1 and board[x + 1][y] == &#x27;O&#x27;: board[x + 1][y] = &#x27;G&#x27; queue.append((x + 1, y)) if y &gt;= 1 and board[x][y - 1] == &#x27;O&#x27;: board[x][y - 1] = &#x27;G&#x27; queue.append((x, y - 1)) if y &lt; cols - 1 and board[x][y + 1] == &#x27;O&#x27;: board[x][y + 1] = &#x27;G&#x27; queue.append((x, y + 1)) 542. 01 矩阵 [n]给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。 两个相邻元素间的距离为 1 。 示例 1: 输入: 0 0 0 0 1 0 0 0 0 输出: 0 0 0 0 1 0 0 0 0 示例 2: 输入: 0 0 0 0 1 0 1 1 1 输出: 0 0 0 0 1 0 1 2 1 注意: 给定矩阵的元素个数不超过 10000。 给定矩阵中至少有一个元素是 0。 矩阵中的元素只在四个方向上相邻: 上、下、左、右。 123456789101112131415161718192021222324class Solution(object): def updateMatrix(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: List[List[int]] &quot;&quot;&quot; m, n = len(matrix), len(matrix[0]) res = [[-1 for _ in xrange(n)] for _ in xrange(m)] queue = [] for i in xrange(m): for j in xrange(n): if matrix[i][j] == 0: res[i][j] = 0 queue.append((i, j)) dires = [(0, 1), (0, -1), (1, 0), (-1, 0)] while queue: x, y = queue.pop(0) for dire in dires: a = x + dire[0] b = y + dire[1] if 0 &lt;= a &lt; m and 0 &lt;= b &lt; n and res[a][b] == -1: res[a][b] = res[x][y] + 1 queue.append((a, b)) return res 841. 钥匙和房间 [n]有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，…，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。 在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，…，N-1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。 最初，除 0 号房间外的其余所有房间都被锁住。 你可以自由地在房间之间来回走动。 如果能进入每个房间返回 true，否则返回 false。 示例 1： 输入: [[1],[2],[3],[]] 输出: true 解释: 我们从 0 号房间开始，拿到钥匙 1。 之后我们去 1 号房间，拿到钥匙 2。 然后我们去 2 号房间，拿到钥匙 3。 最后我们去了 3 号房间。 由于我们能够进入每个房间，我们返回 true。 示例 2： 输入：[[1,3],[3,0,1],[2],[0]] 输出：false 解释：我们不能进入 2 号房间。 提示： 1 &lt;= rooms.length &lt;= 1000 0 &lt;= rooms[i].length &lt;= 1000 所有房间中的钥匙数量总计不超过 3000 123456789101112131415161718class Solution(object): def canVisitAllRooms(self, rooms): &quot;&quot;&quot; :type rooms: List[List[int]] :rtype: bool &quot;&quot;&quot; visited = [0 for _ in xrange(len(rooms))] queue = [0] while queue: sz = len(queue) for i in xrange(sz): room_idx = queue.pop(0) if visited[room_idx] == 1: continue visited[room_idx] = 1 for j in rooms[room_idx]: queue.append(j) return sum(visited) == len(rooms) 863. 二叉树中所有距离为 K 的结点 [n]给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。 返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。 示例 1： 输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2 输出：[7,4,1] 解释： 所求结点为与目标结点（值为 5）距离为 2 的结点， 值分别为 7，4，以及 1 提示： 给定的树是非空的，且最多有 K 个结点。 树上的每个结点都具有唯一的值 0 &lt;= node.val &lt;= 500 。 目标结点 target 是树上的结点。 0 &lt;= K &lt;= 1000. 123456789101112131415161718192021222324252627282930313233class Solution(object): def distanceK(self, root, target, K): &quot;&quot;&quot; :type root: TreeNode :type target: TreeNode :type K: int :rtype: List[int] &quot;&quot;&quot; m = collections.defaultdict(list) self.helper(None, root, m) queue = [target.val] visited = set([target.val]) for _ in xrange(K): sz = len(queue) for _ in xrange(sz): v = queue.pop(0) for i in m[v]: if i not in visited: visited.add(i) queue.append(i) return queue def helper(self, parent, child, m): if parent and child: m[child.val].append(parent.val) m[parent.val].append(child.val) if child.left: self.helper(child, child.left, m) if child.right: self.helper(child, child.right, m) 993. 二叉树的堂兄弟节点 [n]在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。 如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。 我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。 只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。 示例 1： 输入：root = [1,2,3,4], x = 4, y = 3 输出：false 示例 2： 输入：root = [1,2,3,null,4,null,5], x = 5, y = 4 输出：true 示例 3： 输入：root = [1,2,3,null,4], x = 2, y = 3 输出：false 12345678910111213141516171819202122232425262728class Solution(object): def isCousins(self, root, x, y): &quot;&quot;&quot; :type root: TreeNode :type x: int :type y: int :rtype: bool &quot;&quot;&quot; if root is None: return False queue = [(root, None)] m = &#123;&#125; depth = 0 while queue: sz = len(queue) for i in xrange(sz): node, parent = queue.pop(0) m[node.val] = (parent, depth) if node.left: queue.append((node.left, node)) if node.right: queue.append((node.right, node)) depth += 1 px, dx = m[x] py, dy = m[y] return px != py and dx == dy","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"海量数据处理常用技法","slug":"技术面试之海量数据处理","date":"2021-03-06T09:45:17.000Z","updated":"2021-03-06T10:26:46.945Z","comments":false,"path":"posts/1322695096.html","link":"","permalink":"https://leel0330.github.io/posts/1322695096.html","excerpt":"之前面试有碰到过如何处理资源有限(时间有限或空间有限)但数据规模庞大的面试题，然后查阅了网上的一些资料，这里做个简单的总结。","text":"之前面试有碰到过如何处理资源有限(时间有限或空间有限)但数据规模庞大的面试题，然后查阅了网上的一些资料，这里做个简单的总结。 常见的处理方法HashHash，即哈希，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值(可以理解为Hash碰撞)。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 BitMap所谓的BitMap就是用一个bit位来标记某个元素对应的值。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。 举个例子，一个int是32bit(即4个字节)。我们可以用4个字节来表示32个数，如0-31。一开始所有位为0，如果某个数存在，我们可以把相应位置1，用此法表示该数存在。 Bloom FilterBloom Filter（BF）是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。它是一个判断元素是否存在集合的快速的概率算法。Bloom Filter有可能会出现错误判断，但不会漏掉判断。也就是Bloom Filter判断元素不在集合，那肯定不在。如果判断元素存在集合中，有一定的概率判断错误。因此，Bloom Filter不适合那些“零错误”的应用场合。 而在能容忍低错误率的应用场合下，Bloom Filter比其他常见的算法（如hash，折半查找）极大节省了空间。 Heap堆是一种特殊的二叉树，具备以下两种性质: 每个节点的值都大于（或者都小于，称为最小堆）其子节点的值 树是完全平衡的，并且最后一层的树叶都在最左边这样就定义了一个最大堆。 如下图用一个数组来表示堆： Trie如下图来表示Trie树: Trie树有以下几个特性: 根节点不包含字符，除根节点外的每一个子节点都包含一个字符。 从根节点到某一节点，路径上经过的字符连接起来，就是该节点对应的字符串。 每个单词的公共前缀作为一个字符节点保存。 题目实战1. 海量日志数据，提取出某日访问百度次数最多的那个IP。算法思想：分而治之+Hash 1.IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理；2.可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址；3.对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址；4.可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP； 2. 搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。算法思想：hashmap+堆 1.先对这批海量数据预处理，在O（N）的时间内用Hash表完成统计；2.借助堆这个数据结构，找出Top K，时间复杂度为O(N*logK)。 或者：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小堆来对出现频率进行排序。 3. 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。算法思想：分而治之 + hash统计 + 堆排序 1.顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。 2.对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。 3.取出出现频率最大的100个词（可以用含100个结点的最小堆）后，再把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并（类似于归并排序）的过程了。 4. 有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。方法1: 算法思想：分而治之 + hash统计 + 堆排序 顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件中。这样新生成的文件每个的大小大约也1G，大于1G继续按照上述思路分。 找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为）。 对这10个文件进行归并排序（内排序与外排序相结合）。 方法2: 算法思想：hashmap+堆 一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。 5. 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url。算法思想：分而治之 + hash统计 遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999）中。这样每个小文件的大约为300M。 遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,…,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,…,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。 求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。 6. 在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。BitMap变种 采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。 7. 给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？算法思想：BitMap 申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。 参考资料 https://www.jianshu.com/p/ac5cad6d64a8","categories":[{"name":"Tech","slug":"Tech","permalink":"https://leel0330.github.io/categories/Tech/"}],"tags":[]},{"title":"剑指Offer选题题解","slug":"剑指Offer","date":"2021-02-28T04:28:04.000Z","updated":"2021-02-28T04:58:03.664Z","comments":false,"path":"posts/3717340568.html","link":"","permalink":"https://leel0330.github.io/posts/3717340568.html","excerpt":"把剑指Offer的题过了一遍，在这里汇总一下。","text":"把剑指Offer的题过了一遍，在这里汇总一下。 面试题07. 重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如，给出 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 限制： 0 &lt;= 节点个数 &lt;= 5000 PythonCpp12345678910111213141516171819202122class Solution(object): def buildTree(self, preorder, inorder): &quot;&quot;&quot; :type preorder: List[int] :type inorder: List[int] :rtype: TreeNode &quot;&quot;&quot; m = &#123;&#125; for idx, v in enumerate(inorder): m[v] = idx return self.helper(preorder, 0, len(preorder) - 1, inorder, 0, len(inorder) - 1, m) def helper(self, preorder, pre_s, pre_e, inorder, in_s, in_e, m): if pre_s &gt; pre_e or in_s &gt; in_e: return None root_v = preorder[pre_s] root_idx = m[root_v] left_len = root_idx - in_s root = TreeNode(root_v) root.left = self.helper(preorder, pre_s + 1, pre_s + left_len, inorder, in_s, root_idx - 1, m) root.right = self.helper(preorder, pre_s + left_len + 1, pre_e, inorder, root_idx + 1, in_e, m) return root1234567891011121314151617181920212223242526272829class Solution&#123;public: TreeNode *buildTree(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder) &#123; unordered_map&lt;int, int&gt; m; for (int i = 0; i &lt; inorder.size(); i++) &#123; m[inorder[i]] = i; &#125; return helper(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1, m); &#125; TreeNode *helper(vector&lt;int&gt; &amp;preorder, int pLeft, int pRight, vector&lt;int&gt; &amp;inorder, int iLeft, int iRight, unordered_map&lt;int, int&gt;&amp; m) &#123; if (pLeft &gt; pRight || iLeft &gt; iRight) &#123; return nullptr; &#125; int rootV = preorder[pLeft]; int rootIdx = m[rootV]; int leftLen = rootIdx - iLeft; TreeNode *root = new TreeNode(rootV); root-&gt;left = helper(preorder, pLeft + 1, pLeft + leftLen, inorder, iLeft, rootIdx - 1, m); root-&gt;right = helper(preorder, pLeft + leftLen + 1, pRight, inorder, rootIdx + 1, iRight, m); return root; &#125;&#125;; 面试题11. 旋转数组的最小数字把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 1： 输入：[3,4,5,1,2] 输出：1 示例 2： 输入：[2,2,2,0,1] 输出：0 PythonCpp123456789101112131415161718class Solution(object): def minArray(self, numbers): &quot;&quot;&quot; :type numbers: List[int] :rtype: int &quot;&quot;&quot; if numbers is None or len(numbers) == 0: return -1 left, right = 0, len(numbers) - 1 while left &lt; right: mid = (left + right) / 2 if numbers[mid] &lt; numbers[right]: right = mid elif numbers[mid] == numbers[right]: right -= 1 else: left = mid + 1 return numbers[left]123456789101112131415161718192021222324252627282930class Solution&#123;public: int minArray(vector&lt;int&gt; &amp;numbers) &#123; if (numbers.size() == 0) &#123; return -1; &#125; int n = numbers.size(); int left = 0, right = n - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (numbers[mid] &lt; numbers[right]) &#123; right = mid; &#125; else if (numbers[mid] == numbers[right]) &#123; right -= 1; &#125; else &#123; left = mid + 1; &#125; &#125; return numbers[left]; &#125;&#125;; 面试题14- I. 剪绳子 [n]给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 k[0]k[1]…*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 示例 1： 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1 示例 2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示： 2 &lt;= n &lt;= 58 PythonCpp12345678910111213141516171819class Solution(object): def cuttingRope(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; cache = [0 for i in xrange(n + 1)] return self.helper(n, cache) def helper(self, n, cache): if n == 2: return 1 if cache[n] != 0: return cache[n] res = -1 for i in xrange(1, n): res = max(res, i * (n - i), i * self.helper(n - i, cache)) cache[n] = res return res12345678910111213141516171819202122232425262728class Solution&#123;public: int cuttingRope(int n) &#123; vector&lt;int&gt; cache(n + 1, 0); return helper(n, cache); &#125; int helper(int n, vector&lt;int&gt; &amp;cache) &#123; int res = 0; if (n == 2) &#123; return 1; &#125; if (cache[n] != 0) &#123; return cache[n]; &#125; for (int i = 1; i &lt; n; i++) &#123; int v = max(i * (n - i), i * helper(n - i, cache)); res = max(res, v); &#125; cache[n] = res; return res; &#125;&#125;; 面试题19. 正则表达式匹配 [n]请实现一个函数用来匹配包含’. ‘和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但与”aa.a”和”ab*a”均不匹配。 示例 1: 输入: s = \"aa\" p = \"a\" 输出: false 解释: \"a\" 无法匹配 \"aa\" 整个字符串。 示例 2: 输入: s = \"aa\" p = \"a*\" 输出: true 解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。 示例 3: 输入: s = \"ab\" p = \".*\" 输出: true 解释: \".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。 示例 4: 输入: s = \"aab\" p = \"c*a*b\" 输出: true 解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。 示例 5: 输入: s = \"mississippi\" p = \"mis*is*p*.\" 输出: false s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 1234567891011121314class Solution(object): def isMatch(self, s, p): &quot;&quot;&quot; :type s: str :type p: str :rtype: bool &quot;&quot;&quot; if not p: return not s first_match = bool(s) and p[0] in [s[0], &#x27;.&#x27;] if len(p) &gt;= 2 and p[1] == &#x27;*&#x27;: return (self.isMatch(s, p[2:])) or (first_match and self.isMatch(s[1:], p)) else: return first_match and self.isMatch(s[1:], p[1:]) 面试题26. 树的子结构输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 例如: 给定的树 A: 3 / \\ 4 5 / \\ 1 2 给定的树 B： 4 / 1 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。 示例 1： 输入：A = [1,2,3], B = [3,1] 输出：false 示例 2： 输入：A = [3,4,5,1,2], B = [4,1] 输出：true 限制： 0 &lt;= 节点个数 &lt;= 10000 PythonCpp1234567891011121314151617class Solution(object): def isSubStructure(self, A, B): &quot;&quot;&quot; :type A: TreeNode :type B: TreeNode :rtype: bool &quot;&quot;&quot; if A is None or B is None: return False return self.helper(A, B) or self.isSubStructure(A.left, B) or self.isSubStructure(A.right, B) def helper(self, A, B): if A is None or B is None: return True if B is None else False if A.val != B.val: return False return self.helper(A.left, B.left) and self.helper(A.right, B.right)12345678910111213141516171819202122232425class Solution&#123;public: bool isSubStructure(TreeNode *A, TreeNode *B) &#123; if (A == nullptr || B == nullptr) &#123; return false; &#125; return helper(A, B) || isSubStructure(A-&gt;left, B) || isSubStructure(A-&gt;right, B); &#125; bool helper(TreeNode *A, TreeNode *B) &#123; if (A == nullptr || B == nullptr) &#123; return B == nullptr ? true : false; &#125; if (A-&gt;val != B-&gt;val) &#123; return false; &#125; return helper(A-&gt;left, B-&gt;left) &amp;&amp; helper(A-&gt;right, B-&gt;right); &#125;&#125;; 面试题27. 二叉树的镜像请完成一个函数，输入一个二叉树，该函数输出它的镜像。 例如输入： 4 / \\ 2 7 / \\ / \\ 1 3 6 9 镜像输出： 4 / \\ 7 2 / \\ / \\ 9 6 3 1 示例 1： 输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1] 限制： 0 &lt;= 节点个数 &lt;= 1000 PythonCpp12345678910111213141516171819class Solution(object): def mirrorTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; if root is None: return root queue = [root] while queue: sz = len(queue) for i in xrange(sz): node = queue.pop(0) node.left, node.right = node.right, node.left if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root123456789101112131415161718192021222324252627282930class Solution&#123;public: TreeNode *mirrorTree(TreeNode *root) &#123; if (root == nullptr) &#123; return root; &#125; queue&lt;TreeNode *&gt; treeQ; treeQ.push(root); while (!treeQ.empty()) &#123; TreeNode *node = treeQ.front(); treeQ.pop(); swap(node-&gt;left, node-&gt;right); if (node-&gt;left) &#123; treeQ.push(node-&gt;left); &#125; if (node-&gt;right) &#123; treeQ.push(node-&gt;right); &#125; &#125; return root; &#125;&#125;; 面试题28. 对称的二叉树请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 示例 1： 输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2： 输入：root = [1,2,2,null,3,null,3] 输出：false 限制： 0 &lt;= 节点个数 &lt;= 1000 PythonCpp12345678910111213141516class Solution(object): def isSymmetric(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; return self.helper(root, root) def helper(self, rootA, rootB): if rootA is None and rootB is None: return True if rootA is None or rootB is None: return False if rootA.val != rootB.val: return False return self.helper(rootA.left, rootB.right) and self.helper(rootA.right, rootB.left)12345678910111213141516171819202122232425class Solution&#123;public: bool isSymmetric(TreeNode *root) &#123; return helper(root, root); &#125; bool helper(TreeNode *p, TreeNode *q) &#123; if (p == nullptr &amp;&amp; q == nullptr) &#123; return true; &#125; if (p == nullptr || q == nullptr) &#123; return false; &#125; if (p-&gt;val != q-&gt;val) &#123; return false; &#125; return helper(p-&gt;left, q-&gt;right) &amp;&amp; helper(p-&gt;right, q-&gt;left); &#125;&#125;; 面试题29. 顺时针打印矩阵输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例 2： 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] 限制： 0 &lt;= matrix.length &lt;= 100 0 &lt;= matrix[i].length &lt;= 100 123456789101112131415161718192021222324252627282930313233class Solution(object): def spiralOrder(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: List[int] &quot;&quot;&quot; if matrix is None or len(matrix) == 0 or len(matrix[0]) == 0: return [] m, n = len(matrix), len(matrix[0]) res = [] top, bottom, left, right = 0, m - 1, 0, n - 1 while True: for i in xrange(left, right + 1): res.append(matrix[top][i]) top += 1 if top &gt; bottom: break for i in xrange(top, bottom + 1): res.append(matrix[i][right]) right -= 1 if right &lt; left: break for i in xrange(right, left - 1, -1): res.append(matrix[bottom][i]) bottom -= 1 if bottom &lt; top: break for i in xrange(bottom, top - 1, -1): res.append(matrix[i][left]) left += 1 if left &gt; right: break return res 面试题33. 二叉搜索树的后序遍历序列输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。 参考以下这颗二叉搜索树： 5 / \\ 2 6 / \\ 1 3 示例 1： 输入: [1,6,3,2,5] 输出: false 示例 2： 输入: [1,3,2,6,5] 输出: true 提示： 数组长度 &lt;= 1000 PythonCpp12345678910111213141516171819202122class Solution(object): def verifyPostorder(self, postorder): &quot;&quot;&quot; :type postorder: List[int] :rtype: bool &quot;&quot;&quot; n = len(postorder) if n == 0 or n == 1: return True return self.helper(postorder, 0, n - 1) def helper(self, postorder, left, right): if left &gt;= right: return True root_v = postorder[right] i = left while postorder[i] &lt; root_v: i += 1 for j in xrange(i, right): if postorder[j] &lt;= root_v: return False return self.helper(postorder, left, i - 1) and self.helper(postorder, i, right - 1)123456789101112131415161718192021222324252627282930class Solution&#123;public: bool verifyPostorder(vector&lt;int&gt; &amp;postorder) &#123; return helper(postorder, 0, postorder.size() - 1); &#125; bool helper(vector&lt;int&gt; &amp;postorder, int left, int right) &#123; if (left &gt;= right) &#123; return true; &#125; int rootV = postorder[right]; int left_end = left; while (left_end &lt; right &amp;&amp; postorder[left_end] &lt; rootV) &#123; left_end += 1; &#125; for (int i = left_end; i &lt; right; i++) &#123; if (postorder[i] &lt;= rootV) &#123; return false; &#125; &#125; return helper(postorder, left, left_end - 1) &amp;&amp; helper(postorder, left_end, right - 1); &#125;&#125;; 面试题36. 二叉搜索树与双向链表 [n]输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 PythonCpp1234567891011121314151617181920212223242526272829class Solution(object): def __init__(self): self.head = None self.prev = None self.tail = None def treeToDoublyList(self, root): &quot;&quot;&quot; :type root: Node :rtype: Node &quot;&quot;&quot; if root is None: return root self.inorder(root) self.head.left = self.tail self.tail.right = self.head return self.head def inorder(self, root): if root is None: return self.inorder(root.left) if self.prev is None: self.head = root else: self.prev.right = root root.left = self.prev self.prev = root self.tail = root self.inorder(root.right)123456789101112131415161718192021222324252627282930313233343536373839class Solution&#123;public: Node *treeToDoublyList(Node *root) &#123; if (root == nullptr) &#123; return root; &#125; inorder(root); _head-&gt;left = _tail; _tail-&gt;right = _head; return _head; &#125; void inorder(Node *root) &#123; if (root == nullptr) &#123; return; &#125; inorder(root-&gt;left); if (_prev == nullptr) &#123; _head = root; &#125; else &#123; _prev-&gt;right = root; &#125; root-&gt;left = _prev; _prev = root; _tail = root; inorder(root-&gt;right); &#125;private: Node *_head, *_tail, *_prev;&#125;; 面试题37. 序列化二叉树 [n]请实现两个函数，分别用来序列化和反序列化二叉树。 示例: 你可以将以下二叉树： 1 / \\ 2 3 / \\ 4 5 序列化为 \"[1,2,3,null,null,4,5]\" PythonCpp12345678910111213141516171819202122232425262728293031323334353637class Codec: def serialize(self, root): &quot;&quot;&quot;Encodes a tree to a single string. :type root: TreeNode :rtype: str &quot;&quot;&quot; res = [] def preorder(root): if root is None: res.append(&#x27;null&#x27;) else: res.append(str(root.val)) preorder(root.left) preorder(root.right) preorder(root) return &#x27;,&#x27;.join(res) def deserialize(self, data): &quot;&quot;&quot;Decodes your encoded data to tree. :type data: str :rtype: TreeNode &quot;&quot;&quot; res = data.split(&#x27;,&#x27;) def buildTree(): if res: val = res.pop(0) if val == &#x27;null&#x27;: return None root = TreeNode(int(val)) root.left = buildTree() root.right = buildTree() return root return buildTree()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Codec&#123;public: // Encodes a tree to a single string. string serialize(TreeNode *root) &#123; string res; tree2str(root, res); return res; &#125; void tree2str(TreeNode *root, string &amp;res) &#123; if (root == nullptr) &#123; res += &quot;# &quot;; return; &#125; res += std::to_string(root-&gt;val) + &quot; &quot;; tree2str(root-&gt;left, res); tree2str(root-&gt;right, res); &#125; // Decodes your encoded data to tree. TreeNode *deserialize(string data) &#123; int idx = 0; return str2tree(data, idx); &#125; TreeNode *str2tree(string data, int &amp;idx) &#123; if (idx == data.size()) &#123; return nullptr; &#125; int endIdx = idx; while (data[endIdx] != &#x27; &#x27;) &#123; endIdx += 1; &#125; if (data[idx] == &#x27;#&#x27;) &#123; idx = endIdx + 1; return nullptr; &#125; int val = 0; bool sign = false; if(data[idx] == &#x27;-&#x27;) &#123; idx = idx + 1; sign = true; &#125; for (int i = idx; i &lt; endIdx; i++) &#123; val = val * 10 + (data[i] - &#x27;0&#x27;); &#125; val = sign ? -val:val; idx = endIdx + 1; TreeNode *root = new TreeNode(val); root-&gt;left = str2tree(data, idx); root-&gt;right = str2tree(data, idx); return root; &#125;&#125;; 面试题44. 数字序列中某一位的数字数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。 请写一个函数，求任意第n位对应的数字。 示例 1： 输入：n = 3 输出：3 示例 2： 输入：n = 11 输出：0 限制： 0 &lt;= n &lt; 2^31 123456789101112131415161718class Solution(object): def findNthDigit(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; if n == 0: return 0 _len = 1 cnt = 9 start = 1 while n &gt; _len * cnt: n -= _len * cnt _len += 1 cnt *= 10 start *= 10 start += (n - 1) / _len return int(str(start)[(n - 1) % _len]) 面试题46. 把数字翻译成字符串 [n]给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 示例 1: 输入: 12258 输出: 5 解释: 12258有5种不同的翻译，分别是\"bccfi\", \"bwfi\", \"bczi\", \"mcfi\"和\"mzi\" 提示： 0 &lt;= num &lt; 231 PythonCpp12345678910111213141516171819class Solution(object): def translateNum(self, num): &quot;&quot;&quot; :type num: int :rtype: int &quot;&quot;&quot; num_str = str(num) slen = len(num_str) dp = [0 for i in xrange(slen + 1)] dp[0] = 1 dp[1] = 1 for i in xrange(2, slen + 1): a = num_str[i - 2:i] b = num_str[i - 1:i] if 10 &lt;= int(a) &lt;= 25: dp[i] += dp[i - 2] if 0 &lt;= int(b) &lt;= 9: dp[i] += dp[i - 1] return dp[slen]12345678910111213141516171819202122232425262728class Solution&#123;public: int translateNum(int num) &#123; string num_str = std::to_string(num); int sLen = num_str.size(); vector&lt;int&gt; dp(sLen + 1, 0); dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;= sLen; i++) &#123; string a = num_str.substr(i - 2, 2); string b = num_str.substr(i - 1, 1); int m = std::stoi(a); int n = std::stoi(b); if (m &gt;= 10 &amp;&amp; m &lt;= 25) &#123; dp[i] += dp[i - 2]; &#125; if (n &gt;= 0 &amp;&amp; n &lt;= 9) &#123; dp[i] += dp[i - 1]; &#125; &#125; return dp[sLen]; &#125;&#125;; 面试题49. 丑数我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。 示例: 输入: n = 10 输出: 12 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明: 1 是丑数。 n 不超过1690。 PythonCpp123456789101112131415161718class Solution(object): def nthUglyNumber(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; dp = [1 for i in xrange(n)] i2, i3, i5 = 0, 0, 0 for i in xrange(1, n): min_v = min(dp[i2] * 2, dp[i3] * 3, dp[i5] * 5) dp[i] = min_v if min_v == dp[i2] * 2: i2 += 1 if min_v == dp[i3] * 3: i3 += 1 if min_v == dp[i5] * 5: i5 += 1 return dp[n - 1]123456789101112131415161718192021222324252627class Solution&#123;public: int nthUglyNumber(int n) &#123; vector&lt;int&gt; dp(n, 1); int i2 = 0, i3 = 0, i5 = 0; for (int i = 1; i &lt; n; i++) &#123; int min_v = min(min(dp[i2] * 2, dp[i3] * 3), dp[i5] * 5); dp[i] = min_v; if (min_v == dp[i2] * 2) &#123; i2 += 1; &#125; if (min_v == dp[i3] * 3) &#123; i3 += 1; &#125; if (min_v == dp[i5] * 5) &#123; i5 += 1; &#125; &#125; return dp[n - 1]; &#125;&#125;; 面试题56 - II. 数组中数字出现的次数 [n]在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 示例 1： 输入：nums = [3,4,3,3] 输出：4 示例 2： 输入：nums = [9,1,7,9,7,9,7] 输出：1 限制： 1 &lt;= nums.length &lt;= 10000 1 &lt;= nums[i] &lt; 2^31 PythonCpp123456789101112131415161718class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; res = 0 for i in range(32): cnt = 0 # 记录当前 bit 有多少个1 bit = 1 &lt;&lt; i # 记录当前要操作的 bit for num in nums: if num &amp; bit != 0: cnt += 1 if cnt % 3 != 0: # 不等于0说明唯一出现的数字在这个 bit 上是1 res |= bit return res - 2 ** 32 if res &gt; 2 ** 31 - 1 else res12345678910111213141516171819202122232425class Solution&#123;public: int singleNumber(vector&lt;int&gt; &amp;nums) &#123; int res = 0; for (int i = 0; i &lt; 32; i++) &#123; int bit = 1 &lt;&lt; i; int cnt = 0; for (auto n : nums) &#123; if ((n &amp; bit) != 0) &#123; cnt += 1; &#125; &#125; if (cnt % 3 != 0) &#123; res |= bit; &#125; &#125; return res; &#125;&#125;; 面试题57 - II. 和为s的连续正数序列 [n]输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。 序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。 示例 1： 输入：target = 9 输出：[[2,3,4],[4,5]] 示例 2： 输入：target = 15 输出：[[1,2,3,4,5],[4,5,6],[7,8]] 限制： 1 &lt;= target &lt;= 10^5 PythonCpp123456789101112131415161718192021class Solution(object): def findContinuousSequence(self, target): &quot;&quot;&quot; :type target: int :rtype: List[List[int]] &quot;&quot;&quot; left, right, total = 1, 0, 0 res = [] flag = (target + 1) / 2 while right &lt;= flag: if total == target: res.append([i for i in xrange(left, right + 1)]) right += 1 total += right elif total &lt; target: right += 1 total += right else: total -= left left += 1 return res1234567891011121314151617181920212223242526272829303132333435class Solution&#123;public: vector&lt;vector&lt;int&gt;&gt; findContinuousSequence(int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; int left = 1, right = 0, total = 0; int flag = (target + 1) / 2; while (right &lt;= flag) &#123; if (total == target) &#123; vector&lt;int&gt; item; for (int i = left; i &lt;= right; i++) &#123; item.push_back(i); &#125; res.push_back(item); right += 1; total += right; &#125; else if (total &lt; target) &#123; right += 1; total += right; &#125; else &#123; total -= left; left += 1; &#125; &#125; return res; &#125;&#125;; 面试题59 - I. 滑动窗口的最大值 [n]给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。 示例: 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 提示： 你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。 1234567891011121314151617181920from collections import dequeclass Solution(object): def maxSlidingWindow(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: List[int] &quot;&quot;&quot; dq = deque() res = [] for i, v in enumerate(nums): while dq and dq[0] &lt;= i - k: dq.popleft() while dq and v &gt; nums[dq[-1]]: dq.pop() dq.append(i) if i &gt;= k - 1: res.append(nums[dq[0]]) return res 面试题62. 圆圈中最后剩下的数字 [n]0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。 示例 1： 输入: n = 5, m = 3 输出: 3 示例 2： 输入: n = 10, m = 17 输出: 2 限制： 1 &lt;= n &lt;= 10^5 1 &lt;= m &lt;= 10^6 PythonCpp12345678910111213class Solution(object): def lastRemaining(self, n, m): &quot;&quot;&quot; :type n: int :type m: int :rtype: int &quot;&quot;&quot; nums = [i for i in xrange(n)] c = (m - 1) % n while len(nums) != 1: nums.pop(c) c = (c + m - 1) % len(nums) return nums[0]12345678910111213class Solution&#123;public: int lastRemaining(int n, int m) &#123; int last = 0; for (int i = 2; i &lt;= n; i++) &#123; last = (last + m) % i; &#125; return last; &#125;&#125;; 面试题68 - II. 二叉树的最近公共祖先给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 PythonCpp123456789101112131415class Solution(object): def lowestCommonAncestor(self, root, p, q): &quot;&quot;&quot; :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode &quot;&quot;&quot; if root is None or root == p or root == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if left and right: return root return left if left else right123456789101112131415161718class Solution&#123;public: TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) &#123; if (root == nullptr || root == p || root == q) &#123; return root; &#125; TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode *right = lowestCommonAncestor(root-&gt;right, p, q); if (left &amp;&amp; right) &#123; return root; &#125; return left == nullptr ? right : left; &#125;&#125;;","categories":[{"name":"Tech","slug":"Tech","permalink":"https://leel0330.github.io/categories/Tech/"}],"tags":[]},{"title":"LeetCode之动态规划(中等)","slug":"LeetCode-动态规划-中等","date":"2021-02-26T12:13:18.000Z","updated":"2021-02-26T12:41:15.564Z","comments":false,"path":"posts/903350571.html","link":"","permalink":"https://leel0330.github.io/posts/903350571.html","excerpt":"动态规划(中等)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"动态规划(中等)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 5. 最长回文子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: \"babad\" 输出: \"bab\" 注意: \"aba\" 也是一个有效答案。 示例 2： 输入: \"cbbd\" 输出: \"bb\" 12345678910111213141516171819202122232425262728class Solution &#123; private int len; private String res; public String longestPalindrome(String s) &#123; len = 0; res = &quot;&quot;; int n = s.length(); for (int i = 0; i &lt; n; i++) &#123; helper(s, i, i); helper(s, i, i + 1); &#125; return res; &#125; private void helper(String s, int left, int right) &#123; int i = left, j = right; int n = s.length(); while (i &gt; -1 &amp;&amp; j &lt; n &amp;&amp; s.charAt(i) == s.charAt(j)) &#123; i -= 1; j += 1; &#125; if (j - i - 1 &gt; len) &#123; len = j - i - 1; res = s.substring(i + 1, j); &#125; &#125;&#125; 91. 解码方法一条包含字母 A-Z 的消息通过以下方式进行了编码： 'A' -> 1 'B' -> 2 ... 'Z' -> 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1: 输入: \"12\" 输出: 2 解释: 它可以解码为 \"AB\"（1 2）或者 \"L\"（12）。 示例 2: 输入: \"226\" 输出: 3 解释: 它可以解码为 \"BZ\" (2 26), \"VF\" (22 6), 或者 \"BBF\" (2 2 6) 。 PythonJava123456789101112131415161718class Solution(object): def numDecodings(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; n = len(s) dp = [0 for _ in xrange(n + 1)] dp[0] = 1 dp[1] = 1 if s[0] != &#x27;0&#x27; else 0 for i in xrange(2, n + 1): one_c = int(s[i - 1: i]) two_c = int(s[i - 2: i]) if 1 &lt;= one_c &lt;= 9: dp[i] += dp[i - 1] if 10 &lt;= two_c &lt;= 26: dp[i] += dp[i - 2] return dp[n]123456789101112131415161718192021class Solution &#123; public int numDecodings(String s) &#123; int n = s.length(); int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = s.charAt(0) == &#x27;0&#x27; ? 0 : 1; for (int i = 2; i &lt; n + 1; i++) &#123; String one_s = s.substring(i - 1, i); String two_s = s.substring(i - 2, i); int one = Integer.parseInt(one_s); if (1 &lt;= one &amp;&amp; one &lt;= 9) &#123; dp[i] += dp[i - 1]; &#125; int two = Integer.parseInt(two_s); if (two &gt;= 10 &amp;&amp; two &lt;= 26) &#123; dp[i] += dp[i - 2]; &#125; &#125; return dp[n]; &#125;&#125; 120. 三角形最小路径和 [n]给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： [ [2], [3,4], [6,5,7], [4,1,8,3] ] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 PythonJava12345678910111213141516171819202122class Solution(object): def minimumTotal(self, triangle): &quot;&quot;&quot; :type triangle: List[List[int]] :rtype: int &quot;&quot;&quot; rows = len(triangle) cols = len(triangle[rows - 1]) dp = [[0 for _ in xrange(cols)] for _ in xrange(rows)] dp[0][0] = triangle[0][0] for i in xrange(1, rows): for j in xrange(0, i + 1): if j == 0: dp[i][j] = dp[i - 1][j] + triangle[i][j] elif i == j: dp[i][j] = dp[i - 1][j - 1] + triangle[i][j] else: dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + triangle[i][j] res = dp[rows - 1][0] for i in xrange(1, cols): res = min(res, dp[rows - 1][i]) return res12345678910111213141516171819202122232425class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int rows = triangle.size(); int cols = triangle.get(rows - 1).size(); int[][] dp = new int[rows][cols]; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; i + 1; j++) &#123; if (i == 0 &amp;&amp; j == 0) &#123; dp[i][j] = triangle.get(i).get(j); &#125; else if (j == 0) &#123; dp[i][j] = triangle.get(i).get(j) + dp[i - 1][j]; &#125; else if (j == i) &#123; dp[i][j] = triangle.get(i).get(j) + dp[i - 1][j - 1]; &#125; else &#123; dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1]) + triangle.get(i).get(j); &#125; &#125; &#125; int res = dp[rows - 1][0]; for (int i = 1; i &lt; cols; i++) &#123; res = Math.min(res, dp[rows - 1][i]); &#125; return res; &#125;&#125; 139. 单词拆分 [n]给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1： 输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"] 输出: true 解释: 返回 true 因为 \"leetcode\" 可以被拆分成 \"leet code\"。 示例 2： 输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"] 输出: true 解释: 返回 true 因为 \"applepenapple\" 可以被拆分成 \"apple pen apple\"。 注意你可以重复使用字典中的单词。 示例 3： 输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"] 输出: false PythonJava123456789101112131415161718class Solution(object): def wordBreak(self, s, wordDict): &quot;&quot;&quot; :type s: str :type wordDict: List[str] :rtype: bool &quot;&quot;&quot; word_set = set() for word in wordDict: word_set.add(word) dp = [False for _ in xrange(len(s) + 1)] dp[0] = True for i in xrange(1, len(s) + 1): for j in xrange(i): if dp[j] and s[j: i] in word_set: dp[i] = True break return dp[len(s)] 12345678910111213141516class Solution &#123; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordDict); boolean[] dp = new boolean[s.length() + 1]; dp[0] = true; for (int i = 0; i &lt; s.length() + 1; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (dp[j] &amp;&amp; wordSet.contains(s.substring(j, i))) &#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.length()]; &#125;&#125; 152. 乘积最大子数组给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）。 示例 1: 输入: [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。 示例 2: 输入: [-2,0,-1] 输出: 0 解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 1234567891011121314class Solution(object): def maxProduct(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; max_n, min_n, res = nums[0], nums[0], nums[0] for i in xrange(1, len(nums)): tmp = max_n max_n = max(max_n * nums[i], min_n * nums[i], nums[i]) min_n = min(tmp * nums[i], min_n * nums[i], nums[i]) if max_n &gt; res: res = max_n return res 221. 最大正方形 [n]在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例: 输入: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 输出: 4 1234567891011121314151617class Solution(object): def maximalSquare(self, matrix): &quot;&quot;&quot; :type matrix: List[List[str]] :rtype: int &quot;&quot;&quot; if matrix is None or len(matrix) == 0 or len(matrix[0]) == 0: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0 for _ in xrange(cols + 1)] for _ in xrange(rows + 1)] max_edge = 0 for i in xrange(1, rows + 1): for j in xrange(1, cols + 1): if matrix[i - 1][j - 1] == &#x27;1&#x27;: dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]) + 1 max_edge = max(max_edge, dp[i][j]) return max_edge * max_edge 264. 丑数 II编写一个程序，找出第 n 个丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例: 输入: n = 10 输出: 12 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明: 1 是丑数。 n 不超过1690。 PythonJava123456789101112131415161718class Solution(object): def nthUglyNumber(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; dp = [1 for i in xrange(n)] i2, i3, i5 = 0, 0, 0 for i in xrange(1, n): min_v = min(dp[i2] * 2, dp[i3] * 3, dp[i5] * 5) dp[i] = min_v if min_v == dp[i2] * 2: i2 += 1 if min_v == dp[i3] * 3: i3 += 1 if min_v == dp[i5] * 5: i5+= 1 return dp[n - 1]123456789101112131415161718192021class Solution &#123; public int nthUglyNumber(int n) &#123; int idx2 = 0, idx3 = 0, idx5 = 0; int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i &lt; n; i++) &#123; int minV = Math.min(dp[idx2] * 2, Math.min(dp[idx3] * 3, dp[idx5] * 5)); dp[i] = minV; if (minV == dp[idx2] * 2) &#123; idx2 += 1; &#125; if (minV == dp[idx3] * 3) &#123; idx3 += 1; &#125; if (minV == dp[idx5] * 5) &#123; idx5 += 1; &#125; &#125; return dp[n - 1]; &#125;&#125; 279. 完全平方数 [n]给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1: 输入: n = 12 输出: 3 解释: 12 = 4 + 4 + 4. 示例 2: 输入: n = 13 输出: 2 解释: 13 = 4 + 9. PythonJava1234567891011121314class Solution(object): def numSquares(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; dp = [0 for _ in xrange(n + 1)] for i in xrange(1, n + 1): j = 1 dp[i] = i while i - j * j &gt;= 0: dp[i] = min(dp[i], dp[i - j * j] + 1) j += 1 return dp[n]1234567891011121314class Solution &#123; public int numSquares(int n) &#123; int[] dp = new int[n + 1]; for (int i = 0; i &lt;= n; i++) &#123; dp[i] = i; int j = 1; while (i - j * j &gt;= 0) &#123; dp[i] = Math.min(dp[i], dp[i - j * j] + 1); j += 1; &#125; &#125; return dp[n]; &#125;&#125; 300. 最长上升子序列给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 输入: [10,9,2,5,3,7,101,18] 输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 PythonJava1234567891011121314151617class Solution(object): def lengthOfLIS(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if nums is None or len(nums) == 0: return 0 dp = [0 for _ in xrange(len(nums))] res = 0 for i in xrange(len(nums)): dp[i] = 1 for j in xrange(i): if nums[i] &gt; nums[j]: dp[i] = max(dp[i], dp[j] + 1) res = max(dp[i], res) return res12345678910111213141516171819class Solution &#123; public int lengthOfLIS(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int res = 0; int[] dp = new int[nums.length]; for (int i = 0; i &lt; nums.length; i++) &#123; dp[i] = 1; for (int j = 0; j &lt; i; j++) &#123; if (nums[i] &gt; nums[j]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; &#125; res = Math.max(dp[i], res); &#125; return res; &#125;&#125; 309. 最佳买卖股票时机含冷冻期 [n]给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​ 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例: 输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 12345678910111213class Solution(object): def maxProfit(self, prices): &quot;&quot;&quot; :type prices: List[int] :rtype: int &quot;&quot;&quot; hold, sold, rest = -1 &lt;&lt; 32, 0, 0 for price in prices: prev_sold = sold sold = hold + price hold = max(hold, rest - price) rest = max(rest, prev_sold) return max(rest, sold) 322. 零钱兑换 [n]给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1: 输入: coins = [1, 2, 5], amount = 11 输出: 3 解释: 11 = 5 + 5 + 1 示例 2: 输入: coins = [2], amount = 3 输出: -1 说明: 你可以认为每种硬币的数量是无限的。 PythonJava123456789101112131415161718class Solution(object): def coinChange(self, coins, amount): &quot;&quot;&quot; :type coins: List[int] :type amount: int :rtype: int &quot;&quot;&quot; INT_MAX = (1 &lt;&lt; 31) - 1 dp = [INT_MAX for _ in xrange(amount + 1)] dp[0] = 0 for i in xrange(1, amount + 1): for j in coins: if i &gt;= j: dp[i] = min(dp[i], dp[i - j] + 1) if dp[amount] == INT_MAX: return -1 else: return dp[amount]123456789101112131415161718class Solution &#123; public int coinChange(int[] coins, int amount) &#123; int[] dp = new int[amount + 1]; final int max = amount + 1; for (int i = 0; i &lt; dp.length; i++) &#123; dp[i] = max; &#125; dp[0] = 0; for (int i = 1; i &lt; amount + 1; i++) &#123; for (int coin : coins) &#123; if (i &gt;= coin) &#123; dp[i] = Math.min(dp[i], dp[i - coin] + 1); &#125; &#125; &#125; return dp[amount] == max ? -1 : dp[amount]; &#125;&#125; 343. 整数拆分 [n]给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例 1: 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。 PythonJava12345678910111213class Solution(object): def integerBreak(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; dp = [0 for _ in xrange(n + 1)] for i in xrange(2, n + 1): cur_max = 0 for j in xrange(1, i): cur_max = max(cur_max, j * (i - j), j * dp[i - j]) dp[i] = cur_max return dp[n]1234567891011121314class Solution &#123; public int integerBreak(int n) &#123; int[] dp = new int[n + 1]; dp[0] = dp[1] = 0; for (int i = 2; i &lt;= n; i++) &#123; int curMax = 0; for (int j = 1; j &lt; i; j++) &#123; curMax = Math.max(curMax, Math.max(j * (i - j), j * dp[i - j])); &#125; dp[i] = curMax; &#125; return dp[n]; &#125;&#125; 357. 计算各个位数不同的数字个数给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x &lt; 10^n 。 示例: 输入: 2 输出: 91 解释: 答案应为除去 11,22,33,44,55,66,77,88,99 外，在 [0,100) 区间内的所有数字。 PythonJava1234567891011121314151617class Solution(object): def countNumbersWithUniqueDigits(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; if n == 0: return 1 dp = [0 for _ in xrange(11)] dp[1] = 10 dp[2] = 9 * 9 for i in xrange(3, 11): dp[i] = dp[i - 1] * (10 - i + 1) res = 0 for i in xrange(min(n, 10) + 1): res += dp[i] return res123456789101112131415161718class Solution &#123; public int countNumbersWithUniqueDigits(int n) &#123; if (n == 0) &#123; return 1; &#125; int[] dp = new int[11]; dp[1] = 10; dp[2] = 9 * 9; for (int i = 3; i &lt;= 10; i++) &#123; dp[i] = dp[i - 1] * (10 - i + 1); &#125; int res = 0; for (int i = 1; i &lt;= Math.min(10, n); i++) &#123; res += dp[i]; &#125; return res; &#125;&#125; 377. 组合总和 Ⅳ [n]给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 示例: nums = [1, 2, 3] target = 4 所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) 请注意，顺序不同的序列被视作不同的组合。 因此输出为 7。 PythonJava1234567891011121314class Solution(object): def combinationSum4(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; dp = [0 for _ in xrange(target + 1)] dp[0] = 1 for i in xrange(1, target + 1): for n in nums: if i &gt;= n: dp[i] += dp[i - n] return dp[target]1234567891011121314class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 1; i &lt;= target; i++) &#123; for (int n : nums) &#123; if (i &gt;= n) &#123; dp[i] += dp[i - n]; &#125; &#125; &#125; return dp[target]; &#125;&#125; 416. 分割等和子集 [n]给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200 示例 1: 输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例 2: 输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集. PythonJava123456789101112131415161718192021class Solution(object): def canPartition(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; n = len(nums) total = sum(nums) if total % 2 == 1: return False total = total / 2 dp = [[False for _ in xrange(total + 1)] for _ in xrange(n + 1)] for i in xrange(n + 1): dp[i][0] = True for i in xrange(1, n + 1): for j in xrange(1, total + 1): if j - nums[i - 1] &lt; 0: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j - nums[i - 1]] or dp[i - 1][j] return dp[n][total]1234567891011121314151617181920212223242526272829class Solution &#123; public boolean canPartition(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return false; &#125; int total = 0; for (int n : nums) &#123; total += n; &#125; if (total % 2 == 1) &#123; return false; &#125; int target = total / 2; boolean[][] dp = new boolean[nums.length + 1][target + 1]; for (int i = 0; i &lt;= nums.length; i++) &#123; dp[i][0] = true; &#125; for (int i = 1; i &lt;= nums.length; i++) &#123; for (int j = 1; j &lt;= target; j++) &#123; if (j - nums[i - 1] &lt; 0) &#123; dp[i][j] = dp[i - 1][j]; &#125; else &#123; dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]]; &#125; &#125; &#125; return dp[nums.length][target]; &#125;&#125; 494. 目标和 [n]给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 示例 1: 输入: nums: [1, 1, 1, 1, 1], S: 3 输出: 5 解释: -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3 一共有5种方法让最终目标和为3。 注意: 数组非空，且长度不会超过20。 初始的数组的和不会超过1000。 保证返回的最终结果能被32位整数存下。 PythonJava1234567891011121314151617class Solution(object): def findTargetSumWays(self, nums, S): &quot;&quot;&quot; :type nums: List[int] :type S: int :rtype: int &quot;&quot;&quot; total = sum(nums) if S &gt; total or (S + total) % 2 != 0: return 0 P = (S + total) / 2 dp = [0 for _ in xrange(P + 1)] dp[0] = 1 for n in nums: for i in xrange(P, n - 1, -1): dp[i] += dp[i - n] return dp[P]1234567891011121314151617181920class Solution &#123; public int findTargetSumWays(int[] nums, int S) &#123; int total = 0; for (int n : nums) &#123; total += n; &#125; if (S &gt; total || (S + total) % 2 != 0) &#123; return 0; &#125; int P = (S + total) / 2; int[] dp = new int[P + 1]; dp[0] = 1; for (int n : nums) &#123; for (int i = P; i &gt;= n; i--) &#123; dp[i] += dp[i - n]; &#125; &#125; return dp[P]; &#125;&#125; 516. 最长回文子序列给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。 示例 1: 输入: \"bbbab\" 输出: 4 一个可能的最长回文子序列为 \"bbbb\"。 示例 2: 输入: \"cbbd\" 输出: 2 一个可能的最长回文子序列为 \"bb\"。 12345678910111213141516class Solution(object): def longestPalindromeSubseq(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; n = len(s) dp = [[0 for _ in xrange(n)] for _ in xrange(n)] for i in xrange(n - 1, -1, -1): dp[i][i] = 1 for j in xrange(i + 1, n): if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1] 650. 只有两个键的键盘最初在一个记事本上只有一个字符 ‘A’。你每次可以对这个记事本进行两种操作： Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。Paste (粘贴) : 你可以粘贴你上一次复制的字符。给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 ‘A’。输出能够打印出 n 个 ‘A’ 的最少操作次数。 示例 1: 输入: 3 输出: 3 解释: 最初, 我们只有一个字符 'A'。 第 1 步, 我们使用 Copy All 操作。 第 2 步, 我们使用 Paste 操作来获得 'AA'。 第 3 步, 我们使用 Paste 操作来获得 'AAA'。 说明: n 的取值范围是 [1, 1000] 。 12345678910111213class Solution(object): def minSteps(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; dp = [n] * (n + 1) dp[0] = dp[1] = 0 for i in xrange(2, n + 1): for j in xrange(1, i): if i % j == 0: dp[i] = min(dp[i], dp[j] + i / j) return dp[n] 673. 最长递增子序列的个数给定一个未排序的整数数组，找到最长递增子序列的个数。 示例 1: 输入: [1,3,5,4,7] 输出: 2 解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。 示例 2: 输入: [2,2,2,2,2] 输出: 5 解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。 注意: 给定的数组长度不超过 2000 并且结果一定是32位有符号整数。 12345678910111213141516171819202122232425class Solution(object): def findNumberOfLIS(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if nums is None or len(nums) == 0: return 0 n = len(nums) dp = [1 for _ in xrange(n)] counter = [1 for _ in xrange(n)] for i in xrange(n): for j in xrange(i): if nums[i] &gt; nums[j]: if dp[j] + 1 &gt; dp[i]: dp[i] = dp[j] + 1 counter[i] = counter[j] elif dp[j] + 1 == dp[i]: counter[i] += counter[j] max_len = max(dp) res = 0 for i in xrange(n): if dp[i] == max_len: res += counter[i] return res","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode之数组(简单)","slug":"LeetCode-数组-简单","date":"2021-01-02T05:34:23.000Z","updated":"2021-01-02T06:03:34.985Z","comments":false,"path":"posts/3027083408.html","link":"","permalink":"https://leel0330.github.io/posts/3027083408.html","excerpt":"数组(简单)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"数组(简单)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 53. 最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 PythonC++12345678910111213class Solution(object): def maxSubArray(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; dp = [0 for _ in xrange(len(nums))] res = nums[0] dp[0] = nums[0] for i in xrange(1, len(nums)): dp[i] = max(dp[i - 1] + nums[i], nums[i]) res = max(res, dp[i]) return res12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n == 0) &#123; return 0; &#125; vector&lt;int&gt; dp(n, 0); dp[0] = nums[0]; int res = dp[0]; for (int i = 1; i &lt; n; i++) &#123; dp[i] = max(dp[i - 1] + nums[i], nums[i]); res = max(res, dp[i]); &#125; return res; &#125;&#125;; 118. 杨辉三角 [n]给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 示例: 输入: 5 输出: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] PythonC++1234567891011121314class Solution(object): def generate(self, numRows): &quot;&quot;&quot; :type numRows: int :rtype: List[List[int]] &quot;&quot;&quot; res = [] item = [] for i in xrange(numRows): item.insert(0, 1) for j in xrange(1, len(item) - 1): item[j] = item[j] + item[j + 1] res.append(item[:]) return res123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: vector&lt;vector&lt;int&gt; &gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt; &gt; res; vector&lt;int&gt; tmp; for (int i = 0; i &lt; numRows; i++) &#123; tmp.insert(tmp.begin(), 1); for (int j = 1; j &lt; tmp.size() - 1; j++) &#123; tmp[j] = tmp[j] + tmp[j + 1]; &#125; vector&lt;int&gt; row = tmp; res.push_back(row); &#125; return res; &#125;&#125;; 119. 杨辉三角 II给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 示例: 输入: 3 输出: [1,3,3,1] PythonC++123456789101112class Solution(object): def getRow(self, rowIndex): &quot;&quot;&quot; :type rowIndex: int :rtype: List[int] &quot;&quot;&quot; item = [] for i in xrange(rowIndex + 1): item.insert(0, 1) for j in xrange(1, len(item) - 1): item[j] = item[j] + item[j + 1] return item123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; res; for (int i = 0; i &lt; rowIndex + 1; i++) &#123; res.insert(res.begin(), 1); for (int j = 1; j &lt; res.size() - 1; j++) &#123; res[j] = res[j] + res[j + 1]; &#125; &#125; return res; &#125;&#125;; 121. 买卖股票的最佳时机给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为0。 PythonC++1234567891011class Solution(object): def maxProfit(self, prices): &quot;&quot;&quot; :type prices: List[int] :rtype: int &quot;&quot;&quot; min_v, max_v = 1 &lt;&lt; 32 -1, 0 for price in prices: min_v = min(min_v, price) max_v = max(max_v, price - min_v) return max_v123456789101112131415161718#include &lt;climits&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int max_v = 0; int min_v = INT_MAX; for (auto iter = prices.cbegin(); iter != prices.cend(); iter++) &#123; min_v = min(min_v, *iter); max_v = max(max_v, *iter - min_v); &#125; return max_v; &#125;&#125;; 122. 买卖股票的最佳时机 II给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 PythonC++1234567891011121314151617class Solution(object): def maxProfit(self, prices): &quot;&quot;&quot; :type prices: List[int] :rtype: int &quot;&quot;&quot; res, i, n = 0, 0, len(prices) while i &lt; n: while i &lt; n - 1 and prices[i + 1] &lt;= prices[i]: i += 1 min_v = prices[i] i += 1 while i &lt; n - 1 and prices[i + 1] &gt;= prices[i]: i += 1 if i &lt; n: res += prices[i] - min_v return res123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); int res = 0, i = 0; int min_v = 0; while (i &lt; n) &#123; while (i &lt; n - 1 &amp;&amp; prices[i + 1] &lt;= prices[i]) &#123; i += 1; &#125; min_v = prices[i]; i += 1; while (i &lt; n - 1 &amp;&amp; prices[i + 1] &gt;= prices[i]) &#123; i += 1; &#125; if (i &lt; n) &#123; res += (prices[i] - min_v); &#125; &#125; return res; &#125;&#125;; 448. 找到所有数组中消失的数字给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。 示例: 输入: [4,3,2,7,8,2,3,1] 输出: [5,6] PythonC++123456789101112131415class Solution(object): def findDisappearedNumbers(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[int] &quot;&quot;&quot; for v in nums: idx = abs(v) - 1 if nums[idx] &gt; 0: nums[idx] = -nums[idx] res = [] for i in xrange(len(nums)): if nums[i] &gt; 0: res.append(i + 1) return res1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; for (int i = 0; i &lt; nums.size(); i++) &#123; int idx = abs(nums[i]) - 1; if (nums[idx] &gt; 0) &#123; nums[idx] = -nums[idx]; &#125; &#125; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] &gt; 0) &#123; res.push_back(i + 1); &#125; &#125; return res; &#125;&#125;; 532. 数组中的K-diff数对给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k. 示例 1: 输入: [3, 1, 4, 1, 5], k = 2 输出: 2 解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。 尽管数组中有两个1，但我们只应返回不同的数对的数量。 示例 2: 输入:[1, 2, 3, 4, 5], k = 1 输出: 4 解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。 示例 3: 输入: [1, 3, 1, 5, 4], k = 0 输出: 1 解释: 数组中只有一个 0-diff 数对，(1, 1)。 注意: 数对 (i, j) 和数对 (j, i) 被算作同一数对。 数组的长度不超过10,000。 所有输入的整数的范围在 [-1e7, 1e7]。 PythonC++123456789101112131415161718192021222324class Solution(object): def findPairs(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; if nums is None or len(nums) == 0 or k &lt; 0: return 0 m = &#123;&#125; for v in nums: if v not in m: m[v] = 1 else: m[v] += 1 res = 0 for key, val in m.iteritems(): if k == 0: if val &gt;= 2: res += 1 else: if key + k in m: res += 1 return res12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: int findPairs(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_map&lt;int, int&gt; m; int res = 0; for (auto n : nums) &#123; m[n]++; &#125; for (auto item : m) &#123; if (k == 0) &#123; if (item.second &gt; 1) &#123; res += 1; &#125; &#125; else if (k &gt; 0) &#123; if (m.find(item.first + k) != m.end()) &#123; res += 1; &#125; &#125; &#125; return res; &#125;&#125;; 581. 最短无序连续子数组给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 你找到的子数组应是最短的，请输出它的长度。 示例 1: 输入: [2, 6, 4, 8, 10, 9, 15] 输出: 5 解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。 说明 : 输入的数组长度范围在 [1, 10,000]。 输入的数组可能包含重复元素 ，所以升序的意思是&lt;= PythonC++12345678910111213141516171819202122class Solution(object): def findUnsortedSubarray(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; sorted_nums = sorted(nums[:]) left, right = 0, len(nums) - 1 while left &lt; right: if sorted_nums[left] == nums[left]: left += 1 else: break while right &gt; left: if sorted_nums[right] == nums[right]: right -= 1 else: break if left &lt; right: return right - left + 1 else: return 012345678910111213141516171819202122232425#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; sorted_nums = nums; sort(sorted_nums.begin(), sorted_nums.end()); int left = 0, right = n - 1; while (left &lt; right &amp;&amp; nums[left] == sorted_nums[left]) &#123; left += 1; &#125; while (left &lt; right &amp;&amp; nums[right] == sorted_nums[right]) &#123; right -= 1; &#125; if (left &lt; right) &#123; return right - left + 1; &#125; return 0; &#125;&#125;; 605. 种花问题假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。 示例 1: 输入: flowerbed = [1,0,0,0,1], n = 1 输出: True 示例 2: 输入: flowerbed = [1,0,0,0,1], n = 2 输出: False 注意: 数组内已种好的花不会违反种植规则。 输入的数组长度范围为 [1, 20000]。 n 是非负整数，且不会超过输入数组的大小。 PythonC++1234567891011121314151617class Solution(object): def canPlaceFlowers(self, flowerbed, n): &quot;&quot;&quot; :type flowerbed: List[int] :type n: int :rtype: bool &quot;&quot;&quot; nums = [0] + flowerbed + [0] i = 1 cnt = 0 while i &lt; len(flowerbed) + 1: if nums[i - 1] == 0 and nums[i] == 0 and nums[i + 1] == 0: cnt += 1 i += 2 else: i += 1 return cnt &gt;= n1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) &#123; vector&lt;int&gt; nums = flowerbed; nums.insert(nums.begin(), 0); nums.insert(nums.end(), 0); int i = 1, cnt = 0; while (i &lt; nums.size() - 1) &#123; if (nums[i - 1] == 0 &amp;&amp; nums[i] == 0 &amp;&amp; nums[i + 1] == 0) &#123; cnt += 1; i += 2; &#125; else &#123; i += 1; &#125; &#125; return cnt &gt;= n; &#125;&#125;; 643. 子数组最大平均数 I给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。 示例 1: 输入: [1,12,-5,-6,50,3], k = 4 输出: 12.75 解释: 最大平均数 (12-5-6+50)/4 = 51/4 = 12.75 注意: 1 &lt;= k &lt;= n &lt;= 30,000。 所给数据范围 [-10,000，10,000]。 PythonC++12345678910111213class Solution(object): def findMaxAverage(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: float &quot;&quot;&quot; res = sum(nums[:k]) sub_sum = res for i in xrange(k, len(nums)): sub_sum = sub_sum + nums[i] - nums[i - k] res = max(res, sub_sum) return res / (k * 1.0)1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: double findMaxAverage(vector&lt;int&gt;&amp; nums, int k) &#123; int tmp_sum = 0, res_sum = 0; for (int i = 0; i &lt; k; i++) &#123; tmp_sum += nums[i]; &#125; res_sum = tmp_sum; for (int i = k; i &lt; nums.size(); i++) &#123; tmp_sum = tmp_sum - nums[i - k] + nums[i]; res_sum = max(res_sum, tmp_sum); &#125; return res_sum * 1.0 / k; &#125;&#125;; 665. 非递减数列 [n]给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。 我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 &lt;= i &lt; n)，满足 array[i] &lt;= array[i + 1]。 示例 1: 输入: [4,2,3] 输出: True 解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。 示例 2: 输入: [4,2,1] 输出: False 解释: 你不能在只改变一个元素的情况下将其变为非递减数列。 说明: n 的范围为 [1, 10,000]。 PythonC++123456789101112131415class Solution(object): def checkPossibility(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; cnt = 0 for i in xrange(1, len(nums)): if nums[i - 1] &gt; nums[i]: cnt += 1 if i - 2 &lt; 0 or nums[i - 2] &lt;= nums[i]: nums[i - 1] = nums[i] else: nums[i] = nums[i - 1] return cnt &lt;= 11234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: bool checkPossibility(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int cnt = 0; for (int i = 1; i &lt; n; i++) &#123; if (nums[i - 1] &gt; nums[i]) &#123; cnt += 1; if (i - 2 &lt; 0 || nums[i - 2] &lt;= nums[i]) &#123; nums[i - 1] = nums[i]; &#125; else &#123; nums[i] = nums[i - 1]; &#125; &#125; &#125; return cnt &lt;= 1; &#125;&#125;; 674. 最长连续递增序列给定一个未经排序的整数数组，找到最长且连续的的递增序列。 示例 1: 输入: [1,3,5,4,7] 输出: 3 解释: 最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 示例 2: 输入: [2,2,2,2,2] 输出: 1 解释: 最长连续递增序列是 [2], 长度为1。 注意：数组长度不会超过10000。 PythonC++123456789101112131415161718class Solution(object): def findLengthOfLCIS(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; cnt = 0 max_cnt = 0 for i, v in enumerate(nums): if i == 0: cnt, max_cnt = 1, 1 else: if nums[i - 1] &lt; v: cnt += 1 max_cnt = max(max_cnt, cnt) else: cnt = 1 return max_cnt123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n == 0) &#123; return 0; &#125; int cnt = 1, max_cnt = 1; for (int i = 1; i &lt; nums.size(); i++) &#123; if (nums[i - 1] &lt; nums[i]) &#123; cnt += 1; max_cnt = max(max_cnt, cnt); &#125; else &#123; cnt = 1; &#125; &#125; return max_cnt; &#125;&#125;; 697. 数组的度 [n]给定一个非空且只包含非负数的整数数组nums, 数组的度的定义是指数组里任一元素出现频数的最大值。 你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。 示例 1: 输入: [1, 2, 2, 3, 1] 输出: 2 解释: 输入数组的度是2，因为元素1和2的出现频数最大，均为2. 连续子数组里面拥有相同度的有如下所示: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] 最短连续子数组[2, 2]的长度为2，所以返回2. 示例 2: 输入: [1,2,2,3,1,4,2] 输出: 6 注意: nums.length 在1到50,000区间范围内。 nums[i] 是一个在0到49,999范围内的整数。 PythonC++123456789101112131415161718192021222324class Solution(object): def findShortestSubArray(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; m = &#123;&#125; for i, v in enumerate(nums): if v not in m: m[v] = [1, i, i] else: m[v][0] += 1 m[v][2] = i res = len(nums) max_cnt = 0 for key, item in m.iteritems(): if item[0] &gt; max_cnt: max_cnt = item[0] res = item[2] - item[1] + 1 elif item[0] == max_cnt: cur_len = item[2] - item[1] + 1 if res &gt; cur_len: res = cur_len return res1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: int findShortestSubArray(vector&lt;int&gt;&amp; nums) &#123; int max_cnt = 0; int n = nums.size(); int res = n; unordered_map&lt;int, int&gt; m; unordered_map&lt;int, pair&lt;int, int&gt; &gt; index; for (int i = 0; i &lt; nums.size(); i++) &#123; m[nums[i]]++; if (m[nums[i]] == 1) &#123; index[nums[i]] = make_pair(i, i); &#125; else &#123; index[nums[i]].second = i; &#125; max_cnt = max(max_cnt, m[nums[i]]); &#125; for (auto item : m) &#123; if (item.second == max_cnt) &#123; res = min(res, index[item.first].second - index[item.first].first + 1); &#125; &#125; return res; &#125;&#125;; 746. 使用最小花费爬楼梯 [n]数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 costi。 每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。 您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。 示例 1: 输入: cost = [10, 15, 20] 输出: 15 解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。 示例 2: 输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出: 6 解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。 注意： cost 的长度将会在 [2, 1000]。 每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。 PythonC++1234567891011121314class Solution(object): def minCostClimbingStairs(self, cost): &quot;&quot;&quot; :type cost: List[int] :rtype: int &quot;&quot;&quot; n = len(cost) dp = [0 for _ in xrange(n + 1)] dp[0] = cost[0] dp[1] = cost[1] for i in xrange(2, n + 1): cost_v = cost[i] if i != n else 0 dp[i] = min(dp[i - 1], dp[i - 2]) + cost_v return dp[n]12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; int n = cost.size(); vector&lt;int&gt; dp(n + 1, 0); dp[0] = cost[0]; dp[1] = cost[1]; for (int i = 2; i &lt; n + 1; i++) &#123; int cur_cost = i == n ? 0 : cost[i]; dp[i] = min(dp[i - 1], dp[i - 2]) + cur_cost; &#125; return dp[n]; &#125;&#125;; 849. 到最近的人的最大距离 [n]在一排座位（ seats）中，1 代表有人坐在座位上，0 代表座位上是空的。 至少有一个空座位，且至少有一人坐在座位上。 亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。 返回他到离他最近的人的最大距离。 示例 1： 输入：[1,0,0,0,1,0,1] 输出：2 解释： 如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为 2 。 如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为 1 。 因此，他到离他最近的人的最大距离是 2 。 示例 2： 输入：[1,0,0,0] 输出：3 解释： 如果亚历克斯坐在最后一个座位上，他离最近的人有 3 个座位远。 这是可能的最大距离，所以答案是 3 。 提示： 1 &lt;= seats.length &lt;= 20000 seats 中只含有 0 和 1，至少有一个 0，且至少有一个 1。 PythonC++12345678910111213141516171819class Solution(object): def maxDistToClosest(self, seats): &quot;&quot;&quot; :type seats: List[int] :rtype: int &quot;&quot;&quot; left = -1 max_dis = 0 for i, v in enumerate(seats): if v == 0: continue if left == -1: max_dis = max(max_dis, i) else: max_dis = max(max_dis, (i - left) / 2) left = i if seats[-1] == 0: max_dis = max(max_dis, len(seats) - 1 - left) return max_dis1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: int maxDistToClosest(vector&lt;int&gt;&amp; seats) &#123; vector&lt;int&gt; persons; for (int i = 0; i &lt; seats.size(); i++) &#123; if (seats[i] == 1) &#123; persons.push_back(i); &#125; &#125; int n = persons.size(), m = seats.size(); int res = 0; for (int i = 0; i &lt; n; i++) &#123; if (i == 0) &#123; res = max(res, persons[i]); &#125; else &#123; res = max(res, (persons[i] - persons[i - 1]) / 2); &#125; &#125; if (n &gt; 0) &#123; res = max(res, m - 1 - persons.back()); &#125; return res; &#125;&#125;; 941. 有效的山脉数组给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。 让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组： A.length &gt;= 3 在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得： A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] A[i] &gt; A[i+1] &gt; … &gt; A[B.length - 1] 示例 1： 输入：[2,1] 输出：false 示例 2： 输入：[3,5,5] 输出：false 示例 3： 输入：[0,3,2,1] 输出：true 提示： 0 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt;= 10000 PythonC++123456789101112class Solution(object): def validMountainArray(self, A): &quot;&quot;&quot; :type A: List[int] :rtype: bool &quot;&quot;&quot; left, right = 0, len(A) - 1 while left + 1 &lt; len(A) and A[left] &lt; A[left + 1]: left += 1 while right - 1 &gt;= 0 and A[right] &lt; A[right - 1]: right -= 1 return left != 0 and right != len(A) - 1 and left == right1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: bool validMountainArray(vector&lt;int&gt;&amp; A) &#123; int n = A.size(); int left = 0; int right = n - 1; while (left &lt; n - 1 &amp;&amp; A[left] &lt; A[left + 1]) &#123; left += 1; &#125; while (right &gt; 0 &amp;&amp; A[right] &lt; A[right - 1]) &#123; right -= 1; &#125; return left != 0 &amp;&amp; right != n - 1 &amp;&amp; left == right; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode之数组(中等)","slug":"LeetCode-数组-中等","date":"2020-12-31T13:25:17.000Z","updated":"2021-01-02T05:33:37.278Z","comments":false,"path":"posts/3239008047.html","link":"","permalink":"https://leel0330.github.io/posts/3239008047.html","excerpt":"数组(中等)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"数组(中等)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 31. 下一个排列 [n]实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1 1234567891011121314151617181920212223class Solution(object): def nextPermutation(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. &quot;&quot;&quot; n = len(nums) i = n - 2 while i &gt;= 0 and nums[i + 1] &lt;= nums[i]: i -= 1 if i &gt;= 0: j = n - 1 while nums[j] &lt;= nums[i]: j -= 1 nums[i], nums[j] = nums[j], nums[i] self.helper(nums, i + 1, n - 1) def helper(self, nums, i, j): s, e = i, j while s &lt; e: nums[s], nums[e] = nums[e], nums[s] s += 1 e -= 1 40. 组合总和 II给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [ [1,2,2], [5] ] PythonJava123456789101112131415161718192021222324class Solution(object): def combinationSum2(self, candidates, target): &quot;&quot;&quot; :type candidates: List[int] :type target: int :rtype: List[List[int]] &quot;&quot;&quot; candidates = sorted(candidates) item, res = [], [] self.helper(candidates, target, 0, item, res) return res def helper(self, candidates, target, idx, item, res): if sum(item) == target: res.append(item[:]) return for i in xrange(idx, len(candidates)): if i &gt; idx and candidates[i] == candidates[i - 1]: continue if sum(item) + candidates[i] &gt; target: continue item.append(candidates[i]) self.helper(candidates, target, i + 1, item, res) item.pop(-1)123456789101112131415161718192021222324252627282930class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; item = new ArrayList&lt;&gt;(); helper(candidates, 0, target, item, res); return res; &#125; private void helper(int[] candidates, int idx, int target, List&lt;Integer&gt; item, List&lt;List&lt;Integer&gt;&gt; res) &#123; if (target &lt; 0) &#123; return; &#125; if (target == 0) &#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); tmp.addAll(item); res.add(tmp); return; &#125; for (int i = idx; i &lt; candidates.length; i++) &#123; if (i &gt; idx &amp;&amp; candidates[i] == candidates[i - 1]) &#123; continue; &#125; item.add(candidates[i]); helper(candidates, i + 1, target - candidates[i], item, res); item.remove(item.size() - 1); &#125; &#125;&#125; 55. 跳跃游戏 [n]给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1: 输入: [2,3,1,1,4] 输出: true 解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。 示例 2: 输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 1234567891011class Solution(object): def canJump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; last_pos = len(nums) - 1 for i in xrange(len(nums) - 1, -1, -1): if i + nums[i] &gt;= last_pos: last_pos = i return last_pos == 0 73. 矩阵置零给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。 示例 1: 输入: [ [1,1,1], [1,0,1], [1,1,1] ] 输出: [ [1,0,1], [0,0,0], [1,0,1] ] 示例 2: 输入: [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] 输出: [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] 进阶: 一个直接的解决方案是使用 O(mn) 的额外空间，但这并不是一个好的解决方案。 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。 你能想出一个常数空间的解决方案吗？ 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def setZeroes(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: None Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; rows = len(matrix) cols = len(matrix[0]) row0_flag = False col0_flag = False # 找第一行是否有0 for j in range(cols): if matrix[0][j] == 0: row0_flag = True break # 第一列是否有0 for i in range(rows): if matrix[i][0] == 0: col0_flag = True break # 把第一行或者第一列作为 标志位 for i in range(1, rows): for j in range(1, cols): if matrix[i][j] == 0: matrix[i][0] = matrix[0][j] = 0 # 置0 for i in range(1, rows): for j in range(1, cols): if matrix[i][0] == 0 or matrix[0][j] == 0: matrix[i][j] = 0 if row0_flag: for j in range(cols): matrix[0][j] = 0 if col0_flag: for i in range(rows): matrix[i][0] = 0 81. 搜索旋转排序数组 II假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 示例 1: 输入: nums = [2,5,6,0,0,1,2], target = 0 输出: true 示例 2: 输入: nums = [2,5,6,0,0,1,2], target = 3 输出: false 进阶: 这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ PythonJava12345678910111213141516171819202122232425class Solution(object): def search(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: bool &quot;&quot;&quot; left, right = 0, len(nums) - 1 while left &lt;= right: mid = (left + right) / 2 if nums[mid] == target: return True if nums[mid] &gt; nums[left]: if nums[left] &lt;= target &lt; nums[mid]: right = mid - 1 else: left = mid + 1 elif nums[mid] &lt; nums[left]: if nums[mid] &lt; target &lt;= nums[right]: left = mid + 1 else: right = mid - 1 else: left += 1 return False123456789101112131415161718192021222324252627282930class Solution &#123; public boolean search(int[] nums, int target) &#123; if (nums == null || nums.length == 0) &#123; return false; &#125; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; return true; &#125; if (nums[mid] &gt; nums[left]) &#123; if (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; else if (nums[mid] &lt; nums[left]) &#123; if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; else &#123; left += 1; &#125; &#125; return false; &#125;&#125; 90. 子集 II给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 输入: [1,2,2] 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] PythonJava12345678910111213141516171819class Solution(object): def subsetsWithDup(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; nums = sorted(nums) item, res = [], [] self.helper(nums, 0, item, res) return res def helper(self, nums, idx, item, res): res.append(item[:]) for i in xrange(idx, len(nums)): if i &gt; idx and nums[i] == nums[i - 1]: continue item.append(nums[i]) self.helper(nums, i + 1, item, res) item.pop(-1)1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (nums == null || nums.length == 0) &#123; return res; &#125; Arrays.sort(nums); List&lt;Integer&gt; item = new ArrayList&lt;&gt;(); helper(nums, 0, item, res); return res; &#125; private void helper(int[] nums, int idx, List&lt;Integer&gt; item, List&lt;List&lt;Integer&gt;&gt; res) &#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); tmp.addAll(item); res.add(tmp); if (idx == nums.length) &#123; return; &#125; for (int i = idx; i &lt; nums.length; i++) &#123; if (i &gt; idx &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; item.add(nums[i]); helper(nums, i + 1, item, res); item.remove(item.size() - 1); &#125; &#125;&#125; 153. 寻找旋转排序数组中的最小值假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 你可以假设数组中不存在重复元素。 示例 1: 输入: [3,4,5,1,2] 输出: 1 示例 2: 输入: [4,5,6,7,0,1,2] 输出: 0 PythonJava1234567891011121314class Solution(object): def findMin(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; left, right = 0, len(nums) - 1 while left &lt; right: mid = left + (right - left) / 2 if nums[mid] &gt; nums[right]: left = mid + 1 else: right = mid return nums[left]1234567891011121314class Solution &#123; public int findMin(int[] nums) &#123; int left = 0, right = nums.length - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &gt; nums[right]) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return nums[left]; &#125;&#125; 287. 寻找重复数 [n]给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例 1: 输入: [1,3,4,2,2] 输出: 2 示例 2: 输入: [3,1,3,4,2] 输出: 3 说明： 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 PythonJava1234567891011121314151617class Solution(object): def findDuplicate(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; fast, slow = nums[0], nums[0] while True: fast = nums[nums[fast]] slow = nums[slow] if fast == slow: break slow = nums[0] while slow != fast: slow = nums[slow] fast = nums[fast] return slow123456789101112131415161718class Solution &#123; public int findDuplicate(int[] nums) &#123; int slow = nums[0], fast = nums[0]; while (true) &#123; slow = nums[slow]; fast = nums[nums[fast]]; if (slow == fast) &#123; break; &#125; &#125; slow = nums[0]; while (slow != fast) &#123; slow = nums[slow]; fast = nums[fast]; &#125; return slow; &#125;&#125; 560. 和为K的子数组 [n]给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1 : 输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明 : 数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。 123456789101112131415161718class Solution(object): def subarraySum(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; res, cur_sum, m = 0, 0, &#123;0:1&#125; n = len(nums) for i in xrange(n): cur_sum += nums[i] if cur_sum - k in m: res += m[cur_sum - k] if cur_sum in m: m[cur_sum] += 1 else: m[cur_sum] = 1 return res 670. 最大交换给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。 示例 1 : 输入: 2736 输出: 7236 解释: 交换数字2和数字7。 示例 2 : 输入: 9973 输出: 9973 解释: 不需要交换。 注意: 给定数字的范围是 [0, 108] 1234567891011121314151617181920class Solution(object): def maximumSwap(self, num): &quot;&quot;&quot; :type num: int :rtype: int &quot;&quot;&quot; nums = [int(c) for c in str(num)] sorted_nums = sorted(nums[:], reverse=True) i, n = 0, len(nums) while i &lt; n: if nums[i] != sorted_nums[i]: break i += 1 if i == n: return num j = n - 1 while j &gt; i and nums[j] != sorted_nums[i]: j -= 1 nums[i], nums[j] = nums[j], nums[i] return int(&#x27;&#x27;.join([str(c) for c in nums])) 713. 乘积小于K的子数组给定一个正整数数组 nums。 找出该数组内乘积小于 k 的连续的子数组的个数。 示例 1: 输入: nums = [10,5,2,6], k = 100 输出: 8 解释: 8个乘积小于100的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。 需要注意的是 [10,5,2] 并不是乘积小于100的子数组。 说明: 0 &lt; nums.length &lt;= 50000 0 &lt; nums[i] &lt; 1000 0 &lt;= k &lt; 10^6 123456789101112131415161718class Solution(object): def numSubarrayProductLessThanK(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; n = len(nums) left, right, res = 0, 0, 0 cur_val = 1 while right &lt; n: cur_val *= nums[right] while left &lt;= right and cur_val &gt;= k: cur_val /= nums[left] left += 1 res += (right - left + 1) right += 1 return res 714. 买卖股票的最佳时机含手续费 [n]给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 示例 1: 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2 输出: 8 解释: 能够达到的最大利润: 在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8. 注意: 0 &lt; prices.length &lt;= 50000. 0 &lt; prices[i] &lt; 50000. 0 &lt;= fee &lt; 50000. 123456789101112class Solution(object): def maxProfit(self, prices, fee): &quot;&quot;&quot; :type prices: List[int] :type fee: int :rtype: int &quot;&quot;&quot; cash, hold = 0, -prices[0] for i in xrange(1, len(prices)): cash = max(cash, hold + prices[i] - fee) hold = max(hold, cash - prices[i]) return cash 718. 最长重复子数组 [n]给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。 示例 1: 输入: A: [1,2,3,2,1] B: [3,2,1,4,7] 输出: 3 解释: 长度最长的公共子数组是 [3, 2, 1]。 说明: 1 &lt;= len(A), len(B) &lt;= 1000 0 &lt;= A[i], B[i] &lt; 100 123456789101112131415161718192021class Solution(object): def findLength(self, A, B): &quot;&quot;&quot; :type A: List[int] :type B: List[int] :rtype: int &quot;&quot;&quot; m, n = len(A), len(B) dp = [[0 for _ in xrange(n + 1)] for _ in xrange(m + 1)] res = 0 for i in xrange(m + 1): for j in xrange(n + 1): if i == 0 or j == 0: dp[i][j] = 0 else: if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = 0 res = max(res, dp[i][j]) return res 795. 区间子数组个数给定一个元素都是正整数的数组A ，正整数 L 以及 R (L &lt;= R)。 求连续、非空且其中最大元素满足大于等于L 小于等于R的子数组个数。 例如 : 输入: A = [2, 1, 4, 3] L = 2 R = 3 输出: 3 解释: 满足条件的子数组: [2], [2, 1], [3]. 注意: L, R 和 A[i] 都是整数，范围在 [0, 10^9]。 数组 A 的长度范围在[1, 50000]。 12345678910111213141516171819202122class Solution(object): def numSubarrayBoundedMax(self, A, L, R): &quot;&quot;&quot; :type A: List[int] :type L: int :type R: int :rtype: int &quot;&quot;&quot; i, j, n = 0, 0, len(A) ans = 0 while j &lt; n: if L &lt;= A[j] &lt;= R: ans += j - i + 1 elif A[j] &lt; L: t = j - 1 while t &gt;= i and A[t] &lt; L: t -= 1 ans += t - i + 1 else: i = j + 1 j += 1 return ans 907. 子数组的最小值之和 [n]给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。 由于答案可能很大，因此返回答案模 10^9 + 7。 示例： 输入：[3,1,2,4] 输出：17 解释： 子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。 提示： 1 &lt;= A &lt;= 30000 1 &lt;= A[i] &lt;= 30000 12345678910111213141516171819202122232425262728class Solution(object): def sumSubarrayMins(self, A): MOD = 10**9 + 7 N = len(A) # prev has i* - 1 in increasing order of A[i* - 1] # where i* is the answer to query j stack = [] prev = [None] * N for i in xrange(N): while stack and A[i] &lt;= A[stack[-1]]: stack.pop() prev[i] = stack[-1] if stack else -1 stack.append(i) # next has k* + 1 in increasing order of A[k* + 1] # where k* is the answer to query j stack = [] next_ = [None] * N for k in xrange(N-1, -1, -1): while stack and A[k] &lt; A[stack[-1]]: stack.pop() next_[k] = stack[-1] if stack else N stack.append(k) # Use prev/next array to count answer return sum((i - prev[i]) * (next_[i] - i) * A[i] for i in xrange(N)) % MOD 915. 分割数组 [n]给定一个数组 A，将其划分为两个不相交（没有公共元素）的连续子数组 left 和 right， 使得： left 中的每个元素都小于或等于 right 中的每个元素。 left 和 right 都是非空的。 left 要尽可能小。 在完成这样的分组后返回 left 的长度。可以保证存在这样的划分方法。 示例 1： 输入：[5,0,3,8,6] 输出：3 解释：left = [5,0,3]，right = [8,6] 示例 2： 输入：[1,1,1,0,6,12] 输出：4 解释：left = [1,1,1,0]，right = [6,12] 提示： 2 &lt;= A.length &lt;= 30000 0 &lt;= A[i] &lt;= 10^6 可以保证至少有一种方法能够按题目所描述的那样对 A 进行划分。 1234567891011121314151617181920212223class Solution(object): def partitionDisjoint(self, A): &quot;&quot;&quot; :type A: List[int] :rtype: int &quot;&quot;&quot; n = len(A) max_left, min_right = [0] * n, [0] * n m = A[0] for i in xrange(n): m = max(m, A[i]) max_left[i] = m m = A[-1] for i in xrange(n - 1, -1, -1): m = min(m, A[i]) min_right[i] = m for i in xrange(1, n): if max_left[i - 1] &lt;= min_right[i]: return i 926. 将字符串翻转到单调递增 [n]如果一个由 ‘0’ 和 ‘1’ 组成的字符串，是以一些 ‘0’（可能没有 ‘0’）后面跟着一些 ‘1’（也可能没有 ‘1’）的形式组成的，那么该字符串是单调递增的。 我们给出一个由字符 ‘0’ 和 ‘1’ 组成的字符串 S，我们可以将任何 ‘0’ 翻转为 ‘1’ 或者将 ‘1’ 翻转为 ‘0’。 返回使 S 单调递增的最小翻转次数。 示例 1： 输入：\"00110\" 输出：1 解释：我们翻转最后一位得到 00111. 示例 2： 输入：\"010110\" 输出：2 解释：我们翻转得到 011111，或者是 000111。 示例 3： 输入：\"00011000\" 输出：2 解释：我们翻转得到 00000000。 提示： 1 &lt;= S.length &lt;= 20000 S 中只包含字符 ‘0’ 和 ‘1’ Python优化前Python优化后1234567891011121314151617class Solution(object): def minFlipsMonoIncr(self, S): &quot;&quot;&quot; :type S: str :rtype: int &quot;&quot;&quot; n = len(S) zeros = [n for _ in xrange(n)] ones = [n for _ in xrange(n)] for i in xrange(n): if i == 0: zeros[i] = int(S[i] != &#x27;0&#x27;) ones[i] = int(S[i] != &#x27;1&#x27;) continue zeros[i] = zeros[i - 1] + int(S[i] != &#x27;0&#x27;) ones[i] = min(ones[i - 1], zeros[i - 1]) + int(S[i] != &#x27;1&#x27;) return min(zeros[n - 1], ones[n - 1])123456789101112class Solution(object): def minFlipsMonoIncr(self, S): &quot;&quot;&quot; :type S: str :rtype: int &quot;&quot;&quot; zero, one = 0, 0 for c in S: last_zero = zero zero = last_zero + int(c != &#x27;0&#x27;) one = min(last_zero, one) + int(c != &#x27;1&#x27;) return min(zero, one) 945. 使数组唯一的最小增量给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。 返回使 A 中的每个值都是唯一的最少操作次数。 示例 1: 输入：[1,2,2] 输出：1 解释：经过一次 move 操作，数组将变为 [1, 2, 3]。 示例 2: 输入：[3,2,1,2,1,7] 输出：6 解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。 可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。 提示： 0 &lt;= A.length &lt;= 40000 0 &lt;= A[i] &lt; 40000 123456789101112class Solution(object): def minIncrementForUnique(self, A): &quot;&quot;&quot; :type A: List[int] :rtype: int &quot;&quot;&quot; A = sorted(A) res, step = 0, 0 for n in A: res += max(n, step) - n step = max(n, step) + 1 return res 962. 最大宽度坡 [n]给定一个整数数组 A，坡是元组 (i, j)，其中 i &lt; j 且 A[i] &lt;= A[j]。这样的坡的宽度为 j - i。 找出 A 中的坡的最大宽度，如果不存在，返回 0 。 示例 1： 输入：[6,0,8,2,1,5] 输出：4 解释： 最大宽度的坡为 (i, j) = (1, 5): A[1] = 0 且 A[5] = 5. 示例 2： 输入：[9,8,1,0,1,9,4,0,4,1] 输出：7 解释： 最大宽度的坡为 (i, j) = (2, 9): A[2] = 1 且 A[9] = 1. 提示： 2 &lt;= A.length &lt;= 50000 0 &lt;= A[i] &lt;= 50000 12345678910111213141516171819202122class Solution(object): def maxWidthRamp(self, A): &quot;&quot;&quot; :type A: List[int] :rtype: int &quot;&quot;&quot; res = 0 if not A: return res stk = [] n = len(A) for i in xrange(n): if not stk or A[stk[-1]] &gt; A[i]: stk.append(i) i = n - 1 while i &gt; res: while stk and A[stk[-1]] &lt;= A[i]: j = stk[-1] res = max(res, i - j) stk.pop(-1) i -= 1 return res","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode之数组(困难)","slug":"LeetCode-数组-困难","date":"2020-12-31T13:25:06.000Z","updated":"2020-12-31T13:41:03.522Z","comments":false,"path":"posts/801922082.html","link":"","permalink":"https://leel0330.github.io/posts/801922082.html","excerpt":"数组(困难)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"数组(困难)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 4. 寻找两个正序数组的中位数 [n]给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。 进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？ 示例 1： 输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 示例 3： 输入：nums1 = [0,0], nums2 = [0,0] 输出：0.00000 示例 4： 输入：nums1 = [], nums2 = [1] 输出：1.00000 示例 5： 输入：nums1 = [2], nums2 = [] 输出：2.00000 提示： nums1.length == m nums2.length == n 0 &lt;= m &lt;= 1000 0 &lt;= n &lt;= 1000 1 &lt;= m + n &lt;= 2000 -106 &lt;= nums1[i], nums2[i] &lt;= 106 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): def findMedianSortedArrays(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: float &quot;&quot;&quot; len1, len2 = len(nums1), len(nums2) total_len = len1 + len2 if total_len &amp; 1 == 1: mid = total_len / 2 res = self.findK(nums1, nums2, mid + 1) return res else: mid1 = total_len / 2 - 1 mid2 = mid1 + 1 res = (self.findK(nums1, nums2, mid1 + 1) + self.findK(nums1, nums2, mid2 + 1)) / 2.0 return res def findK(self, nums1, nums2, k): len1, len2 = len(nums1), len(nums2) idx1, idx2 = 0, 0 while True: if idx1 == len1: return nums2[idx2 + k - 1] if idx2 == len2: return nums1[idx1 + k - 1] if k == 1: return min(nums1[idx1], nums2[idx2]) half = k / 2 new_idx1 = min(idx1 + half, len1) - 1 new_idx2 = min(idx2 + half, len2) - 1 if nums1[new_idx1] &lt;= nums2[new_idx2]: k -= (new_idx1 - idx1 + 1) idx1 = new_idx1 + 1 else: k -= (new_idx2 - idx2 + 1) idx2 = new_idx2 + 1 41. 缺失的第一个正数给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。 示例 1: 输入: [1,2,0] 输出: 3 示例 2: 输入: [3,4,-1,1] 输出: 2 示例 3: 输入: [7,8,9,11,12] 输出: 1 提示： 你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。 123456789101112131415161718class Solution(object): def firstMissingPositive(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n = len(nums) for i in xrange(n): if nums[i] &lt;= 0: nums[i] = n + 1 for i in xrange(n): cur_num = abs(nums[i]) if cur_num &lt;= n: nums[cur_num - 1] = -abs(nums[cur_num - 1]) for i in xrange(n): if nums[i] &gt; 0: return i + 1 return n + 1 42. 接雨水 [n]给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例 1： 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例 2： 输入：height = [4,2,0,3,2,5] 输出：9 提示： n == height.length 0 &lt;= n &lt;= 3 * 104 0 &lt;= height[i] &lt;= 105 123456789101112131415161718192021class Solution(object): def trap(self, height): &quot;&quot;&quot; :type height: List[int] :rtype: int &quot;&quot;&quot; if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in xrange(1, n): left_max[i] = max(height[i], left_max[i - 1]) right_max[n - 1] = height[n - 1] for i in xrange(n - 2, -1, -1): right_max[i] = max(height[i], right_max[i + 1]) res = 0 for i in xrange(1, n - 1): res += min(left_max[i], right_max[i]) - height[i] return res 45. 跳跃游戏 II给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 示例: 输入: [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 说明: 假设你总是可以到达数组的最后一个位置。 12345678910111213141516class Solution(object): def jump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n = len(nums) max_pos = 0 end = 0 res = 0 for i in xrange(n - 1): max_pos = max(max_pos, i + nums[i]) if i == end: end = max_pos res += 1 return res","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"牛客题霸-名企高频面试题","slug":"牛客题霸-名企高频面试题","date":"2020-12-22T13:46:09.000Z","updated":"2021-03-14T13:44:03.524Z","comments":false,"path":"posts/1369037266.html","link":"","permalink":"https://leel0330.github.io/posts/1369037266.html","excerpt":"终于把牛客题霸-名企高频面试题刷完了，在这里汇总一下。","text":"终于把牛客题霸-名企高频面试题刷完了，在这里汇总一下。 NC21. 链表内指定区间反转将一个链表 m 位置到 n 位置之间的区间反转，要求时间复杂度，空间复杂度。 示例1 输入: {1,2,3,4,5},2,4 返回值: {1,4,3,2,5} 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; // write code here ListNode *dummy = new ListNode(-1); dummy-&gt;next = head; ListNode *p = dummy, *prev = nullptr; ListNode *q = dummy, *next = nullptr; for(int i = 0;i &lt; m; i++) &#123; prev = p; p = p-&gt;next; &#125; for(int i = 0; i &lt; n; i++) &#123; q = q-&gt;next; &#125; next = q-&gt;next; pair&lt;ListNode*, ListNode*&gt; res = reverse(prev, p, next); prev-&gt;next = res.first; res.second-&gt;next = next; head = dummy-&gt;next; dummy-&gt;next = nullptr; delete dummy; return head; &#125; pair&lt;ListNode*, ListNode*&gt; reverse(ListNode *prev, ListNode *head, ListNode *tail) &#123; ListNode *p = head, *q = prev; while(p != tail) &#123; ListNode *nextNode = p-&gt;next; p-&gt;next = q; q = p; p = nextNode; &#125; pair&lt;ListNode*, ListNode*&gt; res; res.first = q; res.second = prev-&gt;next; return res; &#125;&#125;; NC24. 删除有序链表中重复出现的元素给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。例如：给出的链表为1→2→3→3→4→4→5, 返回1→2→5.给出的链表为1→1→1→2→3, 返回2→3. PythonC++1234567891011121314151617181920212223242526class Solution: def deleteDuplicates(self , head): # write code here if not head or head.next is None: return head dummy = ListNode(-1) dummy.next = head p = dummy q = head while q: cur = q cur_v = q.val cnt = 1 while cur.next and cur.next.val == cur_v: cur = cur.next cnt += 1 if cnt == 1: p.next = cur q = cur.next p = cur else: p.next = cur.next q = cur.next p = dummy.next dummy.next = None return p1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: /** * * @param head ListNode类 * @return ListNode类 */ ListNode* deleteDuplicates(ListNode* head) &#123; // write code here if(head == nullptr || head-&gt;next == nullptr) &#123; return head; &#125; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode *p = dummy, *q = head; while(q) &#123; ListNode *cur = q; int curVal = cur-&gt;val; int cnt = 1; while(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == curVal) &#123; cnt += 1; cur = cur-&gt;next; &#125; if(cnt &gt; 1) &#123; p-&gt;next = cur-&gt;next; q = cur-&gt;next; &#125;else &#123; p-&gt;next = cur; q = cur-&gt;next; p = cur; &#125; &#125; p = dummy-&gt;next; dummy-&gt;next = nullptr; delete dummy; return p; &#125;&#125;; NC35. 最小编辑代价 [n]给定两个字符串str1和str2，再给定三个整数ic，dc和rc，分别代表插入、删除和替换一个字符的代价，请输出将str1编辑成str2的最小代价。 示例1 输入: \"abc\",\"adc\",5,3,2 返回值: 2 示例2 输入: \"abc\",\"adc\",5,3,100 返回值: 8 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: /** * min edit cost * @param str1 string字符串 the string * @param str2 string字符串 the string * @param ic int整型 insert cost * @param dc int整型 delete cost * @param rc int整型 replace cost * @return int整型 */ int minEditCost(string str1, string str2, int ic, int dc, int rc) &#123; // write code here int s1Len = str1.size(); int s2Len = str2.size(); vector&lt; vector&lt;int&gt; &gt; dp(s1Len + 1, vector&lt;int&gt;(s2Len + 1, 0)); for(int i = 0; i &lt;= s1Len; i++) &#123; dp[i][0] = i * dc; &#125; for(int i = 0; i &lt;= s2Len; i++) &#123; dp[0][i] = i * ic; &#125; for(int i = 1; i &lt;= s1Len; i++) &#123; for(int j = 1; j &lt;= s2Len; j++) &#123; if(str1[i - 1] == str2[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1]; &#125;else&#123; int ins = dp[i][j - 1] + ic; int del = dp[i - 1][j] + dc; int replace = dp[i - 1][j - 1] + rc; dp[i][j] = min(ins, min(del, replace)); &#125; &#125; &#125; return dp[s1Len][s2Len]; &#125;&#125;; NC44. 通配符匹配 [n]请实现支持’?’and’*‘.的通配符模式匹配。‘?’ 可以匹配任何单个字符。‘*‘ 可以匹配任何字符序列（包括空序列）。 12345678910111213141516171819202122class Solution: def isMatch(self , s , p ): # write code here i, j = 0, 0 backi, backj = -1, -1 while i &lt; len(s): if j &lt; len(p) and (s[i] == p[j] or p[j] == &#x27;?&#x27;): i += 1 j += 1 elif j &lt; len(p) and p[j] == &#x27;*&#x27;: backi = i backj = j j += 1 elif backj != -1: i = backi + 1 j = backj + 1 backi = i else: return False while j &lt; len(p) and p[j] == &#x27;*&#x27;: j += 1 return j == len(p) NC49. 最长的括号子串给出一个仅包含字符’(‘和’)’的字符串，计算最长的格式正确的括号子串的长度。对于字符串”(()”来说，最长的格式正确的子串是”()”，长度为2.再举一个例子：对于字符串”)()())”,来说，最长的格式正确的子串是”()()”，长度为4. 输入: \"(()\" 返回值: 2 12345678910111213141516171819202122class Solution: def longestValidParentheses(self , s ): # write code here s_len = len(s) if s_len &lt; 1: return 0 stk = [] max_len = 0 last = -1 for i in xrange(s_len): if s[i] == &#x27;(&#x27;: stk.append(i) else: if len(stk) == 0: last = i else: stk.pop(-1) if len(stk) == 0: max_len = max(max_len, i - last) else: max_len = max(max_len, i - stk[-1]) return max_len NC50. 链表中的节点每k个一组翻转 [n]将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样你不能更改节点中的值，只能更改节点本身。要求空间复杂度 O(1)例如： 给定的链表是1→2→3→4→5 对于 k=2, 你应该返回 2→1→4→3→5 对于 k=3, 你应该返回 3→2→1→4→5 PythonCpp1234567891011121314151617181920212223242526272829303132class Solution: def reverse(self, head, tail): prev = tail.next p = head while prev != tail: nex = p.next p.next = prev prev = p p = nex return tail, head def reverseKGroup(self, head, k): dummy = ListNode(-1) dummy.next = head pre = dummy while head: tail = pre # 查看剩余部分长度是否大于等于 k for i in range(k): tail = tail.next if not tail: return dummy.next nex = tail.next head, tail = self.reverse(head, tail) # 把子链表重新接回原链表 pre.next = head tail.next = nex pre = tail head = tail.next return dummy.next12345678910111213141516171819202122232425262728293031323334353637383940414243/** * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */class Solution &#123;public: /** * * @param head ListNode类 * @param k int整型 * @return ListNode类 */ ListNode* reverseKGroup(ListNode* head, int k) &#123; // write code here if(head == nullptr) &#123; return head; &#125; ListNode *p = head, *q = head; for(int i = 0; i &lt; k; i++) &#123; if(q == nullptr) &#123; return p; &#125; q = q-&gt;next; &#125; ListNode* newHead = reverse(p, q); p-&gt;next = reverseKGroup(q, k); return newHead; &#125; ListNode* reverse(ListNode *head, ListNode* end) &#123; ListNode* p = head, *q = nullptr; while(p != end) &#123; ListNode *r = p-&gt;next; p-&gt;next = q; q = p; p = r; &#125; return q; &#125;&#125;; NC57. 反转数字将给出的32位整数x翻转。例1:x=123，返回321。例2:x=-123，返回-321。 你有注意到翻转后的整数可能溢出吗？因为给出的是32位整数，则其数值范围为[−2^{31}, 2^{31} − 1]。翻转可能会导致溢出，如果反转后的结果会溢出就返回 0。 输入: -123 返回值: -321 1234567891011121314151617class Solution: def reverse(self , x ): # write code here INT_MIN = -(1 &lt;&lt; 31) INT_MAX = (1 &lt;&lt; 31) - 1 sign = x &lt; 0 x = abs(x) res = 0 while x: v = x % 10 x = x // 10 if res &gt; INT_MAX / 10 or (res == INT_MAX / 10 and v &gt; 7): return 0 if sign and (-res &lt; INT_MIN / 10 or (-res == INT_MIN / 10 and v &lt; -8)): return 0 res = res * 10 + v return res if not sign else -res NC62. 平衡二叉树输入一棵二叉树，判断该二叉树是否是平衡二叉树。 在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树。 平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 输入: {1,2,3,4,5,6,7} 返回值: true 123456789101112131415161718class Solution: def IsBalanced_Solution(self, pRoot): # write code here return self.helper(pRoot) != -1 def helper(self, root): if not root: return 0 left = self.helper(root.left) if left == -1: return -1 right = self.helper(root.right) if right == -1: return -1 v = abs(left - right) if v &gt; 1: return -1 return max(left, right) + 1 NC64. 二叉搜索树与双向链表输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 123456789101112131415161718192021222324class Solution: def __init__(self): self.last_node = None def Convert(self, pRootOfTree): # write code here if not pRootOfTree: return pRootOfTree self.last_node = None self.helper(pRootOfTree) while pRootOfTree.left: pRootOfTree = pRootOfTree.left return pRootOfTree def helper(self, root): if not root: return if root.left: self.helper(root.left) root.left = self.last_node if self.last_node: self.last_node.right = root self.last_node = root if root.right: self.helper(root.right) NC75. 数组中只出现一次的数字一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 12345678910111213141516171819202122class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): # write code here x = 0 for n in array: x ^= n idx = 0 while x &amp; 1 == 0: x &gt;&gt;= 1 idx += 1 n1, n2 = 0, 0 for n in array: if self.f(n, idx): n1 ^= n else: n2 ^= n return [n1, n2] def f(self, n, idx): n &gt;&gt;= idx return(n &amp; 1) == 1 NC82. 滑动窗口的最大值给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。窗口大于数组长度的时候，返回空 示例1 输入: [2,3,4,2,6,2,5,1],3 返回值: [4,4,6,6,6,5] 12345678910111213141516class Solution: def maxInWindows(self, nums, size): # write code here queue = [] if not size: return queue res = [] for i, v in enumerate(nums): while queue and queue[0] &lt;= i - size: queue.pop(0) while queue and v &gt; nums[queue[-1]]: queue.pop(-1) queue.append(i) if i &gt;= size - 1: res.append(nums[queue[0]]) return res NC88. 寻找第K大有一个整数数组，请你根据快速排序的思路，找出数组中第K大的数。 给定一个整数数组a,同时给定它的大小n和要找的K(K在1到n之间)，请返回第K大的数，保证答案存在。 示例1 输入: [1,3,5,2,2],5,3 返回值: 2 PythonCpp12345678910111213141516171819202122232425class Finder: def findKth(self, a, n, K): # write code here return self.helper(a, 0, n - 1, K) def helper(self, a, left, right, K): idx = self.paritition(a, left, right) if idx == K - 1: return a[idx] elif idx &lt; K - 1: return self.helper(a, idx + 1, right, K) else: return self.helper(a, left, idx - 1, K) def paritition(self, a, low, high): pivot = a[low] while low &lt; high: while low &lt; high and a[high] &lt;= pivot: high -= 1 a[low] = a[high] while low &lt; high and a[low] &gt;= pivot: low += 1 a[high] = a[low] a[low] = pivot return low1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int findKth(vector&lt;int&gt; a, int n, int K) &#123; // write code here return Helper(a, 0, n - 1, K); &#125; int Helper(vector&lt;int&gt;&amp; arr, int left, int right, int K) &#123; int idx = Partition(arr, left, right); if(idx + 1 == K) &#123; return arr[idx]; &#125; if(idx + 1 &lt; K) &#123; return Helper(arr, idx + 1, right, K); &#125;else &#123; return Helper(arr, left, idx - 1, K); &#125; &#125; int Partition(vector&lt;int&gt;&amp; arr, int left, int right) &#123; int pivot = arr[left]; while(left &lt; right) &#123; while(left &lt; right &amp;&amp; arr[right] &lt;= pivot) &#123; right -= 1; &#125; arr[left] = arr[right]; while(left &lt; right &amp;&amp; arr[left] &gt;= pivot) &#123; left += 1; &#125; arr[right] = arr[left]; &#125; arr[left] = pivot; return left; &#125;&#125;; NC91. 最长递增子序列 [n]给定数组arr，设长度为n，输出arr的最长递增子序列。（如果有多个答案，请输出其中字典序最小的）。 示例1 输入: [2,1,5,3,6,4,8,9,7] 返回值: [1,3,4,8,9] 示例2 输入: [1,2,8,6,4] 返回值: [1,2,4] 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;int&gt; LIS(vector&lt;int&gt;&amp; arr) &#123; // write code here // 第一步：利用贪心+二分求最长递增子序列长度 vector&lt;int&gt; res; vector&lt;int&gt; maxLen; if (arr.size() &lt; 1) return res; res.emplace_back(arr[0]); // 注：emplace_back(val)作用同push_back，效率更高 maxLen.emplace_back(1); for (int i = 1; i &lt; arr.size(); ++i) &#123; if (arr[i] &gt; res.back()) &#123; res.emplace_back(arr[i]); maxLen.emplace_back(res.size()); &#125; else &#123; // lower_bound(begin, end, val)包含在&lt;algorithm&gt;中 // 它的作用是返回有序数组begin..end中第一个大于等于val的元素的迭代器 int pos = lower_bound(res.begin(), res.end(), arr[i]) - res.begin(); res[pos] = arr[i]; maxLen.emplace_back(pos+1); &#125; &#125; // 第二步：填充最长递增子序列 for (int i = arr.size()-1, j = res.size(); j &gt; 0; --i) &#123; if (maxLen[i] == j) &#123; res[--j] = arr[i]; &#125; &#125; return res; &#125;&#125;; NC92. 最长公共子序列 [n]给定两个字符串str1和str2，输出连个字符串的最长公共子序列。如过最长公共子序列为空，则输出-1。 示例1 输入: \"1A2C3D4B56\",\"B1D23CA45B6A\" 返回值: \"123456\" 1234567891011121314151617181920212223242526272829class Solution &#123;public: string LCS(string s1, string s2) &#123; // write code here if(s1.size() == 0 || s2.size() == 0) return &quot;-1&quot;; int maxLen = 0, start = -1; vector&lt;int&gt; dp(s2.size() + 1, 0); for(int i = 1; i &lt;= s1.size(); ++i)&#123; int last = dp[0]; for(int j = 1; j &lt;= s2.size(); ++j)&#123; int tmp = dp[j]; if(s1[i - 1] == s2[j - 1])&#123; dp[j] = last + 1; &#125;else&#123; dp[j] = 0; &#125; last = tmp; if(maxLen &lt; dp[j])&#123; maxLen = dp[j]; start = i; &#125; &#125; &#125; if(maxLen == 0) return &quot;-1&quot;; return s1.substr(start-maxLen, maxLen); &#125;&#125;; NC108. 最大正方形给定一个由0和1组成的2维矩阵，返回该矩阵中最大的由1组成的正方形的面积 示例1 输入: [[1,0,1,0,0],[1,0,1,1,1],[1,1,1,1,1],[1,0,0,1,0]] 返回值: 4 12345678910111213141516171819202122232425262728class Solution &#123;public: int solve(vector&lt;vector&lt;char&gt; &gt;&amp; matrix) &#123; // write code here int maxEdge = 0; if(matrix.size() == 0 || matrix[0].size() == 0) &#123; return maxEdge; &#125; int rows = matrix.size(), cols = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(rows, vector&lt;int&gt;(cols, 0)); for(int i = 0; i &lt; rows; i++) &#123; for(int j = 0; j &lt; cols; j++) &#123; if(matrix[i][j] == &#x27;0&#x27;) &#123; dp[i][j] = 0; &#125;else &#123; if(i ==0 || j == 0) &#123; dp[i][j] = 1; &#125;else &#123; int temp = min(dp[i - 1][j - 1], dp[i][j - 1]); dp[i][j] = min(dp[i - 1][j], temp) + 1; &#125; &#125; maxEdge = max(maxEdge, dp[i][j]); &#125; &#125; return maxEdge * maxEdge; &#125;&#125;; NC116. 把数字翻译成字符串有一种将字母编码成数字的方式：’a’-&gt;1, ‘b-&gt;2’, … , ‘z-&gt;26’。 现在给一串数字，返回有多少种可能的译码结果 示例1 输入: \"12\" 返回值: 2 示例1 输入: \"31717126241541717\" 返回值: 192 123456789101112131415class Solution: def solve(self , nums ): # write code here n = len(nums) dp = [0 for _ in xrange(n + 1)] dp[0] = 1 dp[1] = 1 if nums[0] != &#x27;0&#x27; else 0 for i in xrange(2, n + 1): two = nums[i - 2: i] one = nums[i - 1:i] if 10 &lt;= int(two) &lt;= 26: dp[i] += dp[i - 2] if 1 &lt;= int(one) &lt;= 9: dp[i] += dp[i - 1] return dp[n] NC118. 数组中的逆序对在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 示例1 输入: [1,2,3,4,5,6,7,0] 返回值: 7 12345678910111213141516171819202122232425262728293031323334class Solution: def InversePairs(self, data): # write code here n = len(data) tmp = [0 for _ in xrange(n)] res = self.mergeSort(data, tmp, 0, n - 1) return res % 1000000007 def mergeSort(self, data, tmp, left, right): if left &gt;= right: return 0 mid = (left + right) // 2 res = self.mergeSort(data, tmp, left, mid) + \\ self.mergeSort(data, tmp, mid + 1, right) i, j = left, mid + 1 pos = left while i &lt;= mid and j &lt;= right: if data[i] &lt;= data[j]: tmp[pos] = data[i] i += 1 res += j - (mid + 1) else: tmp[pos] = data[j] j += 1 pos += 1 for k in xrange(i, mid + 1): tmp[pos] = data[k] pos += 1 res += j - (mid + 1) for k in xrange(j, right + 1): tmp[pos] = data[k] pos += 1 data[left: right + 1] = tmp[left: right + 1] return res NC119. 最小的K个数输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。示例1 输入 [4,5,1,6,2,7,3,8],4 返回值 [1,2,3,4] 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; vector&lt;int&gt; res; if(input.size() &lt; k || k == 0) &#123; return res; &#125; int start = 0, end = input.size() - 1； while(start &lt;= end) &#123; //需要细心，要加等号！ int idx = Partition(input, start, end); if(idx + 1 == k) &#123; return vector&lt;int&gt;(input.begin(), input.begin() + k); &#125; if(idx + 1 &lt; k) &#123; start = idx + 1; &#125;else &#123; end = idx - 1; &#125; &#125; return res; &#125; int Partition(vector&lt;int&gt;&amp; arr, int start, int end) &#123; int pivot = arr[start]; int left = start, right = end; while(left &lt; right) &#123; while(left &lt; right &amp;&amp; arr[right] &gt;= pivot) &#123; right -= 1; &#125; arr[left] = arr[right]; while(left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123; left += 1; &#125; arr[right] = arr[left]; &#125; arr[left] = pivot; return left; &#125;&#125;; NC122. 正则表达式匹配 [n]请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 示例1 输入: \"aaa\",\"a*a\" 返回值: true 1234567891011121314151617181920212223242526272829class Solution: # s, pattern都是字符串 def match(self, s, pattern): # write code here if not s and not pattern: return True s_len = len(s) p_len = len(pattern) dp = [[False for _ in xrange(p_len + 1)] for _ in xrange(s_len + 1)] dp[0][0] = True for i in xrange(s_len + 1): for j in xrange(1, p_len + 1): if pattern[j - 1] == &#x27;*&#x27;: dp[i][j] = dp[i][j - 2] if self.isOK(s, pattern, i, j - 1): dp[i][j] = dp[i][j] or dp[i - 1][j] else: if self.isOK(s, pattern, i, j): dp[i][j] = dp[i - 1][j - 1] return dp[s_len][p_len] def isOK(self, s, pattern, i, j): if i == 0: return False if pattern[j - 1] == &#x27;.&#x27;: return True return s[i - 1] == pattern[j - 1] NC126. 换钱的最少货币数 [n]给定数组arr，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个aim，代表要找的钱数，求组成aim的最少货币数。如果无解，请返回-1.【要求】时间复杂度O(n×aim)，空间复杂度O(n)。 示例1 输入: [5,2,3],20 返回值: 4 1234567891011class Solution: def minMoney(self, arr, aim): # write code here INT_MAX = (1 &lt;&lt; 31) - 1 dp = [INT_MAX for _ in xrange(aim + 1)] dp[0] = 0 for n in xrange(aim + 1): for v in arr: if n &gt;= v: dp[n] = min(dp[n], dp[n - v] + 1) return dp[aim] if dp[aim] != INT_MAX else -1 NC127. 最长公共子串 [n]给定两个字符串str1和str2,输出两个字符串的最长公共子串，如果最长公共子串为空，输出-1。 示例1 输入: \"1AB2345CD\",\"12345EF\" 返回值: \"2345\" Python会超时。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: /** * longest common substring * @param str1 string字符串 the string * @param str2 string字符串 the string * @return string字符串 */ string LCS(string str1, string str2) &#123; // write code here int s1Len = str1.size(); int s2Len = str2.size(); string res = &quot;&quot;; int maxLen = 0; vector&lt; vector&lt;int&gt; &gt; dp(s1Len + 1, vector&lt;int&gt;(s2Len + 1, 0)); for(int i = 1; i &lt;= s1Len; i++) &#123; for(int j = 1; j &lt;= s2Len; j++) &#123; if(str1[i - 1] == str2[j - 1]) &#123; dp[i][j] = 1 + dp[i - 1][j - 1]; &#125; if(maxLen &lt; dp[i][j]) &#123; maxLen = dp[i][j]; res = str1.substr(i - dp[i][j], dp[i][j]); &#125; &#125; &#125; if(res.empty()) &#123; return &quot;-1&quot;; &#125; return res; &#125;&#125;; NC128. 容器盛水问题 [n]给定一个整形数组arr，已知其中所有的值都是非负的，将这个数组看作一个容器，请返回容器能装多少水。具体请参考样例解释 示例1 输入: [3,1,2,5,2,4] 返回值: 5 示例2 输入: [4,5,1,3,2] 返回值: 2 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: /** * max water * @param arr int整型vector the array * @return long长整型 */ long long maxWater(vector&lt;int&gt;&amp; arr) &#123; // write code here if(arr.size() &lt;= 2) &#123; return 0; &#125; int left = 0, right = arr.size() - 1; long long res = 0; int min = getMin(arr[left], arr[right]); while(left &lt; right) &#123; if(arr[left] &lt; arr[right]) &#123; left += 1; if(arr[left] &lt; min) &#123; res += min - arr[left]; &#125;else &#123; min = getMin(arr[left], arr[right]); &#125; &#125;else &#123; right -= 1; if(arr[right] &lt; min) &#123; res += min - arr[right]; &#125;else &#123; min = getMin(arr[left], arr[right]); &#125; &#125; &#125; return res; &#125; int getMin(int a, int b) &#123; return a &gt; b ? b: a; &#125;&#125;; NC138. 矩阵最长递增路径给定一个矩阵，矩阵内所有数均为非负整数。求一条路径，该路径上所有数是递增的。这个路径必须满足以下条件：1、对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外。2、你不能走重复的单元格。即每个格子最多只能走一次。 示例1 输入: [[1,2,3],[4,5,6],[7,8,9]] 返回值: 5 示例2 输入: [[1,2],[4,3]] 返回值: 4 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int solve(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123; // write code here if(matrix.size() == 0 || matrix[0].size() == 0) &#123; return 0; &#125; int rows = matrix.size(), cols = matrix[0].size(); int res = 0; int dirs[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; vector&lt;vector&lt;int&gt;&gt; memo(rows, vector&lt;int&gt;(cols, 0)); for(int i = 0; i &lt; rows; i++) &#123; for(int j = 0; j &lt; cols; j++) &#123; int cur = dfs(matrix, i, j, rows, cols, memo, dirs); res = max(res, cur); &#125; &#125; return res; &#125; int dfs(const vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int i, int j, int rows, int cols, vector&lt;vector&lt;int&gt;&gt;&amp; memo, int dirs[4][2]) &#123; if(memo[i][j] != 0) &#123; return memo[i][j]; &#125; memo[i][j] += 1; for(int k = 0; k &lt; 4; k++) &#123; int newI = dirs[k][0] + i, newJ = dirs[k][1] + j; if(newI &gt;= 0 &amp;&amp; newI &lt; rows &amp;&amp; newJ &gt;= 0 &amp;&amp; newJ &lt; cols &amp;&amp; matrix[i][j] &lt; matrix[newI][newJ]) &#123; memo[i][j] = max(memo[i][j], dfs(matrix, newI, newJ, rows, cols, memo, dirs) + 1); &#125; &#125; return memo[i][j]; &#125;&#125;;","categories":[{"name":"Tech","slug":"Tech","permalink":"https://leel0330.github.io/categories/Tech/"}],"tags":[]},{"title":"Docker构建包含zsh和vim的Ubuntu","slug":"Docker构建包含zsh和vim的Ubuntu","date":"2020-12-18T15:24:31.000Z","updated":"2020-12-27T05:05:14.642Z","comments":false,"path":"posts/2954551561.html","link":"","permalink":"https://leel0330.github.io/posts/2954551561.html","excerpt":"晚上花了点时间研究了下如何在Docker环境下构建属于自己的Ubuntu。该Ubuntu包含了zsh和Oh-my-zsh插件，也包含了YouCompleteMe插件的Vim编辑器。 含泪说下:网上的YouCompleteMe很多教程都已经过时了，还是得以官方文档为主来配置该插件，否则你会安装的很痛苦。 另外，该Ubuntu也包含了C/C++的编译环境，如gcc、g++、gdb和valgrind常用工具。","text":"晚上花了点时间研究了下如何在Docker环境下构建属于自己的Ubuntu。该Ubuntu包含了zsh和Oh-my-zsh插件，也包含了YouCompleteMe插件的Vim编辑器。 含泪说下:网上的YouCompleteMe很多教程都已经过时了，还是得以官方文档为主来配置该插件，否则你会安装的很痛苦。 另外，该Ubuntu也包含了C/C++的编译环境，如gcc、g++、gdb和valgrind常用工具。 预安装123456789apt updateapt install systemdapt install curlapt install wgetapt install git 安装zsh1234567apt install zshsh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlightinggit clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 在.zshrc配置插件 1plugins=(git zsh-syntax-highlighting zsh-autosuggestions) 避免复制命令在控制台是一个个字符显示出来 123456789101112# This speeds up pasting w/ autosuggest# https://github.com/zsh-users/zsh-autosuggestions/issues/238pasteinit() &#123; OLD_SELF_INSERT=$&#123;$&#123;(s.:.)widgets[self-insert]&#125;[2,3]&#125; zle -N self-insert url-quote-magic # I wonder if you&#x27;d need `.url-quote-magic`?&#125;pastefinish() &#123; zle -N self-insert $OLD_SELF_INSERT&#125;zstyle :bracketed-paste-magic paste-init pasteinitzstyle :bracketed-paste-magic paste-finish pastefinish (不一定会碰到这个问题)按tab键shell中重复显示命令的前几个字符问题修复: 12345678apt-get install -y localesrm -rf /var/lib/apt/lists/*localedef -i en_US -c -f UTF-8 -A /usr/share/locale/locale.alias en_US.UTF-8echo &#x27;export LANG=en_US.utf8&#x27; &gt;&gt; ~/.zshrcsource ~/.zshrc 以上都放置在.zshrc文件就可以，然后重启下就可以了。 安装vim并配置 按照插件管理器Vundle。1git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 建立默认.vimrc文件在~目录下，内容为:1234567891011121314151617181920212223242526272829set nocompatible &quot; be iMproved, requiredfiletype off &quot; required&quot; set the runtime path to include Vundle and initializeset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()&quot; alternatively, pass a path where Vundle should install plugins&quot;call vundle#begin(&#x27;~/some/path/here&#x27;)&quot; let Vundle manage Vundle, requiredPlugin &#x27;VundleVim/Vundle.vim&#x27;&quot; plugins here&quot; All of your Plugins must be added before the following linecall vundle#end() &quot; requiredfiletype plugin indent on &quot; required&quot; To ignore plugin indent changes, instead use:&quot;filetype plugin on&quot;&quot; Brief help&quot; :PluginList - lists configured plugins&quot; :PluginInstall - installs plugins; append `!` to update or just :PluginUpdate&quot; :PluginSearch foo - searches for foo; append `!` to refresh local cache&quot; :PluginClean - confirms removal of unused plugins; append `!` to auto-approve removal&quot;&quot; see :h vundle for more details or wiki for FAQ&quot; Put your non-Plugin stuff after this line 安装YouCompleteMe插件 在.vimrc添加如下内容:1Plugin &#39;Valloric&#x2F;YouCompleteMe&#39; 拉取YouCompleteMe插件代码:12345cd ~/.vim/bundlegit clone https://github.com/Valloric/YouCompleteMe.gitcd ~/.vim/bundle/YouCompleteMegit submodule update --init --recursive(注意:这个命令可能花时间比较久) 拉取构建YouCompleteMe依赖:1apt install build-essential cmake vim-nox python3-dev 安装代码提示:123cd ~/.vim/bundle/YouCompleteMepython3 install.py --clangd-completer 这4步完成后YouCompleteMe插件就算完成了，网上好多说要配置.ycm_extra_conf.py。其实这个文件已经在这个~/.vim/bundle/YouCompleteMe目录下了，你可以通过ls -a来看到那个文件。 安装C/C++环境1234567apt install gccapt install g++apt install valgrindapt install gdb","categories":[{"name":"Tech","slug":"Tech","permalink":"https://leel0330.github.io/categories/Tech/"}],"tags":[]},{"title":"谈一谈你对进程和线程的认识(未完待续...)","slug":"谈一谈进程和线程","date":"2020-12-14T12:37:25.000Z","updated":"2021-03-04T14:35:25.241Z","comments":false,"path":"posts/3970838420.html","link":"","permalink":"https://leel0330.github.io/posts/3970838420.html","excerpt":"这是自己看完几本操作系统书和网上一些博客后，为了加深自己对进程和线程的认识，写的总结性的文章，也希望这篇文章能让你耳目一新^_^。 这篇文章只谈概念，不谈代码。如果你理解了概念，写代码的时候思路就会变得很清晰，不会陷入我也不知道自己在写神马的困境。","text":"这是自己看完几本操作系统书和网上一些博客后，为了加深自己对进程和线程的认识，写的总结性的文章，也希望这篇文章能让你耳目一新^_^。 这篇文章只谈概念，不谈代码。如果你理解了概念，写代码的时候思路就会变得很清晰，不会陷入我也不知道自己在写神马的困境。 什么是进程？ 进程是执行中的程序，是操作系统分配资源的基本单位。 内存中的进程结构如图所示: 进程在执行时会改变状态，每个进程可能处于下列状态中的某一个，如图所示: 每个进程在操作系统内用程序控制块(PCB)来表示。PCB通常包含了以下几类信息: 程序状态:包括新的、就绪、运行、等待、停止等。 程序计数器:计数器表示进程要执行的下个指令的地址。 CPU寄存器:与程序计数器一起，寄存器的状态信息在出现中断时也需要保存，以便进程以后能正确地继续执行。 CPU调度信息:包括进程优先级、调度队列的指针和其他调度参数。 内存管理信息:包括基址和界限寄存器的值、页表或段表。 记账信息:包括CPU时间、实际使用时间、时间界限、记账数据、作业或进程数量等。 I/O状态信息:包括分配给进程的I/O设备列表、打开的文件列表等。 驻留在内存中就绪的、等待运行的进程保存在就绪队列中，该队列通常用双向链表来实现。等待特定I/O设备的进程列表称为设备队列，每个设备都有自己的设备队列。 绝大多数进程可以分为I/O密集型或CPU密集型。I/O密集型的进程在执行I/O方面比执行计算要花费更多的时间。CPU密集型的进程将更多的时间用在计算上。 将CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态，这一任务被称为上下文切换。上下文切换时间是额外开销，因为切换时系统并不能做什么有用的工作。 进程在执行过程中，能够通过创建进程系统调用创建多个新进程。大多数操作系统根据一个唯一的进程标识符来识别进程，pid(process identifier)通常是一个整数值。 进程间通信有两种基本模式:共享内存和消息传递。在共享内存模式中，建立起一块共进程共享的内存区域，进程通过向此共享区域读或写入数据来交换信息。在消息传递模式中，通过在进程间交换消息来实现通信。 消息传递对于交换较少数量的数据很有用，因为不需要避免冲突。对于计算机间的通信，消息传递也比共享内存更易于实现。共享内存允许以最快的速度进行方便的通信，在计算机中它可以达到内存的速度。共享内存比消息传递快，消息传递系统通常用系统调用来实现，因此需要更多的内核介入的时间消耗。共享内存系统中仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有的访问都被处理为常规的内存访问，不需要内核的帮助。(共享内存和消息传递的比较) 什么是线程？ 线程是操作系统调度的基本单位，由线程ID、程序计数器、寄存器集合和栈组成。它与属于同一进程的其他线程共享代码段、数据段和其他操作系统资源，如打开文件和信号。 多线程编程有4个优点: 响应度高:如果对一个交互程序采用多线程，那么即使其他部分阻塞或执行较冗长的操作，该程序仍能继续执行，从而增加了对用户的响应程度。 资源共享:线程默认共享它们所属进程的内存和资源。 经济:进程创建所需要的内存和资源的分配比较昂贵。由于线程共享它们所属进程的资源，所以创建和切换线程会更为经济。 多处理器体系结构的利用:能充分利用多处理器体系结构，以便每个进程能并行运行在不同的处理器上。在多CPU上使用多线程加强了并发功能。 线程池的主要思想是在进程开始时创建一定数量的线程，并放入到池中以等待工作。当服务器收到请求时，它会唤醒池中的一个线程，并将要处理的请求传递给它。一旦线程完成了服务，它会返回池中再等待工作。如果池中没有可用的线程，那么服务器会一直等到有空线程为止。线程池有如下几个优点: 通常用现有线程处理请求要比等待创建新的线程要快。 线程池限制了在任何时候可用线程的数量。这对那些不能支持大量并发线程的系统非常重要。 线程池中的线程数量由系统CPU的数量、物理内存的大小和并发客户请求的期望值等因素决定。 进程和线程有哪些联系和区别？多进程还是多线程？我该怎么选择呢？参考资料 《操作系统概念》 进程和线程的概念什么是进程什么是线程进程通信和线程通信进程间通信线程间通信进程和线程优缺点进程的优缺点进程的优点进程的缺点线程的优缺点线程的优点线程的缺点","categories":[{"name":"Tech","slug":"Tech","permalink":"https://leel0330.github.io/categories/Tech/"}],"tags":[]},{"title":"LeetCode之字符串(中等)","slug":"LeetCode-字符串-中等","date":"2020-12-12T09:03:40.000Z","updated":"2020-12-27T05:06:34.892Z","comments":false,"path":"posts/723701661.html","link":"","permalink":"https://leel0330.github.io/posts/723701661.html","excerpt":"字符串(中等)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"字符串(中等)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 3. 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。 示例 1: 输入: \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2: 输入: \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3: 输入: \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 PythonJava123456789101112131415161718class Solution(object): def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; n = len(s) cset = set() i, j, res = 0, 0, 0 while i &lt; n and j &lt; n: if s[j] not in cset: cset.add(s[j]) res = max(res, j - i + 1) j += 1 else: cset.remove(s[i]) i += 1 return res12345678910111213141516171819class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int i = 0, j = 0; Set&lt;Character&gt; hashSet = new HashSet&lt;&gt;(); int n = s.length(); int res = 0; while (i &lt; n) &#123; if (hashSet.contains(s.charAt(i))) &#123; hashSet.remove(s.charAt(j)); j += 1; &#125; else &#123; hashSet.add(s.charAt(i)); i += 1; &#125; res = Math.max(res, i - j); &#125; return res; &#125;&#125; 5. 最长回文子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: \"babad\" 输出: \"bab\" 注意: \"aba\" 也是一个有效答案。 示例 2： 输入: \"cbbd\" 输出: \"bb\" PythonJava123456789101112131415161718192021222324252627class Solution(object): def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; if s is None or len(s) == 0: return &quot;&quot; res_left, res_right, res_len = 0, 0, 0 for i in xrange(0, len(s)): l1, r1, len1 = self.helper(s, i, i) l2, r2, len2 = self.helper(s, i, i + 1) if len1 &gt; len2: if len1 &gt; res_len: res_left, res_right, res_len = l1, r1, len1 else: if len2 &gt; res_len: res_left, res_right, res_len = l2, r2, len2 res_str = s[res_left:res_right + 1] return res_str def helper(self, s, left, right): L, R = left, right while L &gt;= 0 and R &lt; len(s) and s[L] == s[R]: L -= 1 R += 1 return L + 1, R - 1, R - L - 112345678910111213141516171819202122232425262728class Solution &#123; private int len; private String res; public String longestPalindrome(String s) &#123; len = 0; res = &quot;&quot;; int n = s.length(); for (int i = 0; i &lt; n; i++) &#123; helper(s, i, i); helper(s, i, i + 1); &#125; return res; &#125; private void helper(String s, int left, int right) &#123; int i = left, j = right; int n = s.length(); while (i &gt; -1 &amp;&amp; j &lt; n &amp;&amp; s.charAt(i) == s.charAt(j)) &#123; i -= 1; j += 1; &#125; if (j - i - 1 &gt; len) &#123; len = j - i - 1; res = s.substring(i + 1, j); &#125; &#125;&#125; 6. ZZ 字形变换将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下： L C I R E T O E S I I G E D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 示例 1: 输入: s = \"LEETCODEISHIRING\", numRows = 3 输出: \"LCIRETOESIIGEDHN\" 示例 2: 输入: s = \"LEETCODEISHIRING\", numRows = 4 输出: \"LDREOEIIECIHNTSG\" 解释: L D R E O E I I E C I H N T S G PythonJava12345678910111213141516171819202122class Solution(object): def convert(self, s, numRows): &quot;&quot;&quot; :type s: str :type numRows: int :rtype: str &quot;&quot;&quot; s_list = [[] for _ in xrange(numRows)] i, n = 0, len(s) while i &lt; n: for j in xrange(0, numRows): if i &lt; n: s_list[j].append(s[i]) i += 1 for j in xrange(numRows - 2, 0, -1): if i &lt; n: s_list[j].append(s[i]) i += 1 res = [] for i in xrange(numRows): res.extend(s_list[i]) return &#x27;&#x27;.join(res)123456789101112131415161718192021222324252627282930class Solution &#123; public String convert(String s, int numRows) &#123; List&lt;StringBuilder&gt; sbs = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; numRows; j++) &#123; sbs.add(new StringBuilder()); &#125; System.out.println(sbs.size()); int i = 0, n = s.length(); while (i &lt; n) &#123; for (int j = 0; j &lt; numRows; j++) &#123; if (i &lt; n) &#123; sbs.get(j).append(s.charAt(i)); i += 1; &#125; &#125; for (int j = numRows - 2; j &gt; 0; j--) &#123; if (i &lt; n) &#123; sbs.get(j).append(s.charAt(i)); i += 1; &#125; &#125; &#125; StringBuilder res = new StringBuilder(); for (StringBuilder sb : sbs) &#123; res.append(sb.toString()); &#125; return res.toString(); &#125;&#125; 22. 括号生成给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： [ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] PythonJava12345678910111213141516171819class Solution(object): def generateParenthesis(self, n): &quot;&quot;&quot; :type n: int :rtype: List[str] &quot;&quot;&quot; item, res = &#x27;&#x27;, [] self.helper(res, item, 0, 0, n) return res def helper(self, res, item, left, right, n): if left == n and right == n: res.append(item) return if left &lt; n: self.helper(res, item + &#x27;(&#x27;, left + 1, right, n) if right &lt; left: self.helper(res, item + &#x27;)&#x27;, left, right + 1, n)12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if (n == 0) &#123; return res; &#125; helper(n, n, &quot;&quot;, res); return res; &#125; private void helper(int left, int right, String cur, List&lt;String&gt; res) &#123; if (left &gt; right) &#123; return; &#125; if (left == 0 &amp;&amp; right == 0) &#123; res.add(cur); return; &#125; if (left &gt; 0) &#123; helper(left - 1, right, cur + &quot;(&quot;, res); &#125; if (right &gt; left) &#123; helper(left, right - 1, cur + &quot;)&quot;, res); &#125; &#125;&#125; 91. 解码方法一条包含字母 A-Z 的消息通过以下方式进行了编码： 'A' -> 1 'B' -> 2 ... 'Z' -> 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1: 输入: \"12\" 输出: 2 解释: 它可以解码为 \"AB\"（1 2）或者 \"L\"（12）。 示例 2: 输入: \"226\" 输出: 3 解释: 它可以解码为 \"BZ\" (2 26), \"VF\" (22 6), 或者 \"BBF\" (2 2 6) 。 PythonJava1234567891011121314151617181920class Solution(object): def numDecodings(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; if s is None or len(s) == 0: return 0 n = len(s) dp = [0 for _ in xrange(n + 1)] dp[0] = 1 dp[1] = 1 if s[0] != &#x27;0&#x27; else 0 for i in xrange(2, n + 1): one_c = int(s[i - 1:i]) two_c = int(s[i - 2:i]) if 1 &lt;= one_c &lt;= 9: dp[i] += dp[i - 1] if 10 &lt;= two_c &lt;= 26: dp[i] += dp[i - 2] return dp[n]123456789101112131415161718192021class Solution &#123; public int numDecodings(String s) &#123; int n = s.length(); int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = s.charAt(0) == &#x27;0&#x27; ? 0 : 1; for (int i = 2; i &lt; n + 1; i++) &#123; String one_s = s.substring(i - 1, i); String two_s = s.substring(i - 2, i); int one = Integer.parseInt(one_s); if (1 &lt;= one &amp;&amp; one &lt;= 9) &#123; dp[i] += dp[i - 1]; &#125; int two = Integer.parseInt(two_s); if (two &gt;= 10 &amp;&amp; two &lt;= 26) &#123; dp[i] += dp[i - 2]; &#125; &#125; return dp[n]; &#125;&#125; 93. 复原IP地址给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 示例: 输入: \"25525511135\" 输出: [\"255.255.11.135\", \"255.255.111.35\"] PythonJava123456789101112131415161718192021222324252627282930class Solution(object): def restoreIpAddresses(self, s): &quot;&quot;&quot; :type s: str :rtype: List[str] &quot;&quot;&quot; item, res = [], [] if s is None or len(s) &lt; 4 or len(s) &gt; 12: return res self.helper(s, item, res) return res def helper(self, s, item, res): if s == &#x27;&#x27; and len(item) == 4: res.append(&#x27;.&#x27;.join(item[:])) return for i in xrange(1, 4): sub_s = s[:i] if len(sub_s) == i and self.ok(sub_s): item.append(sub_s) self.helper(s[i:], item, res) item.pop(-1) def ok(self, s): if len(s) == 0: return False if len(s) &gt; 1 and s[0] == &#x27;0&#x27;: return False n = int(s) return 0 &lt;= n &lt;= 2551234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public List&lt;String&gt; restoreIpAddresses(String s) &#123; int n = s.length(); List&lt;String&gt; res = new ArrayList&lt;&gt;(); if (n &lt; 4 || n &gt; 12) &#123; return res; &#125; List&lt;String&gt; item = new ArrayList&lt;&gt;(); helper(s, 0, item, res); return res; &#125; private void helper(String s, int idx, List&lt;String&gt; item, List&lt;String&gt; res) &#123; if (idx == 4) &#123; if (s.length() &gt; 0) &#123; return; &#125; List&lt;String&gt; tmp = new ArrayList&lt;&gt;(); tmp.addAll(item); res.add(String.join(&quot;.&quot;, tmp)); return; &#125; for (int i = 1; i &lt; 4; i++) &#123; if (s.length() &lt; i) &#123; continue; &#125; String substr = s.substring(0, i); if (isOK(substr)) &#123; item.add(substr); helper(s.substring(i), idx + 1, item, res); item.remove(item.size() - 1); &#125; &#125; &#125; private boolean isOK(String s) &#123; if (s.length() == 0 || s.length() &gt; 3) &#123; return false; &#125; if (s.length() &gt; 1 &amp;&amp; s.charAt(0) == &#x27;0&#x27;) &#123; return false; &#125; int n = Integer.parseInt(s); return n &gt;= 0 &amp;&amp; n &lt;= 255; &#125;&#125; 316. 去除重复字母 [n]给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。 示例 1： 输入：s = \"bcabc\" 输出：\"abc\" 示例 2： 输入：s = \"cbacdcbc\" 输出：\"acdb\" 提示： 1 &lt;= s.length &lt;= 10^4 s 由小写英文字母组成 PythonJava1234567891011121314151617class Solution(object): def removeDuplicateLetters(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; stk = [] seen = set() m = &#123;c: i for i, c in enumerate(s)&#125; for i, c in enumerate(s): if c not in seen: while stk and stk[-1] &gt; c and m[stk[-1]] &gt; i: rm_c = stk.pop(-1) seen.discard(rm_c) seen.add(c) stk.append(c) return &#x27;&#x27;.join(stk)1234567891011121314151617181920212223242526class Solution &#123; public String removeDuplicateLetters(String s) &#123; Stack&lt;Character&gt; stk = new Stack&lt;&gt;(); Set&lt;Character&gt; seen = new HashSet&lt;&gt;(); Map&lt;Character, Integer&gt; m = new HashMap&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; m.put(s.charAt(i), i); &#125; for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if (!seen.contains(c)) &#123; while (stk.size() &gt; 0 &amp;&amp; stk.peek() &gt; c &amp;&amp; m.get(stk.peek()) &gt; i) &#123; char rm_c = stk.pop().charValue(); seen.remove(rm_c); &#125; seen.add(c); stk.add(c); &#125; &#125; StringBuilder res = new StringBuilder(stk.size()); for (int i = 0; i &lt; stk.size(); i++) &#123; res.append(stk.get(i)); &#125; return res.toString(); &#125;&#125; 402. 移掉K位数字给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。 注意: num 的长度小于 10002 且 ≥ k。 num 不会包含任何前导零。 示例 1 : 输入: num = \"1432219\", k = 3 输出: \"1219\" 解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。 示例 2 : 输入: num = \"10200\", k = 1 输出: \"200\" 解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。 示例 3 : 输入: num = \"10\", k = 2 输出: \"0\" 解释: 从原数字移除所有的数字，剩余为空就是0。 12345678910111213141516171819class Solution(object): def removeKdigits(self, num, k): &quot;&quot;&quot; :type num: str :type k: int :rtype: str &quot;&quot;&quot; stk = [] for c in num: while k and stk and stk[-1] &gt; c: stk.pop(-1) k -= 1 stk.append(c) while k: stk.pop(-1) k -= 1 if not stk: return &#x27;0&#x27; return str(int(&#x27;&#x27;.join(stk))) 424. 替换后的最长重复字符[n]给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。 注意: 字符串长度 和 k 不会超过 104。 示例 1: 输入: s = \"ABAB\", k = 2 输出: 4 解释: 用两个'A'替换为两个'B',反之亦然。 示例 2: 输入: s = \"AABABBA\", k = 1 输出: 4 解释: 将中间的一个'A'替换为'B',字符串变为 \"AABBBBA\"。 子串 \"BBBB\" 有最长重复字母, 答案为 4。 123456789101112131415161718class Solution(object): def characterReplacement(self, s, k): &quot;&quot;&quot; :type s: str :type k: int :rtype: int &quot;&quot;&quot; m = &#123;&#125; start, end, max_freq, res = 0, 0, 0, 0 while end &lt; len(s): m[s[end]] = 1 if s[end] not in m else m[s[end]] + 1 max_freq = max(max_freq, m[s[end]]) if end - start + 1 - max_freq &gt; k: m[s[start]] -= 1 start += 1 res = max(res, end - start + 1) end += 1 return res 556. Next Greater Element III [n]给定一个32位正整数 n，你需要找到最小的32位整数，其与 n 中存在的位数完全相同，并且其值大于n。如果不存在这样的32位整数，则返回-1。 示例 1: 输入: 12 输出: 21 示例 2: 输入: 21 输出: -1 1234567891011121314151617181920212223242526class Solution(object): def nextGreaterElement(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; max_val = (1 &lt;&lt; 32) - 1 nums = [int(i) for i in str(n)] i = len(nums) - 1 while i &gt; 0: if nums[i - 1] &lt; nums[i]: break i -= 1 if i == 0: return -1 x = nums[i - 1] smallest = i for j in xrange(i + 1, len(nums)): if nums[j] &gt; x and nums[j] &lt; nums[smallest]: smallest = j nums[i - 1], nums[smallest] = nums[smallest], nums[i - 1] left = nums[:i] right = sorted(nums[i:]) nums = left + right v = int(&#x27;&#x27;.join([str(i) for i in nums])) return v if v &lt; max_val else -1 583. 两个字符串的删除操作 [n]给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。 示例 1: 输入: \"sea\", \"eat\" 输出: 2 解释: 第一步将\"sea\"变为\"ea\"，第二步将\"eat\"变为\"ea\" 说明: 给定单词的长度不超过500。 给定单词中的字符只含有小写字母。 12345678910111213141516171819class Solution(object): def minDistance(self, word1, word2): &quot;&quot;&quot; :type word1: str :type word2: str :rtype: int &quot;&quot;&quot; len1, len2 = len(word1), len(word2) dp = [[0 for _ in xrange(len2 + 1)] for _ in xrange(len1 + 1)] for i in xrange(len1 + 1): for j in xrange(len2 + 1): if i == 0 or j == 0: continue elif word1[i - 1] == word2[j - 1]: dp[i][j] = 1 + dp[i - 1][j - 1] else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) lcs = dp[len1][len2] return len1 + len2 - 2 * lcs 647. 回文子串给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。 示例 1: 输入: \"abc\" 输出: 3 解释: 三个回文子串: \"a\", \"b\", \"c\". 示例 2: 输入: \"aaa\" 输出: 6 说明: 6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\". 注意: 输入的字符串长度不会超过1000。 1234567891011121314151617181920class Solution(object): def __init__(self): self.res = 0 def countSubstrings(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; self.res = 0 for i in xrange(0, len(s)): self.helper(s, i, i) self.helper(s, i, i + 1) return self.res def helper(self, s, left, right): while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]: self.res += 1 left -= 1 right += 1 678. 有效的括号字符串 [n]给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则： 任何左括号 ( 必须有相应的右括号 )。 任何右括号 ) 必须有相应的左括号 ( 。 左括号 ( 必须在对应的右括号之前 )。 * 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。 一个空字符串也被视为有效字符串。 示例 1: 输入: \"()\" 输出: True 示例 2: 输入: \"(*)\" 输出: True 示例 3: 输入: \"(*))\" 输出: True 注意: 字符串大小将在 [1，100] 范围内。 123456789101112131415161718192021class Solution(object): def checkValidString(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; low, high = 0, 0 for c in s: if c == &#x27;(&#x27;: low, high = low +1, high + 1 elif c == &#x27;)&#x27;: if low &gt; 0: low -= 1 high -= 1 else: if low &gt; 0: low -= 1 high += 1 if high &lt; 0: return False return low == 0 767. 重构字符串给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。 若可行，输出任意可行的结果。若不可行，返回空字符串。 示例 1: 输入: S = \"aab\" 输出: \"aba\" 示例 2: 输入: S = \"aaab\" 输出: \"\" 注意: S 只包含小写字母并且长度在[1, 500]区间内。 123456789101112131415161718192021222324252627282930313233343536class Solution(object): def reorganizeString(self, S): &quot;&quot;&quot; :type S: str :rtype: str &quot;&quot;&quot; char_cnt = [0 for _ in xrange(26)] max_char = None i_a = ord(&#x27;a&#x27;) for c in S: i = ord(c) - i_a char_cnt[i] += 1 if max_char is None: max_char = c else: j = ord(max_char) - i_a if char_cnt[i] &gt; char_cnt[j]: max_char = c if 2 * char_cnt[ord(max_char) - i_a] -1 &gt; len(S): return &quot;&quot; res = [&#x27;&#x27; for _ in xrange(len(S))] i_max_char = ord(max_char) - i_a i = 0 for j in xrange (char_cnt[i_max_char]): res[i] = max_char i += 2 char_cnt[i_max_char] = 0 for j in xrange(26): if char_cnt[j] &gt; 0: c = chr(j + i_a) for k in xrange(char_cnt[j]): if i &gt;= len(S): i = 1 res[i] = c i += 2 return &quot;&quot;.join(res) 856. 括号的分数给定一个平衡括号字符串 S，按下述规则计算该字符串的分数： () 得 1 分。AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。(A) 得 2 * A 分，其中 A 是平衡括号字符串。 示例 1： 输入： \"()\" 输出： 1 示例 2： 输入： \"(())\" 输出： 2 示例 3： 输入： \"()()\" 输出： 2 示例 4： 输入： \"(()(()))\" 输出： 6 提示： S 是平衡括号字符串，且只含有 ( 和 ) 。 2 &lt;= S.length &lt;= 50 123456789101112131415161718192021class Solution(object): def scoreOfParentheses(self, S): &quot;&quot;&quot; :type S: str :rtype: int &quot;&quot;&quot; stk = [] for c in S: if c == &#x27;(&#x27;: stk.append(-1) else: cnt = 0 while stk[-1] != -1: cnt += stk[-1] stk.pop(-1) stk.pop(-1) if cnt == 0: stk.append(1) else: stk.append(2 * cnt) return sum(stk) 890. 查找和替换模式你有一个单词列表 words 和一个模式 pattern，你想知道 words 中的哪些单词与模式匹配。 如果存在字母的排列 p ，使得将模式中的每个字母 x 替换为 p(x) 之后，我们就得到了所需的单词，那么单词与模式是匹配的。 （回想一下，字母的排列是从字母到字母的双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母。） 返回 words 中与给定模式匹配的单词列表。 你可以按任何顺序返回答案。 示例： 输入：words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\" 输出：[\"mee\",\"aqq\"] 解释： \"mee\" 与模式匹配，因为存在排列 {a -> m, b -> e, ...}。 \"ccc\" 与模式不匹配，因为 {a -> c, b -> c, ...} 不是排列。 因为 a 和 b 映射到同一个字母。 提示： 1 &lt;= words.length &lt;= 50 1 &lt;= pattern.length = words[i].length &lt;= 20 12345678910111213141516171819202122232425class Solution(object): def findAndReplacePattern(self, words, pattern): &quot;&quot;&quot; :type words: List[str] :type pattern: str :rtype: List[str] &quot;&quot;&quot; res = [] p = self.helper(pattern) for w in words: pw = self.helper(w) if pw == p: res.append(w) return res def helper(self, pattern): m = &#123;&#125; res = [] for c in pattern: if c in m: res.append(m[c]) else: m[c] = len(m) + 1 res.append(m[c]) return &#x27;&#x27;.join([str(i) for i in res])","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode之字符串(简单)","slug":"LeetCode-字符串-简单","date":"2020-12-11T13:38:13.000Z","updated":"2020-12-27T05:06:53.757Z","comments":false,"path":"posts/c026ad95.html","link":"","permalink":"https://leel0330.github.io/posts/c026ad95.html","excerpt":"字符串(简单)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"字符串(简单)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 14. 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1: 输入: [\"flower\",\"flow\",\"flight\"] 输出: \"fl\" 示例 2: 输入: [\"dog\",\"racecar\",\"car\"] 输出: \"\" 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 123456789101112131415class Solution(object): def longestCommonPrefix(self, strs): &quot;&quot;&quot; :type strs: List[str] :rtype: str &quot;&quot;&quot; res = &quot;&quot; if strs is None or len(strs) == 0: return res for i, c in enumerate(strs[0]): for j in xrange(1, len(strs)): if i &gt;= len(strs[j]) or strs[j][i] != c: return res res += c return res 443. 压缩字符串给定一组字符，使用原地算法将其压缩。 压缩后的长度必须始终小于或等于原数组长度。 数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。 在完成原地修改输入数组后，返回数组的新长度。 进阶： 你能否仅使用O(1) 空间解决问题？ 示例 1： 输入： [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"] 输出： 返回6，输入数组的前6个字符应该是：[\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"] 说明： \"aa\"被\"a2\"替代。\"bb\"被\"b2\"替代。\"ccc\"被\"c3\"替代。 示例 2： 输入： [\"a\"] 输出： 返回1，输入数组的前1个字符应该是：[\"a\"] 说明： 没有任何字符串被替代。 示例 3： 输入： [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"] 输出： 返回4，输入数组的前4个字符应该是：[\"a\",\"b\",\"1\",\"2\"]。 说明： 由于字符\"a\"不重复，所以不会被压缩。\"bbbbbbbbbbbb\"被“b12”替代。 注意每个数字在数组中都有它自己的位置。 注意： 所有字符都有一个ASCII值在[35, 126]区间内。 1 &lt;= len(chars) &lt;= 1000。 123456789101112131415161718192021class Solution(object): def compress(self, chars): &quot;&quot;&quot; :type chars: List[str] :rtype: int &quot;&quot;&quot; res = [] i = 0 while i &lt; len(chars): c, cnt = chars[i], 0 while i &lt; len(chars) and chars[i] == c: cnt += 1 i += 1 if cnt == 1: res.append(c) else: res.append(c) res.extend([c for c in str(cnt)]) for idx, c in enumerate(res): chars[idx] = c return len(res) 680. 验证回文字符串 Ⅱ给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例 1: 输入: \"aba\" 输出: True 示例 2: 输入: \"abca\" 输出: True 解释: 你可以删除c字符。 注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000 12345678910111213141516171819202122232425class Solution(object): def validPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; i, j = 0, len(s) - 1 while i &lt; j and s[i] == s[j]: i += 1 j -= 1 if i &gt;= j: return True if self.isPalindrome(s, i + 1, j) or self.isPalindrome(s, i, j - 1): return True return False def isPalindrome(self, s, i, j): if i &gt; j: return False while i &lt; j: if s[i] != s[j]: return False i += 1 j -= 1 return True 696. 计数二进制子串 [n]给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。 重复出现的子串要计算它们出现的次数。 示例 1 : 输入: \"00110011\" 输出: 6 解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。 请注意，一些重复出现的子串要计算它们出现的次数。 另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。 示例 2 : 输入: \"10101\" 输出: 4 解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。 注意： s.length 在1到50,000之间。 s 只包含“0”或“1”字符。 123456789101112131415161718class Solution(object): def countBinarySubstrings(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; res = pre = 0 cur = 1 n = len(s) for i in xrange(1, n): if s[i] == s[i - 1]: cur += 1 else: pre = cur cur = 1 if pre &gt;= cur: res += 1 return res 788. 旋转数字我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。 如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。 现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？ 示例: 输入: 10 输出: 4 解释: 在[1, 10]中有四个好数： 2, 5, 6, 9。 注意 1 和 10 不是好数, 因为他们在旋转之后不变。 注意: N 的取值范围是 [1, 10000]。 123456789101112131415161718class Solution(object): def rotatedDigits(self, N): &quot;&quot;&quot; :type N: int :rtype: int &quot;&quot;&quot; cnt = 0 for i in xrange(1, N + 1): if self.isGoodNum(i): cnt += 1 return cnt def isGoodNum(self, n): if any(x in str(n) for x in [&#x27;3&#x27;, &#x27;4&#x27;, &#x27;7&#x27;]): return False if any(x in str(n) for x in [&#x27;2&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;9&#x27;]): return True return False 859. 亲密字符串给定两个由小写字母构成的字符串 A 和 B ，只要我们可以通过交换 A 中的两个字母得到与 B 相等的结果，就返回 true ；否则返回 false 。 示例 1： 输入： A = \"ab\", B = \"ba\" 输出： true 示例 2： 输入： A = \"ab\", B = \"ab\" 输出： false 示例 3: 输入： A = \"aa\", B = \"aa\" 输出： true 示例 4： 输入： A = \"aaaaaaabc\", B = \"aaaaaaacb\" 输出： true 示例 5： 输入： A = \"\", B = \"aa\" 输出： false 提示： 0 &lt;= A.length &lt;= 20000 0 &lt;= B.length &lt;= 20000 A 和 B 仅由小写字母构成。 1234567891011121314151617class Solution(object): def buddyStrings(self, A, B): if len(A) != len(B): return False if A == B: seen = set() for a in A: if a in seen: return True seen.add(a) return False else: pairs = [] for a, b in zip(A, B): if a != b: pairs.append((a, b)) if len(pairs) &gt; 2: return False return len(pairs) == 2 and pairs[0] == pairs[1][::-1] 925. 长按键入你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。 你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。 示例 1： 输入：name = \"alex\", typed = \"aaleex\" 输出：true 解释：'alex' 中的 'a' 和 'e' 被长按。 示例 2： 输入：name = \"saeed\", typed = \"ssaaedd\" 输出：false 解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。 示例 3： 输入：name = \"leelee\", typed = \"lleeelee\" 输出：true 示例 4： 输入：name = \"laiden\", typed = \"laiden\" 输出：true 解释：长按名字中的字符并不是必要的。 提示： name.length &lt;= 1000 typed.length &lt;= 1000 name 和 typed 的字符都是小写字母。 123456789101112131415161718192021222324252627282930class Solution(object): def isLongPressedName(self, name, typed): &quot;&quot;&quot; :type name: str :type typed: str :rtype: bool &quot;&quot;&quot; a = self.getHelper(name) b = self.getHelper(typed) if len(a) != len(b): return False for idx in xrange(0, len(a), 2): if a[idx] != b[idx]: return False if a[idx + 1] &gt; b[idx + 1]: return False return True def getHelper(self, s): res = [] idx = 0 while idx &lt; len(s): cur_c, cnt = s[idx], 0 while idx &lt; len(s) and s[idx] == cur_c: idx += 1 cnt += 1 res.append(cur_c) res.append(cnt) return res","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode刷题指南(持续更新中)","slug":"LeetCode刷题指南","date":"2020-12-05T07:07:21.000Z","updated":"2021-03-14T14:04:19.203Z","comments":false,"path":"posts/af9ea9dd.html","link":"","permalink":"https://leel0330.github.io/posts/af9ea9dd.html","excerpt":"这个LeetCode分类是我刷题过程中整理出来的值得刷的题目。 因为我对Python比较熟练，所以大部分代码是用Python实现的😬。","text":"这个LeetCode分类是我刷题过程中整理出来的值得刷的题目。 因为我对Python比较熟练，所以大部分代码是用Python实现的😬。 首先需要说明的是，本人不做大而全的刷题目录，题目现在实在太多了，而且网上已经有一些人这么做了，对于刚开始刷题的你其实并不是十分友好。如果需要我可以在结尾给出一些链接，基本涵盖了所有题目，而且也有一些详细的解释。本人也不做题解，因为代码能看懂的话基本上不需要再阐释了，如果你需要，可以参考我给出的链接，我在刷题过程中也参考了别人的解法。(打算等根据tag刷完后，将标记出[n]的题目给出一份详细的解题指南)总之三人行，必有我师。希望你的刷题之路顺利。 本人刷题一开始是按照官方上Tag来刷了，因为自己的算法基础比较薄弱，就采取了相对比较容易的路子。同时按照Tag刷，暗示了题目可能会用到的算法和数据结构，本人又只选取了简单和中等的题目，所以刷起来相对轻松一点。为了方便，这里列出了一些本人认为非常重要的Tag(✅表示已完成)： Tag类别完成状态防迷路链接 广度优先遍历✅LeetCode之广度优先遍历 动态规划(中等)✅LeetCode之动态规划(中等) 数组(简单)✅LeetCode之数组(简单) 数组(中等)✅LeetCode之数组(中等) 数组(困难)✅LeetCode之数组(困难) 字符串(简单)✅LeetCode之字符串(简单) 字符串(中等)✅LeetCode之字符串(中等) 二叉树(简单)✅LeetCode之二叉树(简单) 二叉树(中等)✅LeetCode之二叉树(中等) 链表✅LeetCode之链表 哈希表✅LeetCode之哈希表 栈和队列✅LeetCode之栈和队列 堆 图 二分查找 深度优先遍历 双指针 回溯 如果按照这些Tag来刷，并选择简单和中等的题目，大概可以刷400-500的题目，基础和经典的题目基本都能覆盖到，对于首次刷题的你还是很友好的。 另一种刷的方式就是按照公司来刷，比如你心意的FLAG(Facebook,Linkedin,Amazon,Google)和Microsoft。可以小试牛刀，看下各家面试题的风格。这里罗列几个比较出名的公司： Google [✅] Microsoft [✅] Linkedin [✅] Facebook [✅] Amazon [✅] 最后的最后，给出本人认为比较好的几个人的刷题链接，在刷题的过程中可以看下别人的解法，对自己写代码的能力提升会很有帮助，废话不多讲，传送门如下： 首推花花酱：https://zxi.mytechroad.com/blog/ grandyang的博客： https://www.cnblogs.com/grandyang/p/4606334.html https://github.com/luliyucoordinate/Leetcode https://github.com/WuLC/LeetCode/tree/master/Algorithm/Python http://bookshadow.com/leetcode/ https://blog.csdn.net/fuxuemingzhu 如果你需要的话，可以联系我，把你的刷题链接附上来，方便大家你我他😁。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode之二叉树(中等)","slug":"LeetCode-二叉树-中等","date":"2020-12-05T02:29:51.000Z","updated":"2020-12-27T05:05:41.000Z","comments":false,"path":"posts/3ddb3bb0.html","link":"","permalink":"https://leel0330.github.io/posts/3ddb3bb0.html","excerpt":"二叉树(中等)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"二叉树(中等)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 95. 不同的二叉搜索树 II [n]给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。 示例: 输入: 3 输出: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] 解释: 以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 12345678910111213141516171819202122232425class Solution(object): def generateTrees(self, n): &quot;&quot;&quot; :type n: int :rtype: List[TreeNode] &quot;&quot;&quot; if n == 0: return [] return self.helper(1, n) def helper(self, start, end): if start &gt; end: return [None] res = [] for i in xrange(start, end + 1): lefts = self.helper(start, i - 1) rights = self.helper(i + 1, end) for left in lefts: for right in rights: node = TreeNode(i) node.left = left node.right = right res.append(node) return res 96. 不同的二叉搜索树 [n]给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 123456789101112class Solution(object): def numTrees(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; dp = [0 for _ in xrange(n + 1)] dp[0] = dp[1] = 1 for i in xrange(2, n + 1): for j in xrange(0, i): dp[i] += dp[j] * dp[i - 1 - j]#减一是因为根节点 return dp[n] 105. 从前序与中序遍历序列构造二叉树根据一棵树的前序遍历与中序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素。 例如，给出 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 12345678910111213141516171819202122232425class Solution(object): def buildTree(self, preorder, inorder): &quot;&quot;&quot; :type preorder: List[int] :type inorder: List[int] :rtype: TreeNode &quot;&quot;&quot; m = &#123;&#125; for idx, v in enumerate(inorder): m[v] = idx return self.helper(preorder, 0, len(preorder) - 1, \\ inorder, 0, len(inorder) - 1, m) def helper(self, preorder, pre_s, pre_e, inorder, in_s, in_e, m): if pre_s &gt; pre_e or in_s &gt; in_e: return None root_v = preorder[pre_s] root_idx = m[root_v] left_len = root_idx - in_s root = TreeNode(root_v) root.left = self.helper(preorder, pre_s + 1, pre_s + left_len, \\ inorder, in_s, root_idx - 1, m) root.right = self.helper(preorder, pre_s + left_len + 1, pre_e, \\ inorder, root_idx + 1, in_e, m) return root 106. 从中序与后序遍历序列构造二叉树根据一棵树的中序遍历与后序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素。 例如，给出 中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 12345678910111213141516171819202122232425class Solution(object): def buildTree(self, inorder, postorder): &quot;&quot;&quot; :type inorder: List[int] :type postorder: List[int] :rtype: TreeNode &quot;&quot;&quot; m = &#123;&#125; for idx, v in enumerate(inorder): m[v] = idx return self.helper(inorder, 0, len(inorder) - 1, \\ postorder, 0, len(postorder) - 1, m) def helper(self, inorder, in_left, in_right, postorder, post_left, post_right, m): if in_left &gt; in_right: return None root_val = postorder[post_right] root_idx = m[root_val] left_len = root_idx - in_left root = TreeNode(root_val) root.left = self.helper(inorder, in_left, root_idx - 1, \\ postorder, post_left, post_left + left_len - 1, m) root.right = self.helper(inorder, root_idx + 1, in_right, \\ postorder, post_left + left_len, post_right - 1, m) return root 114. 二叉树展开为链表给定一个二叉树，原地将它展开为链表。 例如，给定二叉树 1 / \\ 2 5 / \\ \\ 3 4 6 将其展开为： 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 12345678910111213141516171819202122232425class Solution(object): def flatten(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: None Do not return anything, modify root in-place instead. &quot;&quot;&quot; items = self.pre_order(root) for i in xrange(len(items) - 1): items[i].left = None items[i].right = items[i + 1] return root def pre_order(self, root): # 前序遍历 items = [] p = root stk = [] while p or stk: while p: items.append(p) stk.append(p) p = p.left node = stk.pop(-1) p = node.right return items 117. 填充每个节点的下一个右侧节点指针 II给定一个二叉树 struct Node { int val; Node *left; Node *right; Node *next; } 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 12345678910111213141516171819202122class Solution(object): def connect(self, root): &quot;&quot;&quot; :type root: Node :rtype: Node &quot;&quot;&quot; if root is None: return root queue = [root] while queue: sz = len(queue) prev = None for i in xrange(sz): node = queue.pop(0) if prev: prev.next = node prev = node if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root 236. 二叉树的最近公共祖先 [n]给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 示例 1: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 123456789101112131415class Solution(object): def lowestCommonAncestor(self, root, p, q): &quot;&quot;&quot; :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode &quot;&quot;&quot; if root is None or root == p or root == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if left and right: return root return left if left else right 331. 验证二叉树的前序序列化 [n]序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。 _9_ / \\ 3 2 / \\ / \\ 4 1 # 6 / \\ / \\ / \\ # # # # # # 例如，上面的二叉树可以被序列化为字符串 “9,3,4,#,#,1,#,#,2,#,6,#,#”，其中 # 代表一个空节点。 给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 ‘#’ 。 你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 “1,,3” 。 示例 1: 输入: \"9,3,4,#,#,1,#,#,2,#,6,#,#\" 输出: true 示例 2: 输入: \"1,#\" 输出: false 示例 3: 输入: \"9,#,#,1\" 输出: false 12345678910111213class Solution(object): def isValidSerialization(self, preorder): &quot;&quot;&quot; :type preorder: str :rtype: bool &quot;&quot;&quot; stk = [] for c in preorder.split(&#x27;,&#x27;): stk.append(c) while len(stk) &gt;= 3 and stk[-2:] == [&#x27;#&#x27;, &#x27;#&#x27;] and stk[-3] != &#x27;#&#x27;: stk = stk[:-3] stk.append(&#x27;#&#x27;) return stk == [&#x27;#&#x27;] 337. 打家劫舍 III [n]在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 示例 1: 输入: [3,2,3,null,3,null,1] 3 / \\ 2 3 \\ \\ 3 1 输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7. 示例 2: 输入: [3,4,5,1,3,null,1] 3 / \\ 4 5 / \\ \\ 1 3 1 输出: 9 解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9. 123456789101112131415161718192021222324class Solution(object): def rob(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; if root is None: return 0 m = &#123;&#125; return self.helper(root, m) def helper(self, root, m): if root is None: return 0 if root in m: return m[root] val = root.val if root.left: val += self.helper(root.left.left, m) + self.helper(root.left.right, m) if root.right: val += self.helper(root.right.left, m) + self.helper(root.right.right, m) res = max(val, self.helper(root.left, m) + self.helper(root.right, m)) m[root] = res return res 437. 路径总和 III给定一个二叉树，它的每个结点都存放着一个整数值。 找出路径和等于给定数值的路径总数。 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。 示例： root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\ 3 -2 1 返回 3。和等于 8 的路径有: 1. 5 -> 3 2. 5 -> 2 -> 1 3. -3 -> 11 123456789101112131415161718192021222324252627class Solution(object): def pathSum(self, root, target): &quot;&quot;&quot; :type root: TreeNode :type target: int :rtype: int &quot;&quot;&quot; if root is None: return 0 self.res = 0 queue = [root] while queue: node = queue.pop(0) self.dfs(node, target) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return self.res def dfs(self, root, target): if root is None: return if root.val == target: self.res += 1 self.dfs(root.left, target - root.val) self.dfs(root.right, target - root.val) 449. 序列化和反序列化二叉搜索树12345678910111213141516171819202122232425262728293031323334353637383940class Codec: def serialize(self, root): &quot;&quot;&quot;Encodes a tree to a single string. :type root: TreeNode :rtype: str &quot;&quot;&quot; stk, p = [], root res = [] while stk or p: while p: res.append(p.val) stk.append(p) p = p.left node = stk.pop(-1) p = node.right return &#x27; &#x27;.join(map(str, res)) def deserialize(self, data): &quot;&quot;&quot;Decodes your encoded data to tree. :type data: str :rtype: TreeNode &quot;&quot;&quot; preorder = map(int, data.split()) inorder = sorted(preorder) return self.build_tree(preorder, inorder) def build_tree(self, preorder, inorder): if not preorder: return None root_v = preorder[0] idx = inorder.index(root_v) root = TreeNode(root_v) root.left = self.build_tree(preorder[1:1+idx], inorder[:idx]) root.right =self.build_tree(preorder[1+idx:], inorder[idx+1:]) return root 450. 删除二叉搜索树中的节点 [n]给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 一般来说，删除节点可分为两个步骤： 首先找到需要删除的节点；如果找到了，删除它。说明： 要求算法时间复杂度为 O(h)，h 为树的高度。 示例: root = [5,3,6,2,4,null,7] key = 3 5 / \\ 3 6 / \\ \\ 2 4 7 给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。 一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。 5 / \\ 4 6 / \\ 2 7 另一个正确答案是 [5,2,6,null,4,null,7]。 5 / \\ 2 6 \\ \\ 4 7 12345678910111213141516171819202122232425262728class Solution(object): def deleteNode(self, root, key): &quot;&quot;&quot; :type root: TreeNode :type key: int :rtype: TreeNode &quot;&quot;&quot; if root is None: return root if key &lt; root.val: root.left = self.deleteNode(root.left, key) elif key &gt; root.val: root.right = self.deleteNode(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left else: node = self.findMin(root.right) root.val = node.val root.right = self.deleteNode(root.right, node.val) return root def findMin(self, node): while node.left: node = node.left return node 508. 出现次数最多的子树元素和给出二叉树的根，找出出现次数最多的子树元素和。一个结点的子树元素和定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。然后求出出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的元素（不限顺序）。 示例 1 输入: 5 / \\ 2 -3 返回 [2, -3, 4]，所有的值均只出现一次，以任意顺序返回所有值。 示例 2 输入: 5 / \\ 2 -5 返回 [2]，只有 2 出现两次，-5 只出现 1 次。 123456789101112131415161718192021222324252627class Solution(object): def findFrequentTreeSum(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[int] &quot;&quot;&quot; self.m = &#123;&#125; self.res = [] self.cnt = 0 self.helper(root) for k, v in self.m.iteritems(): if v == self.cnt: self.res.append(k) return self.res def helper(self, root): if root is None: return 0 left = self.helper(root.left) right = self.helper(root.right) cur_sum = left + right + root.val if cur_sum in self.m: self.m[cur_sum] += 1 else: self.m[cur_sum] = 1 self.cnt = max(self.cnt, self.m[cur_sum]) return cur_sum 538. 把二叉搜索树转换为累加树给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。 例如： 输入: 二叉搜索树: 5 / \\ 2 13 输出: 转换为累加树: 18 / \\ 20 13 12345678910111213141516171819class Solution(object): def convertBST(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; p = root stk = [] prev = 0 while p or stk: while p: stk.append(p) p = p.right node = stk.pop(-1) old_v = node.val node.val += prev prev += old_v p = node.left return root 623. 在二叉树中增加一行给定一个二叉树，根节点为第1层，深度为 1。在其第 d 层追加一行值为 v 的节点。 添加规则：给定一个深度值 d （正整数），针对深度为 d-1 层的每一非空节点 N，为 N 创建两个值为 v 的左子树和右子树。 将 N 原先的左子树，连接为新节点 v 的左子树；将 N 原先的右子树，连接为新节点 v 的右子树。 如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。 示例 1: 输入: 二叉树如下所示: 4 / \\ 2 6 / \\ / 3 1 5 v = 1 d = 2 输出: 4 / \\ 1 1 / \\ 2 6 / \\ / 3 1 5 示例 2: 输入: 二叉树如下所示: 4 / 2 / \\ 3 1 v = 1 d = 3 输出: 4 / 2 / \\ 1 1 / \\ 3 1 注意: 输入的深度值 d 的范围是：[1，二叉树最大深度 + 1]。 输入的二叉树至少有一个节点。 1234567891011121314151617181920212223242526272829303132class Solution(object): def addOneRow(self, root, v, d): &quot;&quot;&quot; :type root: TreeNode :type v: int :type d: int :rtype: TreeNode &quot;&quot;&quot; if d == 1: new_root = TreeNode(v) new_root.left = root return new_root queue = [root] for _ in xrange(d - 2): sz = len(queue) for _ in xrange(sz): node = queue.pop(0) if node.left: queue.append(node.left) if node.right: queue.append(node.right) while queue: node = queue.pop(0) tmp = node.left new_node = TreeNode(v) new_node.left = tmp node.left = new_node tmp = node.right new_node = TreeNode(v) new_node.right = tmp node.right = new_node return root 652. 寻找重复的子树 [n]给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。 两棵树重复是指它们具有相同的结构以及相同的结点值。 示例 1： 1 / \\ 2 3 / / \\ 4 2 4 / 4 下面是两个重复的子树： 2 / 4 和 4 因此，你需要以列表的形式返回上述重复子树的根结点。 1234567891011121314151617181920212223class Solution(object): def findDuplicateSubtrees(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[TreeNode] &quot;&quot;&quot; m, res = &#123;&#125;, [] self.helper(root, m) for k, v in m.iteritems(): if len(v) &gt; 1: res.append(v[0]) return res def helper(self, root, m): if root is None: return &quot;&quot; s = &quot;(&quot; + self.helper(root.left, m) + str(root.val) + \\ self.helper(root.right, m) + &quot;)&quot; if s in m: m[s].append(root) else: m[s] = [root] return s 654. 最大二叉树给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下： 二叉树的根是数组中的最大元素。 左子树是通过数组中最大值左边部分构造出的最大二叉树。 右子树是通过数组中最大值右边部分构造出的最大二叉树。 通过给定的数组构建最大二叉树，并且输出这个树的根节点。 示例 ： 输入：[3,2,1,6,0,5] 输出：返回下面这棵树的根节点： 6 / \\ 3 5 \\ / 2 0 \\ 1 提示： 给定的数组的大小在 [1, 1000] 之间。 1234567891011121314151617181920class Solution(object): def constructMaximumBinaryTree(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: TreeNode &quot;&quot;&quot; m = &#123;&#125; for idx, v in enumerate(nums): m[v] = idx return self.helper(nums, 0, len(nums) - 1, m) def helper(self, nums, left, right, m): if left &gt; right: return None max_v = max(nums[left: right + 1]) max_idx = m[max_v] root = TreeNode(max_v) root.left = self.helper(nums, left, max_idx - 1, m) root.right = self.helper(nums, max_idx + 1, right, m) return root 655. 输出二叉树 [n]在一个 m*n 的二维字符串数组中输出二叉树，并遵守以下规则： 行数 m 应当等于给定二叉树的高度。 列数 n 应当总是奇数。 根节点的值（以字符串格式给出）应当放在可放置的第一行正中间。根节点所在的行与列会将剩余空间划分为两部分（左下部分和右下部分）。你应该将左子树输出在左下部分，右子树输出在右下部分。左下和右下部分应当有相同的大小。即使一个子树为空而另一个非空，你不需要为空的子树输出任何东西，但仍需要为另一个子树留出足够的空间。然而，如果两个子树都为空则不需要为它们留出任何空间。 每个未使用的空间应包含一个空的字符串””。 使用相同的规则输出子树。 示例 1: 输入: 1 / 2 输出: [[\"\", \"1\", \"\"], [\"2\", \"\", \"\"]] 示例 2: 输入: 1 / \\ 2 3 \\ 4 输出: [[\"\", \"\", \"\", \"1\", \"\", \"\", \"\"], [\"\", \"2\", \"\", \"\", \"\", \"3\", \"\"], [\"\", \"\", \"4\", \"\", \"\", \"\", \"\"]] 示例 3: 输入: 1 / \\ 2 5 / 3 / 4 输出: [[\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"1\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"] [\"\", \"\", \"\", \"2\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"5\", \"\", \"\", \"\"] [\"\", \"3\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"] [\"4\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]] 注意: 二叉树的高度在范围 [1, 10] 中。 1234567891011121314151617181920212223242526class Solution(object): def printTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[List[str]] &quot;&quot;&quot; if root is None: return [] height = self.getHeight(root) width = (1 &lt;&lt; height) - 1 res = [[&quot;&quot;] * width for _ in xrange(height)] self.helper(root, 0, width - 1, 0, height, res) return res def helper(self, root, left, right, h, height, res): if root is None or h == height: return mid = (left + right) / 2 res[h][mid] = str(root.val) self.helper(root.left, left, mid - 1, h + 1, height, res) self.helper(root.right, mid + 1, right, h + 1, height, res) def getHeight(self, root): if root is None: return 0 return max(self.getHeight(root.left), self.getHeight(root.right)) + 1 687. 最长同值路径 [n]给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。 注意：两个节点之间的路径长度由它们之间的边数表示。 示例 1: 输入: 5 / \\ 4 5 / \\ \\ 1 1 5 输出: 2 示例 2: 输入: 1 / \\ 4 5 / \\ \\ 4 4 5 输出: 2 注意: 给定的二叉树不超过10000个结点。 树的高度不超过1000。 12345678910111213141516171819202122class Solution(object): def longestUnivaluePath(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; self.res = 0 self.helper(root) return self.res def helper(self, root): if root is None: return 0 left = self.helper(root.left) right = self.helper(root.right) pl, pr = 0, 0 if root.left and root.left.val == root.val: pl = left + 1 if root.right and root.right.val == root.val: pr = right + 1 self.res = max(self.res, pl + pr) return max(pl, pr) 701. 二叉搜索树中的插入操作给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。 例如, 给定二叉搜索树: 4 / \\ 2 7 / \\ 1 3 和 插入的值: 5 你可以返回这个二叉搜索树: 4 / \\ 2 7 / \\ / 1 3 5 或者这个树也是有效的: 5 / \\ 2 7 / \\ 1 3 \\ 4 1234567891011121314class Solution(object): def insertIntoBST(self, root, val): &quot;&quot;&quot; :type root: TreeNode :type val: int :rtype: TreeNode &quot;&quot;&quot; if root is None: return TreeNode(val) if root.val &gt; val: root.left = self.insertIntoBST(root.left, val) else: root.right = self.insertIntoBST(root.right, val) return root 814. 二叉树剪枝 [n]给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。 返回移除了所有不包含 1 的子树的原二叉树。 ( 节点 X 的子树为 X 本身，以及所有 X 的后代。) 示例1: 输入: [1,null,0,0,1] 输出: [1,null,0,null,1] 解释: 只有红色节点满足条件“所有不包含 1 的子树”。 右图为返回的答案。 示例2: 输入: [1,0,1,0,0,0,1] 输出: [1,null,1,null,1] 示例3: 输入: [1,1,0,1,1,0,1,0] 输出: [1,1,0,1,1,null,1] 说明: 给定的二叉树最多有 100 个节点。 每个节点的值只会为 0 或 1 。 12345678910111213class Solution(object): def pruneTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; if root is None: return None root.left = self.pruneTree(root.left) root.right = self.pruneTree(root.right) if root.left is None and root.right is None and root.val == 0: return None return root 863. 二叉树中所有距离为 K 的结点 [n]给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。 返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。 示例 1： 输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2 输出：[7,4,1] 解释： 所求结点为与目标结点（值为 5）距离为 2 的结点， 值分别为 7，4，以及 1 提示： 给定的树是非空的，且最多有 K 个结点。 树上的每个结点都具有唯一的值 0 &lt;= node.val &lt;= 500 。 目标结点 target 是树上的结点。 0 &lt;= K &lt;= 1000. 123456789101112131415161718192021222324252627282930313233class Solution(object): def distanceK(self, root, target, K): &quot;&quot;&quot; :type root: TreeNode :type target: TreeNode :type K: int :rtype: List[int] &quot;&quot;&quot; m = collections.defaultdict(list) self.helper(None, root, m) queue = [target.val] visited = set([target.val]) for _ in xrange(K): sz = len(queue) for _ in xrange(sz): v = queue.pop(0) for i in m[v]: if i not in visited: visited.add(i) queue.append(i) return queue def helper(self, parent, child, m): if parent and child: m[child.val].append(parent.val) m[parent.val].append(child.val) if child.left: self.helper(child, child.left, m) if child.right: self.helper(child, child.right, m) 865. 具有所有最深结点的最小子树 [n]给定一个根为 root 的二叉树，每个结点的深度是它到根的最短距离。 如果一个结点在整个树的任意结点之间具有最大的深度，则该结点是最深的。 一个结点的子树是该结点加上它的所有后代的集合。 返回能满足“以该结点为根的子树中包含所有最深的结点”这一条件的具有最大深度的结点。 示例： 输入：[3,5,1,6,2,0,8,null,null,7,4] 输出：[2,7,4] 解释： 我们返回值为 2 的结点，在图中用黄色标记。 在图中用蓝色标记的是树的最深的结点。 输入 \"[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]\" 是对给定的树的序列化表述。 输出 \"[2, 7, 4]\" 是对根结点的值为 2 的子树的序列化表述。 输入和输出都具有 TreeNode 类型。 提示： 树中结点的数量介于 1 和 500 之间。 每个结点的值都是独一无二的。 12345678910111213141516171819class Solution(object): def subtreeWithAllDeepest(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; depth, res = self.helper(root) return res def helper(self, root): if root is None: return (0, None) left_pair = self.helper(root.left) right_pair = self.helper(root.right) dl, dr = left_pair[0], right_pair[0] root_depth = max(dl, dr) + 1 if dl == dr: return (root_depth, root) return (root_depth, left_pair[1]) if dl &gt; dr else (root_depth, right_pair[1]) 894. 所有可能的满二叉树 [n]满二叉树是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。 返回包含 N 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。 答案中每个树的每个结点都必须有 node.val=0。 你可以按任何顺序返回树的最终列表。 示例： 输入：7 输出： [[0,0,0,null,null,0,0,null,null,0,0], [0,0,0,null,null,0,0,0,0], [0,0,0,0,0,0,0], [0,0,0,0,0,null,null,null,null,0,0], [0,0,0,0,0,null,null,0,0]] 123456789101112131415161718192021class Solution(object): def allPossibleFBT(self, N): &quot;&quot;&quot; :type N: int :rtype: List[TreeNode] &quot;&quot;&quot; if N % 2 == 0: return [] if N == 1: return [TreeNode(0)] res = [] for i in xrange(1, N, 2): lefts = self.allPossibleFBT(i) rights = self.allPossibleFBT(N - 1 - i) for left in lefts: for right in rights: root = TreeNode(0) root.left = left root.right = right res.append(root) return res 951. 翻转等价二叉树 [n]我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。 只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转等价于二叉树 Y。 编写一个判断两个二叉树是否是翻转等价的函数。这些树由根节点 root1 和 root2 给出。 示例： 输入：root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7] 输出：true 解释：We flipped at nodes with values 1, 3, and 5. 提示： 每棵树最多有 100 个节点。 每棵树中的每个值都是唯一的、在 [0, 99] 范围内的整数。 12345678910111213141516class Solution(object): def flipEquiv(self, root1, root2): &quot;&quot;&quot; :type root1: TreeNode :type root2: TreeNode :rtype: bool &quot;&quot;&quot; if root1 == root2: return True if root1 is None or root2 is None or root1.val != root2.val: return False a = self.flipEquiv(root1.left, root2.left) and \\ self.flipEquiv(root1.right, root2.right) b = self.flipEquiv(root1.left, root2.right) and \\ self.flipEquiv(root1.right, root2.left) return a or b 958. 二叉树的完全性检验给定一个二叉树，确定它是否是一个完全二叉树。 百度百科中对完全二叉树的定义如下： 若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。） 1234567891011121314151617181920class Solution(object): def isCompleteTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; if root is None: return True queue = [root] flag = False while queue: node = queue.pop(0) if node: if flag: return False queue.append(node.left) queue.append(node.right) else: flag = True return True 971. 翻转二叉树以匹配先序遍历 [n]给定一个有 N 个节点的二叉树，每个节点都有一个不同于其他节点且处于 {1, …, N} 中的值。 通过交换节点的左子节点和右子节点，可以翻转该二叉树中的节点。 考虑从根节点开始的先序遍历报告的 N 值序列。将这一 N 值序列称为树的行程。 （回想一下，节点的先序遍历意味着我们报告当前节点的值，然后先序遍历左子节点，再先序遍历右子节点。） 我们的目标是翻转最少的树中节点，以便树的行程与给定的行程 voyage 相匹配。 如果可以，则返回翻转的所有节点的值的列表。你可以按任何顺序返回答案。 如果不能，则返回列表 [-1]。 示例 1： 输入：root = [1,2], voyage = [2,1] 输出：[-1] 示例 2： 输入：root = [1,2,3], voyage = [1,3,2] 输出：[1] 示例 3： 输入：root = [1,2,3], voyage = [1,2,3] 输出：[] 提示： 1 &lt;= N &lt;= 100 12345678910111213141516171819202122232425class Solution(object): def flipMatchVoyage(self, root, voyage): &quot;&quot;&quot; :type root: TreeNode :type voyage: List[int] :rtype: List[int] &quot;&quot;&quot; self.pos, self.res = 0, [] self.dfs(root, voyage) print(self.res) return self.res def dfs(self, root, voyage): if root is None: return if root.val != voyage[self.pos]: self.res = [-1] return self.res if root.left and root.left.val != voyage[self.pos + 1]: root.left, root.right = root.right, root.left self.res.append(root.val) self.pos += 1 self.dfs(root.left, voyage) self.dfs(root.right, voyage) 979. 在二叉树中分配硬币 [n]给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。 在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。 返回使每个结点上只有一枚硬币所需的移动次数。 示例 1： 输入：[3,0,0] 输出：2 解释：从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。 示例 2： 输入：[0,3,0] 输出：3 解释：从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。 示例 3： 输入：[1,0,2] 输出：2 示例 4： 输入：[1,0,0,null,3] 输出：4 提示： 1&lt;= N &lt;= 100 0 &lt;= node.val &lt;= N 1234567891011121314151617class Solution(object): def distributeCoins(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; self.res = 0 self.helper(root) return self.res def helper(self, root): if root is None: return 0 left = self.helper(root.left) right = self.helper(root.right) self.res += abs(left) + abs(right) return root.val - 1 + left + right","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"那些我认为不错的计算机专业书(仅面向后台开发)","slug":"计算机专业图书推荐","date":"2020-12-04T13:40:04.000Z","updated":"2021-03-14T14:05:30.063Z","comments":false,"path":"posts/4f424561.html","link":"","permalink":"https://leel0330.github.io/posts/4f424561.html","excerpt":"如果你是程序员新人，那么这篇文章对你很有用，能让你少走一些弯路，多看一些经典书籍，打下扎实的计算机基础。 如果你是职场老鸟，那么这篇文章可能适合选读。有些书还是不错的，值得多读几遍。 友情提示：点击图书可以跳转到豆瓣，查看相应图书的目录内容和用户评价。","text":"如果你是程序员新人，那么这篇文章对你很有用，能让你少走一些弯路，多看一些经典书籍，打下扎实的计算机基础。 如果你是职场老鸟，那么这篇文章可能适合选读。有些书还是不错的，值得多读几遍。 友情提示：点击图书可以跳转到豆瓣，查看相应图书的目录内容和用户评价。 前言，那些我想对你说的话作为一名程序员，猿龄有四五年了。断断续续看了不少专业书，有些书还是让我成长了不少的，所以安耐不住内心的冲动，非常想分享一波，正好借本人的博客与大家交流一下☺️。 可以这么说，每个分类都是本人精心挑选过的，本人也有看过才会推荐。不过一千个读者眼里有一千个哈姆雷特，每个人的经历和认知差异比较大，很难满足每个人的口味。所以这里只是挑选出每个分类下个人认为不错的top3。 再次提示：点击图书可以跳转到豆瓣，查看相应图书的目录内容和用户评价哦~ 慢着，看XX语言之前你可能需要先看这里，嘿嘿我想你的脑子里肯定蹦出来一句话:”你给我推荐这么多语言的书看虾米，我看不过来啊!“。是的，你看不过来的，我也看不过来，但是我为了推荐的完整性，就都罗列出来了。 不瞒你说，你需要从上述基本语言挑出你自己喜欢的主力语言和辅助语言了，因为不同语言可以满足不同的需求，有它自身的一些特点。选择的话你可以考虑以下几点: 不会就选C。所以说它是必修课!(是的，你没看错就是C语言！你没得选，因为计算机软件专业课，第一门要学的语言就是它！这里强调一点，Linux操作系统就是C语言实现的哦！) 这门语言好学吗？我现在很想快点上手写一些代码呢？！(这条我推Python，只此一家，别无分店) 简单的我不想学，我想先学有难度的，因为难得东西好哈哈！(这条不说了，大家都明白，选C++吧，你会爱上它的o(￣︶￣)o) 我只想学一门语言，而且我想在这门语言深耕。(嗯不错，专一挺好的，那我推荐C++或者Java) 我已经会了C，也学了一门面向对象的语言(C++或者Java)，我想扩展一下，那可以学下Go看看。 时间是有限的，你不可能上来就什么都学，那样的话你什么都没有学会，还有可能因为学太多而走火入魔。早点做选择也没有坏处，需要做选择的时候就要果断点。当然你可以先大概了解一下每一门语言然后再深入学你喜欢的，这样也没问题的。 废话少说，快开始你的表演吧~，那我就开始咯，show time! C语言 C++语言因为C++很难，所以这里多推荐一些书，哈哈，可能这里就劝退了一波人啦，坚持下来的人加油哦！高精尖技术等着你开发呢😀~ Java语言老实说，Java要推荐的书也不少。 Python语言Python版本有2和3之分，2的话官方好像已经停止维护了，所以推荐直接学Python3吧。 Go语言 数据结构和算法 操作系统这几本操作系统书内容比较全面，对本科生来说深度也可以。需要重点关注的章节是进程、内存和IO。 计算机网络现在的应用程序可以说都离不开网络，无论什么客户端，都需要和server进行交互去拿相应的数据。因此掌握计算机网络相关知识就显得尤为重要。 对与《TCP/IP详解 卷1：协议》和《计算机网络》这两本书，需要重点关注的是运输层和应用层。也就是TCP/UDP和HTTP这几个协议。毕竟和程序员打交道最多的就是这两层了。希望同学能认真读完并掌握哦~ 对于《UNIX网络编程 卷1》。最需要掌握的是C/S编程范式(主要是tcp的socket编程，包括多进程、多线程和I/O复用)。 Linux编程 后记，既然看到这里了，再听我唠叨几句又何妨(手动狗头)如果你认真看完了上面所列的书籍，除了运气成分外，面大厂你的基础应该是很扎实了，但是有句话还是要讲一下就是”纸上得来终觉浅，绝知此事要躬行”，这句话对看这篇文章的人讲，也是对我自己讲。实践是1，看书是0，有了实践再看书相当于往1后面添加0，如果不实践看再多的书也是0。希望和大家一起共勉把！","categories":[{"name":"Book","slug":"Book","permalink":"https://leel0330.github.io/categories/Book/"}],"tags":[]},{"title":"LeetCode之二叉树(简单)","slug":"LeetCode-二叉树-简单","date":"2020-12-03T13:26:41.000Z","updated":"2020-12-27T05:05:55.775Z","comments":false,"path":"posts/94def828.html","link":"","permalink":"https://leel0330.github.io/posts/94def828.html","excerpt":"二叉树(简单)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"二叉树(简单)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 101. 对称二叉树给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 Python(BFS)Python(递归)1234567891011121314151617181920212223class Solution(object): def isSymmetric(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; if root is None: return True queue = [root, root] while queue: t1 = queue.pop(0) t2 = queue.pop(0) if t1 is None and t2 is None: continue if t1 is None or t2 is None: return False if t1.val != t2.val: return False queue.append(t1.left) queue.append(t2.right) queue.append(t1.right) queue.append(t2.left) return True123456789101112131415class Solution(object): def isSymmetric(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; return self.isMirror(root, root) def isMirror(self, p, q): if p is None and q is None: return True if p is None or q is None: return False return p.val == q.val and self.isMirror(p.left, q.right) \\ and self.isMirror(p.right, q.left) 110. 平衡二叉树给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 示例 1: 给定二叉树 [3,9,20,null,null,15,7] 3 / \\ 9 20 / \\ 15 7 返回 true 。 示例 2: 给定二叉树 [1,2,2,3,3,null,null,4,4] 1 / \\ 2 2 / \\ 3 3 / \\ 4 4 返回 false 。 1234567891011121314151617181920class Solution(object): def isBalanced(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; return self.helper(root) != -1 def helper(self, root): if root is None: return 0 left_height = self.helper(root.left) if left_height == -1: return -1 right_height = self.helper(root.right) if right_height == -1: return -1 if abs(left_height - right_height) &gt; 1: return -1 return 1 + max(left_height, right_height) 111. 二叉树的最小深度给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回它的最小深度 2. 123456789101112131415161718192021class Solution(object): def minDepth(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; if not root: return 0 queue = [root] level = 0 while queue: n = len(queue) level += 1 for i in xrange(n): node = queue.pop(0) if node.left is None and node.right is None: return level if node.left: queue.append(node.left) if node.right: queue.append(node.right) 226. 翻转二叉树翻转一棵二叉树。 示例： 输入： 4 / \\ 2 7 / \\ / \\ 1 3 6 9 输出： 4 / \\ 7 2 / \\ / \\ 9 6 3 1 1234567891011121314151617class Solution(object): def invertTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; if not root: return root queue = [root] while queue: node = queue.pop(0) node.left, node.right = node.right, node.left if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root 257. 二叉树的所有路径给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 输入: 1 / \\ 2 3 \\ 5 输出: [\"1->2->5\", \"1->3\"] 解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3 123456789101112131415161718192021class Solution(object): def binaryTreePaths(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[str] &quot;&quot;&quot; if not root: return [] item, res = [], [] self.dfs(root, item, res) return res def dfs(self, root, item, res): if root is None: return if root.left is None and root.right is None: tmp = item[:] + [str(root.val)] res.append(&#x27;-&gt;&#x27;.join(tmp)) return self.dfs(root.left, item + [str(root.val)], res) self.dfs(root.right, item + [str(root.val)], res) 501. 二叉搜索树中的众数 [n]给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。 假定 BST 有如下定义： 结点左子树中所含结点的值小于等于当前结点的值 结点右子树中所含结点的值大于等于当前结点的值 左子树和右子树都是二叉搜索树 例如： 给定 BST [1,null,2,2], 1 \\ 2 / 2 返回[2]. 提示：如果众数超过1个，不需考虑输出顺序 进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内） 123456789101112131415161718192021222324252627282930class Solution(object): def findMode(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[int] &quot;&quot;&quot; self.count = 0 self.max_count = 0 self.res = [] self.prev = None self.helper(root) return self.res def helper(self, root): if root is None: return self.helper(root.left) if self.prev is None: self.count = 1 elif self.prev.val == root.val: self.count += 1 else: self.count = 1 self.prev = root if self.count == self.max_count: self.res.append(self.prev.val) if self.count &gt; self.max_count: self.max_count = self.count self.res = [self.prev.val] self.helper(root.right) 543. 二叉树的直径给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。 示例 : 给定二叉树 1 / \\ 2 3 / \\ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。 注意：两结点之间的路径长度是以它们之间边的数目表示。 1234567891011121314151617class Solution(object): def diameterOfBinaryTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; self.ans = 1 self.helper(root) return self.ans - 1 def helper(self, root): if not root: return 0 left = self.helper(root.left) right = self.helper(root.right) self.ans = max(self.ans, left + right + 1) return max(left, right) + 1 563. 二叉树的坡度给定一个二叉树，计算整个树的坡度。 一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。 整个树的坡度就是其所有节点的坡度之和。 示例: 输入: 1 / \\ 2 3 输出: 1 解释: 结点的坡度 2 : 0 结点的坡度 3 : 0 结点的坡度 1 : |2-3| = 1 树的坡度 : 0 + 0 + 1 = 1 1234567891011121314151617class Solution(object): def findTilt(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; self.res = 0 self.helper(root) return self.res def helper(self, root): if root is None: return 0 L = self.helper(root.left) R = self.helper(root.right) self.res += abs(L - R) return L + R + root.val 572. 另一个树的子树给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。 示例 1: 给定的树 s: 3 / \\ 4 5 / \\ 1 2 给定的树 t： 4 / \\ 1 2 返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。 示例 2: 给定的树 s： 3 / \\ 4 5 / \\ 1 2 / 0 给定的树 t： 4 / \\ 1 2 返回 false。 123456789101112131415161718192021222324252627class Solution(object): def isSubtree(self, s, t): &quot;&quot;&quot; :type s: TreeNode :type t: TreeNode :rtype: bool &quot;&quot;&quot; queue = [s] while queue: node = queue.pop(0) if self.isSameTree(node, t): return True if node.left: queue.append(node.left) if node.right: queue.append(node.right) return False def isSameTree(self, s, t): if s is None and t is None: return True if s is None or t is None: return False if s.val != t.val: return False return self.isSameTree(s.left, t.left) \\ and self.isSameTree(s.right, t.right) 606. 根据二叉树创建字符串 [n]你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。 空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。 示例 1: 输入: 二叉树: [1,2,3,4] 1 / \\ 2 3 / 4 输出: \"1(2(4))(3)\" 解释: 原本将是“1(2(4)())(3())”， 在你省略所有不必要的空括号对之后， 它将是“1(2(4))(3)”。 示例 2: 输入: 二叉树: [1,2,3,null,4] 1 / \\ 2 3 \\ 4 输出: \"1(2()(4))(3)\" 解释: 和第一个示例相似， 除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。 12345678910111213class Solution(object): def tree2str(self, t): &quot;&quot;&quot; :type t: TreeNode :rtype: str &quot;&quot;&quot; if t is None: return &quot;&quot; if t.left is None and t.right is None: return str(t.val) left = &#x27;()&#x27; if t.left is None else &#x27;(&#x27; + self.tree2str(t.left) + &#x27;)&#x27; right = &#x27;&#x27; if t.right is None else &#x27;(&#x27; + self.tree2str(t.right) + &#x27;)&#x27; return str(t.val) + left + right 897. 递增顺序查找树给定一个树，按中序遍历重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。 示例 ： 输入：[5,3,6,2,4,null,8,1,null,null,null,7,9] 5 / \\ 3 6 / \\ \\ 2 4 8 / / \\ 1 7 9 输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 \\ 7 \\ 8 \\ 9 提示： 给定树中的结点数介于 1 和 100 之间。 每个结点都有一个从 0 到 1000 范围内的唯一整数值。 1234567891011121314151617181920212223242526class Solution(object): def increasingBST(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; res = self.inorder(root) if not res: return None for i in xrange(len(res) - 1): res[i].right = res[i + 1] return res[0] def inorder(self, root): res = [] p = root stk = [] while p or stk: while p: stk.append(p) p = p.left node = stk.pop(-1) node.left = None res.append(node) p = node.right return res 993. 二叉树的堂兄弟节点在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。 如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。 我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。 只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。 示例 1： 输入：root = [1,2,3,4], x = 4, y = 3 输出：false 示例 2： 输入：root = [1,2,3,null,4,null,5], x = 5, y = 4 输出：true 示例 3： 输入：root = [1,2,3,null,4], x = 2, y = 3 输出：false 提示： 二叉树的节点数介于 2 到 100 之间。 每个节点的值都是唯一的、范围为 1 到 100 的整数。 12345678910111213141516171819202122232425262728class Solution(object): def isCousins(self, root, x, y): &quot;&quot;&quot; :type root: TreeNode :type x: int :type y: int :rtype: bool &quot;&quot;&quot; if root is None: return False queue = [(root, None)] m = &#123;&#125; depth = 0 while queue: sz = len(queue) for i in xrange(sz): node, parent = queue.pop(0) m[node.val] = (parent, depth) if node.left: queue.append((node.left, node)) if node.right: queue.append((node.right, node)) depth += 1 px, dx = m[x] py, dy = m[y] return px != py and dx == dy","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode之链表","slug":"LeetCode-链表","date":"2020-11-29T04:27:42.000Z","updated":"2020-12-27T05:07:28.771Z","comments":false,"path":"posts/fb43e507.html","link":"","permalink":"https://leel0330.github.io/posts/fb43e507.html","excerpt":"链表的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"链表的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 24. 两两交换链表中的节点给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例: 给定 1->2->3->4, 你应该返回 2->1->4->3. 12345678910111213141516171819202122class Solution(object): def swapPairs(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if head is None or head.next is None: return head dummy = ListNode(-1) dummy.next = head r = dummy p, q = head, head.next while p and q: r.next = q p.next = q.next q.next = p r = p p = r.next q = p.next if p else None r = dummy.next dummy.next = None return r 82. 删除排序链表中的重复元素 II给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1: 输入: 1->2->3->3->4->4->5 输出: 1->2->5 示例 2: 输入: 1->1->1->2->3 输出: 2->3 123456789101112131415161718192021222324252627class Solution(object): def deleteDuplicates(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if head is None or head.next is None: return head dummy = ListNode(-1) dummy.next = head p, cur = dummy, head while cur: cnt = 1 v = cur.val while cur.next and cur.next.val == v: cur = cur.next cnt += 1 if cnt == 1: p.next = cur cur = cur.next p = p.next else: p.next = cur.next cur = cur.next p = dummy.next dummy.next = None return p 92. 反转链表 II反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明: 1 ≤ m ≤ n ≤ 链表长度。 示例: 输入: 1->2->3->4->5->NULL, m = 2, n = 4 输出: 1->4->3->2->5->NULL 1234567891011121314151617181920212223242526class Solution &#123; public ListNode reverseBetween(ListNode head, int m, int n) &#123; ListNode dummy = new ListNode(-1); dummy.next = head; ListNode prev = dummy, cur = head; int step = 0; while (step &lt; m - 1) &#123; prev = prev.next; cur = cur.next; step += 1; &#125; for (int i = 0; i &lt; n - m; i++) &#123; ListNode removed = cur.next; cur.next = cur.next.next; removed.next = prev.next; prev.next = removed; &#125; ListNode newHead = dummy.next; dummy.next = null; return newHead; &#125;&#125; 109. 有序链表转换二叉搜索树给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 PythonJava12345678910111213141516171819class Solution(object): def sortedListToBST(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: TreeNode &quot;&quot;&quot; return self.buildTree(head, None) def buildTree(self, head, tail): if head == tail: return None fast = slow = head while fast != tail and fast.next != tail: fast = fast.next.next slow = slow.next root = TreeNode(slow.val) root.left = self.buildTree(head, slow) root.right = self.buildTree(slow.next, tail) return root1234567891011121314151617181920class Solution &#123; public TreeNode sortedListToBST(ListNode head) &#123; return buildTree(head, null); &#125; public TreeNode buildTree(ListNode head, ListNode tail) &#123; if (head == tail) &#123; return null; &#125; ListNode fast = head, slow = head; while (fast != tail &amp;&amp; fast.next != tail) &#123; fast = fast.next.next; slow = slow.next; &#125; TreeNode root = new TreeNode(slow.val); root.left = buildTree(head, slow); root.right = buildTree(slow.next, tail); return root; &#125;&#125; 142. 环形链表 II给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 12345678910111213141516171819class Solution(object): def detectCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; fast, slow = head, head while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: break if fast is None or fast.next is None: return None fast = head while slow != fast: slow = slow.next fast = fast.next return slow 143. 重排链表给定一个单链表 L：L0→L1→…→Ln-1→Ln ，将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1: 给定链表 1->2->3->4, 重新排列为 1->4->2->3. 示例 2: 给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3. 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution(object): def reorderList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: None Do not return anything, modify head in-place instead. &quot;&quot;&quot; if head is None or head.next is None: return prev = None fast, slow = head, head while fast and fast.next: prev = slow slow = slow.next fast = fast.next.next prev.next = None slow = self.reverseList(slow) dummy = ListNode(-1) p = dummy while slow and head: ts, th = slow.next, head.next p.next = head p.next.next = slow slow = ts head = th p = p.next.next p.next = slow if slow else head p = dummy.next dummy.next = None def reverseList(self, head): if head is None or head.next is None: return head p, q = None, head while q: r = q.next q.next = p p = q q = r return p 147. 对链表进行插入排序 [n]12345678910111213141516171819202122class Solution(object): def insertionSortList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if head is None or head.next is None: return head dummy = ListNode(0) dummy.next = head while head.next: if head.val &lt;= head.next.val: head = head.next else: tmp = head.next head.next = tmp.next q = dummy while q.next and q.next.val &lt;= tmp.val: q = q.next tmp.next = q.next q.next = tmp return dummy.next 148. 排序链表merge sort 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def sortList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if head is None or head.next is None: return head prev, fast, slow = None, head, head while fast and fast.next: prev = slow fast = fast.next.next slow = slow.next prev.next = None head = self.sortList(head) slow = self.sortList(slow) return self.merge(head, slow) def merge(self, l1, l2): dummy = ListNode(-1) p = dummy while l1 and l2: if l1.val &lt; l2.val: p.next = l1 l1 = l1.next else: p.next = l2 l2 = l2.next p = p.next p.next = l1 if l1 else l2 p = dummy.next dummy.next = None return p 234. 回文链表请判断一个链表是否为回文链表。 示例 1: 输入: 1->2 输出: false 示例 2: 输入: 1->2->2->1 输出: true 12345678910111213141516171819202122232425262728293031323334class Solution(object): def isPalindrome(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; if head is None or head.next is None: return True mid = self.get_mid_node(head) mid = self.reverse_list(mid) while mid: if mid.val != head.val: return False mid = mid.next head = head.next return True def get_mid_node(self, head): slow, fast = head, head while fast and fast.next: fast = fast.next.next slow = slow.next return slow def reverse_list(self, head): if head is None or head.next is None: return head p, q = None, head while q: r = q.next q.next = p p = q q = r return p 328. 奇偶链表给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。 示例 1: 输入: 1->2->3->4->5->NULL 输出: 1->3->5->2->4->NULL 示例 2: 输入: 2->1->3->5->6->4->7->NULL 输出: 2->3->6->7->1->5->4->NULL 说明: 应当保持奇数节点和偶数节点的相对顺序。 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。 123456789101112131415161718192021222324class Solution(object): def oddEvenList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if head is None or head.next is None: return head new_head_p, new_head_q = head, head.next p, q = head, head.next prev = None while p: next_p = q.next if q else None next_q = next_p.next if next_p else None p.next = next_p if q: q.next = next_q prev = p p = next_p q = next_q prev.next = new_head_q return new_head_p 430. 扁平化多级双向链表 [n]您将获得一个双向链表，除了下一个和前一个指针之外，它还有一个子指针，可能指向单独的双向链表。这些子列表可能有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。 扁平化列表，使所有结点出现在单级双链表中。您将获得列表第一级的头部。 示例: 输入: 1---2---3---4---5---6--NULL | 7---8---9---10--NULL | 11--12--NULL 输出: 1-2-3-7-8-11-12-9-10-4-5-6-NULL 123456789101112131415161718192021222324class Solution(object): def flatten(self, head): &quot;&quot;&quot; :type head: Node :rtype: Node &quot;&quot;&quot; self.dfs(head) return head def dfs(self, head): cur = head while cur: if cur.child: next = cur.next cur.next = cur.child cur.next.prev = cur child_last = self.dfs(cur.child) child_last.next = next if next: next.prev = child_last cur.child = None head = cur cur = cur.next return head 1019. 链表中的下一个更大节点给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, … 。 每个节点都可能有下一个更大值（next larger value）：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j &gt; i 且 node_j.val &gt; node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。 返回整数答案数组 answer，其中 answer[i] = next_larger(node_{i+1}) 。 注意：在下面的示例中，诸如 [2,1,5] 这样的输入（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。 示例 1： 输入：[2,1,5] 输出：[5,5,0] 示例 2： 输入：[2,7,4,3,5] 输出：[7,0,5,5,0] 示例 3： 输入：[1,7,5,1,9,2,5,1] 输出：[7,9,9,9,0,5,0,0] 提示： 对于链表中的每个节点，1 &lt;= node.val &lt;= 10^9 给定列表的长度在 [0, 10000] 范围内 1234567891011121314151617class Solution(object): def nextLargerNodes(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: List[int] &quot;&quot;&quot; nums = [] while head: nums.append(head.val) head = head.next res = [0] * len(nums) stk = [] for i, v in enumerate(nums): while stk and nums[stk[-1]] &lt; v: res[stk.pop()] = v stk.append(i) return res 1171. 从链表中删去总和值为零的连续节点 [n]给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。 删除完毕后，请你返回最终结果链表的头节点。 你可以返回任何满足题目要求的答案。 （注意，下面示例中的所有序列，都是对 ListNode 对象序列化的表示。） 示例 1： 输入：head = [1,2,-3,3,1] 输出：[3,1] 提示：答案 [1,2,1] 也是正确的。 示例 2： 输入：head = [1,2,3,-3,4] 输出：[1,2,4] 示例 3： 输入：head = [1,2,3,-3,-2] 输出：[1] 提示： 给你的链表中可能有 1 到 1000 个节点。 对于链表中的每个节点，节点的值：-1000 &lt;= node.val &lt;= 1000. 12345678910111213141516171819202122232425262728class Solution(object): def removeZeroSumSublists(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; m = &#123;&#125; dummy = ListNode(0) dummy.next = head p = dummy total = 0 while p: total += p.val m[total] = p p = p.next total = 0 p = dummy while p: total += p.val p.next = m[total].next p = p.next p = dummy.next dummy.next = None return p","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode之栈和队列","slug":"LeetCode-栈和队列","date":"2020-11-28T03:50:05.000Z","updated":"2020-12-27T05:07:12.635Z","comments":false,"path":"posts/1ccb8d85.html","link":"","permalink":"https://leel0330.github.io/posts/1ccb8d85.html","excerpt":"栈与队列的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"栈与队列的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 394. 字符串解码给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例: s = \"3[a]2[bc]\", 返回 \"aaabcbc\". s = \"3[a2[c]]\", 返回 \"accaccacc\". s = \"2[abc]3[cd]ef\", 返回 \"abcabccdcdcdef\". PythonJava12345678910111213141516171819class Solution(object): def decodeString(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; stack, res, multi = [], &quot;&quot;, 0 for c in s: if c == &#x27;[&#x27;: stack.append([multi, res]) res, multi = &quot;&quot;, 0 elif c == &#x27;]&#x27;: cur_multi, last_res = stack.pop() res = last_res + cur_multi * res elif &#x27;0&#x27; &lt;= c &lt;= &#x27;9&#x27;: multi = multi * 10 + int(c) else: res += c return res12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; class Item &#123; public int num; public String str; public Item(int n, String s) &#123; this.num = n; this.str = s; &#125; &#125; public String decodeString(String s) &#123; String res = &quot;&quot;; int multi = 0; Stack&lt;Item&gt; stk = new Stack&lt;&gt;(); for(int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if(c == &#x27;[&#x27;) &#123; stk.add(new Item(multi, res)); res = &quot;&quot;; multi = 0; &#125;else if(c == &#x27;]&#x27;) &#123; Item item = stk.pop(); StringBuilder sb = new StringBuilder(); for(int k = 0; k &lt; item.num; k++) &#123; sb.append(res); &#125; res = item.str + sb.toString(); &#125;else if(c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; multi = multi * 10 + Integer.parseInt(c + &quot;&quot;); &#125;else&#123; res += c; &#125; &#125; return res; &#125;&#125; 402. 移掉K位数字给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。 注意: num 的长度小于 10002 且 ≥ k。 num 不会包含任何前导零。 示例 1 : 输入: num = \"1432219\", k = 3 输出: \"1219\" 解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。 示例 2 : 输入: num = \"10200\", k = 1 输出: \"200\" 解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。 示例 3 : 输入: num = \"10\", k = 2 输出: \"0\" 解释: 从原数字移除所有的数字，剩余为空就是0。 PythonJava12345678910111213141516171819class Solution(object): def removeKdigits(self, num, k): &quot;&quot;&quot; :type num: str :type k: int :rtype: str &quot;&quot;&quot; stk = [] for c in num: while k and stk and stk[-1] &gt; c: stk.pop(-1) k -= 1 stk.append(c) while k: stk.pop(-1) k -= 1 if not stk: return &#x27;0&#x27; return str(int(&#x27;&#x27;.join(stk)))12345678910111213141516171819202122232425262728class Solution &#123; public String removeKdigits(String num, int k) &#123; Stack&lt;Character&gt; stk = new Stack&lt;&gt;(); for (int i = 0; i &lt; num.length(); i++) &#123; char c = num.charAt(i); while (k &gt; 0 &amp;&amp; !stk.empty() &amp;&amp; stk.peek() &gt; c) &#123; stk.pop(); k -= 1; &#125; stk.add(c); &#125; while (k &gt; 0) &#123; stk.pop(); k -= 1; &#125; while (!stk.empty() &amp;&amp; stk.get(0) == &#x27;0&#x27;) &#123; stk.remove(0); &#125; if (stk.empty()) &#123; return &quot;0&quot;; &#125; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; stk.size(); i++) &#123; sb.append(stk.get(i)); &#125; return sb.toString(); &#125;&#125; 456. 132模式给定一个整数序列：a1, a2, …, an，一个132模式的子序列 ai, aj, ak 被定义为：当 i &lt; j &lt; k 时，ai &lt; ak &lt; aj。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。 注意：n 的值小于15000。 示例1: 输入: [1, 2, 3, 4] 输出: False 解释: 序列中不存在132模式的子序列。 示例 2: 输入: [3, 1, 4, 2] 输出: True 解释: 序列中有 1 个132模式的子序列： [1, 4, 2]. 示例 3: 输入: [-1, 3, 2, 0] 输出: True 解释: 序列中有 3 个132模式的的子序列: [-1, 3, 2], [-1, 3, 0] 和 [-1, 2, 0]. PythonJava12345678910111213141516class Solution(object): def find132pattern(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; stk = [] INT_MIN = -(1 &lt;&lt; 31) third = INT_MIN for idx in xrange(len(nums) - 1, -1, -1): if nums[idx] &lt; third: return True while stk and stk[-1] &lt; nums[idx]: third = stk.pop(-1) stk.append(nums[idx]) return False1234567891011121314151617class Solution &#123; public boolean find132pattern(int[] nums) &#123; int INT_MIN = -(1 &lt;&lt; 31); int third = INT_MIN; Stack&lt;Integer&gt; stk = new Stack&lt;&gt;(); for (int i = nums.length - 1; i &gt;= 0; i--) &#123; if (nums[i] &lt; third) &#123; return true; &#125; while (!stk.empty() &amp;&amp; stk.peek() &lt; nums[i]) &#123; third = stk.pop(); &#125; stk.add(nums[i]); &#125; return false; &#125;&#125; 496. 下一个更大元素 I给定两个没有重复元素的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。 nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。 示例 1: 输入: nums1 = [4,1,2], nums2 = [1,3,4,2]. 输出: [-1,3,-1] 解释: 对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。 对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。 对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。 示例 2: 输入: nums1 = [2,4], nums2 = [1,2,3,4]. 输出: [3,-1] 解释: 对于num1中的数字2，第二个数组中的下一个较大数字是3。 对于num1中的数字4，第二个数组中没有下一个更大的数字，因此输出 -1。 注意: nums1和nums2中所有元素是唯一的。 nums1和nums2 的数组大小都不超过1000。 123456789101112131415161718192021class Solution(object): def nextGreaterElement(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: List[int] &quot;&quot;&quot; m = &#123;&#125; stk = [] res = [-1 for _ in xrange(len(nums1))] for n in nums2: while len(stk) &gt; 0 and stk[-1] &lt; n: m[stk[-1]] = n stk.pop(-1) stk.append(n) for idx, n in enumerate(nums1): if n in m: res[idx] = m[n] else: res[idx] = -1 return res 503. 下一个更大元素 II [n]给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。 示例 1: 输入: [1,2,1] 输出: [2,-1,2] 解释: 第一个 1 的下一个更大的数是 2； 数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。 注意: 输入数组的长度不会超过 10000。 123456789101112131415161718class Solution(object): def nextGreaterElements(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[int] &quot;&quot;&quot; n = len(nums) res = [-1 for _ in xrange(n)] stk = [] for idx in xrange(n * 2 - 1, -1, -1): while stk and stk[-1] &lt;= nums[idx % n]: stk.pop(-1) if len(stk) == 0: res[idx % n] = -1 else: res[idx % n] = stk[-1] stk.append(nums[idx % n]) return res 622. 设计循环队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class MyCircularQueue(object): def __init__(self, k): &quot;&quot;&quot; Initialize your data structure here. Set the size of the queue to be k. :type k: int &quot;&quot;&quot; self.queue = [None] * k self.size = k self.real_cnt = 0 self.head = 0 self.tail = 0 # 有效元素尾部的下一个位置 def enQueue(self, value): &quot;&quot;&quot; Insert an element into the circular queue. Return true if the operation is successful. :type value: int :rtype: bool &quot;&quot;&quot; if self.isFull(): return False self.queue[self.tail] = value self.tail = (self.tail + 1) % self.size self.real_cnt += 1 return True def deQueue(self): &quot;&quot;&quot; Delete an element from the circular queue. Return true if the operation is successful. :rtype: bool &quot;&quot;&quot; if self.isEmpty(): return False self.head = (self.head + 1) % self.size self.real_cnt -= 1 return True def Front(self): &quot;&quot;&quot; Get the front item from the queue. :rtype: int &quot;&quot;&quot; if self.isEmpty(): return -1 return self.queue[self.head] def Rear(self): &quot;&quot;&quot; Get the last item from the queue. :rtype: int &quot;&quot;&quot; if self.isEmpty(): return -1 if self.tail == 0: return self.queue[self.size - 1] return self.queue[self.tail - 1] def isEmpty(self): &quot;&quot;&quot; Checks whether the circular queue is empty or not. :rtype: bool &quot;&quot;&quot; return self.real_cnt == 0 def isFull(self): &quot;&quot;&quot; Checks whether the circular queue is full or not. :rtype: bool &quot;&quot;&quot; return self.real_cnt == self.size 641. 设计循环双端队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109class MyCircularDeque(object): def __init__(self, k): &quot;&quot;&quot; Initialize your data structure here. Set the size of the deque to be k. :type k: int &quot;&quot;&quot; self.deque = [None] * k self.size = k self.real_cnt = 0 self.head = 0 self.tail = 0 # 有效元素尾部的下一个位置 def insertFront(self, value): &quot;&quot;&quot; Adds an item at the front of Deque. Return true if the operation is successful. :type value: int :rtype: bool &quot;&quot;&quot; if self.isFull(): return False if self.head == 0: self.head = self.size - 1 else: self.head = self.head - 1 self.deque[self.head] = value self.real_cnt += 1 return True def insertLast(self, value): &quot;&quot;&quot; Adds an item at the rear of Deque. Return true if the operation is successful. :type value: int :rtype: bool &quot;&quot;&quot; if self.isFull(): return False self.deque[self.tail] = value self.tail = (self.tail + 1) % self.size self.real_cnt += 1 return True def deleteFront(self): &quot;&quot;&quot; Deletes an item from the front of Deque. Return true if the operation is successful. :rtype: bool &quot;&quot;&quot; if self.isEmpty(): return False self.head = (self.head + 1) % self.size self.real_cnt -= 1 return True def deleteLast(self): &quot;&quot;&quot; Deletes an item from the rear of Deque. Return true if the operation is successful. :rtype: bool &quot;&quot;&quot; if self.isEmpty(): return False if self.tail == 0: self.tail = self.size - 1 else: self.tail = self.tail - 1 self.real_cnt -= 1 return True def getFront(self): &quot;&quot;&quot; Get the front item from the deque. :rtype: int &quot;&quot;&quot; if self.isEmpty(): return -1 return self.deque[self.head] def getRear(self): &quot;&quot;&quot; Get the last item from the deque. :rtype: int &quot;&quot;&quot; if self.isEmpty(): return -1 if self.tail == 0: return self.deque[self.size - 1] else: return self.deque[self.tail - 1] def isEmpty(self): &quot;&quot;&quot; Checks whether the circular deque is empty or not. :rtype: bool &quot;&quot;&quot; return self.real_cnt == 0 def isFull(self): &quot;&quot;&quot; Checks whether the circular deque is full or not. :rtype: bool &quot;&quot;&quot; return self.real_cnt == self.size 739. 每日温度 [n]根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 1234567891011121314class Solution(object): def dailyTemperatures(self, T): &quot;&quot;&quot; :type T: List[int] :rtype: List[int] &quot;&quot;&quot; res = [0 for _ in xrange(len(T))] stk = [] for i in xrange(len(T) - 1, -1, -1): while stk and T[stk[-1]] &lt;= T[i]: stk.pop(-1) res[i] = 0 if not stk else stk[-1] - i stk.append(i) return res 856. 括号的分数给定一个平衡括号字符串 S，按下述规则计算该字符串的分数： () 得 1 分。AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。(A) 得 2 * A 分，其中 A 是平衡括号字符串。 示例 1： 输入： \"()\" 输出： 1 示例 2： 输入： \"(())\" 输出： 2 示例 3： 输入： \"()()\" 输出： 2 示例 4： 输入： \"(()(()))\" 输出： 6 提示： S 是平衡括号字符串，且只含有 ( 和 ) 。 2 &lt;= S.length &lt;= 50 123456789101112131415161718192021class Solution(object): def scoreOfParentheses(self, S): &quot;&quot;&quot; :type S: str :rtype: int &quot;&quot;&quot; stk = [] for c in S: if c == &#x27;(&#x27;: stk.append(-1) else: cnt = 0 while stk[-1] != -1: cnt += stk[-1] stk.pop(-1) stk.pop(-1) if cnt == 0: stk.append(1) else: stk.append(2 * cnt) return sum(stk) 880. 索引处的解码字符串 [n]给定一个编码字符串 S。为了找出解码字符串并将其写入磁带，从编码字符串中每次读取一个字符，并采取以下步骤： 如果所读的字符是字母，则将该字母写在磁带上。如果所读的字符是数字（例如 d），则整个当前磁带总共会被重复写 d-1 次。现在，对于给定的编码字符串 S 和索引 K，查找并返回解码字符串中的第 K 个字母。 示例 1： 输入：S = \"leet2code3\", K = 10 输出：\"o\" 解释： 解码后的字符串为 \"leetleetcodeleetleetcodeleetleetcode\"。 字符串中的第 10 个字母是 \"o\"。 示例 2： 输入：S = \"ha22\", K = 5 输出：\"h\" 解释： 解码后的字符串为 \"hahahaha\"。第 5 个字母是 \"h\"。 示例 3： 输入：S = \"a2345678999999999999999\", K = 1 输出：\"a\" 解释： 解码后的字符串为 \"a\" 重复 8301530446056247680 次。第 1 个字母是 \"a\"。 提示： 2 &lt;= S.length &lt;= 100 S 只包含小写字母与数字 2 到 9 。 S 以字母开头。 1 &lt;= K &lt;= 10^9 解码后的字符串保证少于 2^63 个字母。 12345678910111213141516171819202122class Solution(object): def decodeAtIndex(self, S, K): &quot;&quot;&quot; :type S: str :type K: int :rtype: str &quot;&quot;&quot; sz = 0 for c in S: if c.isdigit(): sz *= int(c) else: sz += 1 for c in S[::-1]: K %= sz if K == 0 and c.isalpha(): return c if c.isdigit(): sz /= int(c) else: sz -= 1 907. 子数组的最小值之和 [n]给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。 由于答案可能很大，因此返回答案模 10^9 + 7。 示例： 输入：[3,1,2,4] 输出：17 解释： 子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。 提示： 1 &lt;= A &lt;= 30000 1 &lt;= A[i] &lt;= 30000 12345678910111213141516171819202122232425262728class Solution(object): def sumSubarrayMins(self, A): MOD = 10**9 + 7 N = len(A) # prev has i* - 1 in increasing order of A[i* - 1] # where i* is the answer to query j stack = [] prev = [None] * N for i in xrange(N): while stack and A[i] &lt;= A[stack[-1]]: stack.pop() prev[i] = stack[-1] if stack else -1 stack.append(i) # next has k* + 1 in increasing order of A[k* + 1] # where k* is the answer to query j stack = [] next_ = [None] * N for k in xrange(N-1, -1, -1): while stack and A[k] &lt; A[stack[-1]]: stack.pop() next_[k] = stack[-1] if stack else N stack.append(k) # Use prev/next array to count answer return sum((i - prev[i]) * (next_[i] - i) * A[i] for i in xrange(N)) % MOD 946. 验证栈序列给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。 示例 1： 输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1] 输出：true 解释：我们可以按以下顺序执行： push(1), push(2), push(3), push(4), pop() -> 4, push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1 示例 2： 输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2] 输出：false 解释：1 不能在 2 之前弹出。 提示： 0 &lt;= pushed.length == popped.length &lt;= 1000 0 &lt;= pushed[i], popped[i] &lt; 1000 pushed 是 popped 的排列。 1234567891011121314151617181920class Solution(object): def validateStackSequences(self, pushed, popped): &quot;&quot;&quot; :type pushed: List[int] :type popped: List[int] :rtype: bool &quot;&quot;&quot; stk = [] i, j = 0, 0 n = len(pushed) m = len(popped) if m != n : return False while i &lt; n: stk.append(pushed[i]) while stk and stk[-1] == popped[j]: j += 1 stk.pop(-1) i += 1 return len(stk) == 0 and j == n 1019. 链表中的下一个更大节点 [n]给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, … 。 每个节点都可能有下一个更大值（next larger value）：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j &gt; i 且 node_j.val &gt; node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。 返回整数答案数组 answer，其中 answer[i] = next_larger(node_{i+1}) 。 注意：在下面的示例中，诸如 [2,1,5] 这样的输入（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。 示例 1： 输入：[2,1,5] 输出：[5,5,0] 示例 2： 输入：[2,7,4,3,5] 输出：[7,0,5,5,0] 示例 3： 输入：[1,7,5,1,9,2,5,1] 输出：[7,9,9,9,0,5,0,0] 提示： 对于链表中的每个节点，1 &lt;= node.val &lt;= 10^9 给定列表的长度在 [0, 10000] 范围内 1234567891011121314151617class Solution(object): def nextLargerNodes(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: List[int] &quot;&quot;&quot; nums = [] while head: nums.append(head.val) head = head.next res = [0] * len(nums) stk = [] for i, v in enumerate(nums): while stk and nums[stk[-1]] &lt; v: res[stk.pop()] = v stk.append(i) return res 1209. 删除字符串中的所有相邻重复项 II给你一个字符串 s，「k 倍重复项删除操作」将会从 s 中选择 k 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。 你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。 在执行完所有删除操作后，返回最终得到的字符串。 本题答案保证唯一。 示例 1： 输入：s = \"abcd\", k = 2 输出：\"abcd\" 解释：没有要删除的内容。 示例 2： 输入：s = \"deeedbbcccbdaa\", k = 3 输出：\"aa\" 解释： 先删除 \"eee\" 和 \"ccc\"，得到 \"ddbbbdaa\" 再删除 \"bbb\"，得到 \"dddaa\" 最后删除 \"ddd\"，得到 \"aa\" 示例 3： 输入：s = \"pbbcggttciiippooaais\", k = 2 输出：\"ps\" 提示： 1 &lt;= s.length &lt;= 10^5 2 &lt;= k &lt;= 10^4 s 中只含有小写英文字母。 12345678910111213141516171819class Solution(object): def removeDuplicates(self, s, k): &quot;&quot;&quot; :type s: str :type k: int :rtype: str &quot;&quot;&quot; stk = [] for c in s: if stk and stk[-1][0] == c: stk[-1][1] += 1 if stk[-1][1] == k: stk.pop(-1) else: stk.append([c, 1]) res = &#x27;&#x27; for v, i in stk: res += i * v return res 1249. 移除无效的括号 [n]给你一个由 ‘(‘、’)’ 和小写字母组成的字符串 s。 你需要从字符串中删除最少数目的 ‘(‘ 或者 ‘)’ （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。 请返回任意一个合法字符串。 有效「括号字符串」应当符合以下 任意一条 要求： 空字符串或只包含小写字母的字符串 可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」 可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」 示例 1： 输入：s = \"lee(t(c)o)de)\" 输出：\"lee(t(c)o)de\" 解释：\"lee(t(co)de)\" , \"lee(t(c)ode)\" 也是一个可行答案。 示例 2： 输入：s = \"a)b(c)d\" 输出：\"ab(c)d\" 示例 3： 输入：s = \"))((\" 输出：\"\" 解释：空字符串也是有效的 示例 4： 输入：s = \"(a(b(c)d)\" 输出：\"a(b(c)d)\" 提示： 1 &lt;= s.length &lt;= 10^5 s[i] 可能是 ‘(‘、’)’ 或英文小写字母 12345678910111213141516171819202122class Solution(object): def minRemoveToMakeValid(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; stk = [] for i, v in enumerate(s): if v == &#x27;(&#x27;: stk.append((i, v)) elif v == &#x27;)&#x27;: if stk and stk[-1][1] == &#x27;(&#x27;: stk.pop(-1) else: stk.append((i, v)) res, j = &quot;&quot;, 0 for i, v in enumerate(s): if j &lt; len(stk) and i == stk[j][0]: j += 1 else: res += v return res","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode之哈希表","slug":"LeetCode-哈希表","date":"2020-11-27T14:05:54.000Z","updated":"2020-12-27T05:06:16.073Z","comments":false,"path":"posts/2d8b42bd.html","link":"","permalink":"https://leel0330.github.io/posts/2d8b42bd.html","excerpt":"哈希表的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"哈希表的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 202. 快乐数编写一个算法来判断一个数是不是“快乐数”。 一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 示例: 输入: 19 输出: true 解释: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 1234567891011121314class Solution(object): def isHappy(self, n): &quot;&quot;&quot; :type n: int :rtype: bool &quot;&quot;&quot; m = &#123;&#125; while True: n = str(sum([int(i) ** 2 for i in str(n)])) if n == &#x27;1&#x27;: return True if n in m: return False m[n] = True 290. 单词规律给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。 这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。 示例1: 输入: pattern = \"abba\", str = \"dog cat cat dog\" 输出: true 示例 2: 输入:pattern = \"abba\", str = \"dog cat cat fish\" 输出: false 示例 3: 输入: pattern = \"aaaa\", str = \"dog cat cat dog\" 输出: false 123456789101112131415161718class Solution(object): def wordPattern(self, pattern, str): &quot;&quot;&quot; :type pattern: str :type str: str :rtype: bool &quot;&quot;&quot; return self.helper(pattern) == self.helper(str.split(&#x27; &#x27;)) def helper(self, s_list): m = &#123;&#125; res = [] for s in s_list: if s not in m: m[s] = len(m) + 1 res.append(m[s]) ss = &#x27;&#x27;.join([str(i) for i in res]) return ss 409. 最长回文串给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。 在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。 注意:假设字符串的长度不会超过 1010。 示例 1: 输入: \"abccccdd\" 输出: 7 解释: 我们可以构造的最长的回文串是\"dccaccd\", 它的长度是 7。 1234567891011121314151617181920212223class Solution(object): def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; m = &#123;&#125; for c in s: if c in m: m[c] += 1 else: m[c] = 1 max_odd = 0 res = 0 has_odd = False for k, v in m.iteritems(): if v % 2 == 0: res += v else: res += v - 1 if not has_odd: has_odd = True return res + 1 if has_odd else res 438. 找到字符串中所有字母异位词给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。 字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。 说明： 字母异位词指字母相同，但排列不同的字符串。 不考虑答案输出的顺序。 示例 1: 输入: s: \"cbaebabacd\" p: \"abc\" 输出: [0, 6] 解释: 起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的字母异位词。 起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的字母异位词。 示例 2: 输入: s: \"abab\" p: \"ab\" 输出: [0, 1, 2] 解释: 起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的字母异位词。 起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的字母异位词。 起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的字母异位词。 PythonJava123456789101112131415161718192021222324252627282930313233class Solution(object): def findAnagrams(self, s, p): &quot;&quot;&quot; :type s: str :type p: str :rtype: List[int] &quot;&quot;&quot; ls, lp = len(s), len(p) cp = self.get_counter(p) cs = &#123;&#125; ans = [] for i in range(ls): if s[i] in cs: cs[s[i]] += 1 else: cs[s[i]] = 1 if i &gt;= lp: cs[s[i - lp]] -= 1 # start前一个元素 if cs[s[i - lp]] == 0: del cs[s[i - lp]] if cs == cp: # 因为end - start + 1 = len; 所以 start = end + 1 - len ans.append(i - lp + 1) return ans def get_counter(self, s): m = &#123;&#125; for c in s: if c in m: m[c] += 1 else: m[c] = 1 return m12345678910111213141516171819202122232425262728293031323334class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(s.isEmpty() || p.length() &gt; s.length()) &#123; return res; &#125; int[] hashS = new int[256]; int[] hashP = new int[256]; for (int i = 0; i &lt; p.length(); i++) &#123; hashP[p.charAt(i)]++; hashS[s.charAt(i)]++; &#125; if (isSameDict(hashS, hashP)) &#123; res.add(0); &#125; for (int i = p.length(); i &lt; s.length(); i++) &#123; hashS[s.charAt(i - p.length())]--; hashS[s.charAt(i)]++; if (isSameDict(hashS, hashP)) &#123; res.add(i + 1 - p.length()); &#125; &#125; return res; &#125; private boolean isSameDict(int[] hashS, int[] hashP) &#123; for (int i = 0; i &lt; hashS.length; i++) &#123; if (hashP[i] != hashS[i]) &#123; return false; &#125; &#125; return true; &#125;&#125; 454. 四数相加 II[n]给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。 为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。 例如: 输入: A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2] 输出: 2 解释: 两个元组如下: 1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 PythonJava123456789101112131415161718192021222324class Solution(object): def fourSumCount(self, A, B, C, D): &quot;&quot;&quot; :type A: List[int] :type B: List[int] :type C: List[int] :type D: List[int] :rtype: int &quot;&quot;&quot; m = &#123;&#125; for i in xrange(len(A)): for j in xrange(len(B)): tmp = A[i] + B[j] if tmp in m: m[tmp] += 1 else: m[tmp] = 1 res = 0 for i in xrange(len(C)): for j in xrange(len(D)): tmp = 0 - (C[i] + D[j]) if tmp in m: res += m[tmp] return res123456789101112131415161718192021class Solution &#123; public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123; int res = 0; Map&lt;Integer, Integer&gt; counter = new HashMap&lt;&gt;(); for (int i = 0; i &lt; A.length; i++) &#123; for (int j = 0; j &lt; B.length; j++) &#123; int tmp = A[i] + B[j]; counter.put(tmp, counter.getOrDefault(tmp, 0) + 1); &#125; &#125; for (int i = 0; i &lt; C.length; i++) &#123; for (int j = 0; j &lt; D.length; j++) &#123; int tmp = C[i] + D[j]; if (counter.containsKey(-tmp)) &#123; res += counter.get(-tmp); &#125; &#125; &#125; return res; &#125;&#125; 525. 连续数组给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。 示例 1: 输入: [0,1] 输出: 2 说明: [0, 1] 是具有相同数量0和1的最长连续子数组。 示例 2: 输入: [0,1,0] 输出: 2 说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。 注意: 给定的二进制数组的长度不会超过50000。 123456789101112131415class Solution(object): def findMaxLength(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; m = &#123;0:-1&#125; res, cnt = 0, 0 for i, n in enumerate(nums): cnt = cnt + 1 if n == 1 else cnt - 1 if cnt in m: res = max(res, i - m[cnt]) else: m[cnt] = i return res 560. 和为K的子数组 [n]给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1 : 输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明 : 数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。 1234567891011121314151617class Solution(object): def subarraySum(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; res, cur_sum, pre_sum_map = 0, 0, &#123;0:1&#125; for n in nums: cur_sum += n if cur_sum - k in pre_sum_map: res += pre_sum_map[cur_sum - k] if cur_sum in pre_sum_map: pre_sum_map[cur_sum] += 1 else: pre_sum_map[cur_sum] = 1 return res 594. 最长和谐子序列 [n]和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。 现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。 示例 1: 输入: [1,3,2,2,5,2,3,7] 输出: 5 原因: 最长的和谐数组是：[3,2,2,2,3]. 说明: 输入的数组长度最大不超过20,000. 1234567891011121314151617181920class Solution(object): def findLHS(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; m = &#123;&#125; for n in nums: if n in m: m[n] += 1 else: m[n] = 1 res = 0 for n in set(nums): a, b = n - 1, n + 1 if a in m: res = max(res, m[a] + m[n]) if b in m: res = max(res, m[b] + m[n]) return res 648. 单词替换 [n]在英语中，我们有一个叫做 词根(root)的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。 现在，给定一个由许多词根组成的词典和一个句子。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。 你需要输出替换之后的句子。 示例 1: 输入: dict(词典) = [\"cat\", \"bat\", \"rat\"] sentence(句子) = \"the cattle was rattled by the battery\" 输出: \"the cat was rat by the bat\" 注: 输入只包含小写字母。 1 &lt;= 字典单词数 &lt;=1000 1 &lt;= 句中词语数 &lt;= 1000 1 &lt;= 词根长度 &lt;= 100 1 &lt;= 句中词语长度 &lt;= 1000 12345678910111213141516171819class Solution(object): def replaceWords(self, words, sentence): &quot;&quot;&quot; :type words: List[str] :type sentence: str :rtype: str &quot;&quot;&quot; res = [] wordset = set(words) for word in sentence.split(&#x27; &#x27;): res.append(self.replaceWord(word, wordset)) return &#x27; &#x27;.join(res) def replaceWord(self, word, wordset): for i in xrange(len(word)): if word[:i] in wordset: return word[:i] return word 720. 词典中最长的单词 [n]给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。 若无答案，则返回空字符串。 示例 1: 输入: words = [\"w\",\"wo\",\"wor\",\"worl\", \"world\"] 输出: \"world\" 解释: 单词\"world\"可由\"w\", \"wo\", \"wor\", 和 \"worl\"添加一个字母组成。 示例 2: 输入: words = [\"a\", \"banana\", \"app\", \"appl\", \"ap\", \"apply\", \"apple\"] 输出: \"apple\" 解释: \"apply\"和\"apple\"都能由词典中的单词组成。但是\"apple\"得字典序小于\"apply\"。 注意: 所有输入的字符串都只包含小写字母。 words数组长度范围为[1,1000]。 words[i]的长度范围为[1,30]。 123456789101112131415class Solution(object): def longestWord(self, words): &quot;&quot;&quot; :type words: List[str] :rtype: str &quot;&quot;&quot; words = sorted(words) word_set = set([&#x27;&#x27;])# 巧妙之处 res = &#x27;&#x27; for word in words: if word[:-1] in word_set: word_set.add(word) if len(word) &gt; len(res): res = word return res","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"},{"name":"Tech","slug":"Tech","permalink":"https://leel0330.github.io/categories/Tech/"},{"name":"Book","slug":"Book","permalink":"https://leel0330.github.io/categories/Book/"}],"tags":[]}