{"meta":{"title":"PingCoder","subtitle":"","description":"less is more","author":"PingCoder","url":"https://leel0330.github.io","root":"/"},"pages":[{"title":"","date":"2020-11-27T13:37:29.000Z","updated":"2020-12-26T07:21:26.332Z","comments":false,"path":"about/index.html","permalink":"https://leel0330.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-27T13:37:44.000Z","updated":"2020-11-27T13:38:19.224Z","comments":true,"path":"categories/index.html","permalink":"https://leel0330.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-12-26T03:48:15.000Z","updated":"2020-12-26T14:14:46.465Z","comments":false,"path":"friends/index.html","permalink":"https://leel0330.github.io/friends/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-27T13:40:50.000Z","updated":"2020-11-27T13:41:07.414Z","comments":true,"path":"tags/index.html","permalink":"https://leel0330.github.io/tags/index.html","excerpt":"","text":""},{"title":"åŠ¨æ€","date":"2020-12-13T14:45:30.000Z","updated":"2021-02-26T12:49:37.740Z","comments":false,"path":"timeline/index.html","permalink":"https://leel0330.github.io/timeline/index.html","excerpt":"","text":"2021å¹´ 2æœˆ26æ—¥ äºŒæœˆçš„æœ€åä¸€ä¸ªå·¥ä½œæ—¥ï¼Œé›¨å¤œ 2021å¹´çš„ç¬¬ä¸€åœºé›¨ï¼Œè®©æˆ‘æƒ³èµ·äº†æœç”«çš„ä¸€é¦–è¯—:å¥½é›¨çŸ¥æ—¶èŠ‚ï¼Œå½“æ˜¥ä¹ƒå‘ç”Ÿã€‚éšé£æ½œå…¥å¤œï¼Œæ¶¦ç‰©ç»†æ— å£°ã€‚é‡å¾„äº‘ä¿±é»‘ï¼Œæ±Ÿèˆ¹ç«ç‹¬æ˜ã€‚æ™“çœ‹çº¢æ¹¿å¤„ï¼ŒèŠ±é‡é”¦å®˜åŸã€‚æ˜¥å¤œå–œé›¨ æœç”« 2020å¹´ 12æœˆ31æ—¥ ä¸€ä¸ªæœ‰ç‚¹å†·ä½†æ˜¯é˜³å…‰ç¿çƒ‚çš„ä¸‹åˆ 2020å¹´æœ€åä¸€å¤©äº†ï¼Œæ²¡æƒ³åˆ°å¸¦äº†ä¸€å¹´å£ç½©ğŸ˜‚ã€‚ç½‘ä¸Šçš„å¹´ç»ˆæ€»ç»“å¤ªå¤šäº†ï¼Œå¯¹äºæˆ‘ï¼Œä¸çŸ¥é“æ€»ç»“ä»€ä¹ˆæ‰å¥½ã€‚ç´¢æ€§è¿˜æ˜¯è®©å‘¨å¤§ä¾ å‡ºåœºå§~æœ€åçš„æœ€åï¼Œæƒ³äº†æƒ³è¿˜æ˜¯ä¸‹é¢è¿™é¦–æ­Œæ¯”è¾ƒåº”æ™¯ã€‚ 2020ï¼Œæƒ³è¯´çˆ±ä½ ä¸å®¹æ˜“~å°±æ˜¯å¼€ä¸äº†å£è®©å¥¹çŸ¥é“ï¼Œæˆ‘ä¸€å®šä¼šå‘µæŠ¤ç€ä½ ï¼Œä¹Ÿé€—ä½ ç¬‘ã€‚ä½ å¯¹æˆ‘æœ‰å¤šé‡è¦ï¼Œæˆ‘åæ‚”æ²¡è®©ä½ çŸ¥é“ã€‚æ•´é¢—å¿ƒæ‚¬åœ¨åŠç©ºï¼Œæˆ‘åªèƒ½å¤Ÿè¿œè¿œçœ‹ç€ã€‚è¿™äº›æˆ‘éƒ½åšå¾—åˆ°ï¼Œä½†é‚£ä¸ªäººå·²ä¸æ˜¯æˆ‘ã€‚ 12æœˆ26æ—¥ ä¸€ä¸ªé˜³å…‰ç¿çƒ‚çš„ä¸‹åˆ å°æ—¶å€™å–œæ¬¢Jerryçš„èªæ˜æœºæ™ºï¼Œé•¿å¤§äº†æ‰å‘ç°Tomçš„â€œæ— æ‰€ä¸èƒ½â€æ‰æ›´æƒ¹äººå–œçˆ±ã€‚æ„Ÿè°¢Tomç»™æˆ‘çš„ç«¥å¹´å¸¦æ¥é‚£ä¹ˆå¤šæ¬¢ä¹ï¼ 12æœˆ25æ—¥ åœ£è¯èŠ‚æ™šä¸Š ä¹‹å‰åšå®¢ç”¨çš„Nextä¸»é¢˜ï¼Œå¯æ˜¯å‘ç°ç½‘ä¸Šç”¨è¿™ä¸ªä¸»é¢˜çš„äººå¤ªå¤šäº†ã€‚ã€‚ã€‚è™½ç„¶Nextç®€æ´å¤§æ–¹ï¼Œä½†è¿˜æ˜¯æœ‰ç‚¹å¤ªç®€æ´äº†ï¼Œç´¢æ€§ä»Šå¤©èŠ±äº†ç‚¹æ—¶é—´æ›´æ–°ä¸»é¢˜åˆ°volantisäº†ã€‚volantiså¯ä»¥æ”¯æŒæˆ‘ä¹‹å‰mdçš„è¯­æ³•ï¼Œå‡ ä¹ä¸éœ€è¦ä¿®æ”¹ï¼Œè¿™ç‚¹å¯¹æˆ‘è¿˜æ˜¯æŒºå¸å¼•çš„ï¼Œç°åœ¨çš„åšå®¢ç›¸è¾ƒä¹‹å‰ï¼Œçœ‹èµ·æ¥ç¡®å®æ›´ç¾è§‚äº†~ 12æœˆ20æ—¥ å‘¨æ—¥é¢è¯•äº†å­—èŠ‚ï¼Œé¡¹ç›®ç»å†æ²¡æœ‰ç­”å¥½ï¼Œè‡ªå·±å¯¹ä»¥å‰åšçš„é¡¹ç›®æ€è€ƒè¿˜ä¸å¤Ÿï¼Œçœ‹æ¥è¿™å—éœ€è¦åŠ å¼ºã€‚é¢è¯•å®˜å‡ºäº†ä¸€é“å•è°ƒæ ˆçš„ç®—æ³•é¢˜(ä¸‹æ¥æœäº†ä¸€ä¸‹æ‰çŸ¥é“æ˜¯å•è°ƒæ ˆ)æ‰“ç®—åŠé€€å§ï¼Œæˆ‘è‡ªå·±éƒ½æ²¡æƒ³åˆ°å±…ç„¶åšå‡ºæ¥äº†ã€‚å¯æƒœæ²¡ä»€ä¹ˆç”¨äº†è¯¶(æœäº†æˆ‘è‡ªå·±ï¼Œç®—æ³•é¢˜æ²¡åšå‡ºæ¥çš„æ—¶å€™å‰é¢ç­”çš„å¥½ï¼Œç®—æ³•é¢˜åšå‡ºæ¥äº†å‰é¢å´ç­”ä¸å¥½ï¼Œæ€»æ˜¯äºŒç¼ºä¸€)ï¼Œå‰é¢çš„é—®é¢˜å›ç­”çš„ä¸å¤ªå¥½ï¼Œç»™é¢è¯•å®˜ç•™ä¸‹äº†ä¸å¥½çš„å°è±¡ï¼Œçœ‹æ¥ç®—æ³•å’Œé¡¹ç›®å¾—ä¸¤æ‰‹æŠ“ï¼Œå¸Œæœ›è‡ªå·±æ—©æ—¥èƒ½é¢ä¸Šå¤§å‚ï¼Œåªèƒ½ç¥è‡ªå·±ä»¥åå¥½è¿äº†ã€‚ 12æœˆ13æ—¥ ä»Šå¤©å¼€å§‹å†™ä¸€äº›ç®€å•çš„æ–‡å­—ï¼Œæ¥è®°å½•ä¸€ä¸‹å½“å¤©çš„å¿ƒæƒ…ã€‚ç¬¬ä¸€å¤©ï¼Œä¸çŸ¥é“å†™ä»€ä¹ˆï¼Œé‚£å¼€å§‹æŒ‰ç…§å­¦ä¹ ç¼–ç¨‹è¯­è¨€çš„æƒ¯ä¾‹ï¼Œå†™ä¸‹å¤§å¤§çš„Hello World!å“†å•¦Aæ¢¦ç¥æˆ‘å¥½è¿è¿è¿"}],"posts":[{"title":"LeetCodeä¹‹å¹¿åº¦ä¼˜å…ˆéå†","slug":"LeetCode-å¹¿åº¦ä¼˜å…ˆéå†","date":"2021-03-14T13:55:04.000Z","updated":"2021-03-14T14:01:54.242Z","comments":false,"path":"posts/160200368.html","link":"","permalink":"https://leel0330.github.io/posts/160200368.html","excerpt":"å¹¿åº¦ä¼˜å…ˆéå†çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚","text":"å¹¿åº¦ä¼˜å…ˆéå†çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ 101. å¯¹ç§°äºŒå‰æ ‘ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦æ˜¯é•œåƒå¯¹ç§°çš„ã€‚ ä¾‹å¦‚ï¼ŒäºŒå‰æ ‘ [1,2,2,3,4,4,3] æ˜¯å¯¹ç§°çš„ã€‚ 1 / \\ 2 2 / \\ / \\ 3 4 4 3 ä½†æ˜¯ä¸‹é¢è¿™ä¸ª [1,2,2,null,3,null,3] åˆ™ä¸æ˜¯é•œåƒå¯¹ç§°çš„: 1 / \\ 2 2 \\ \\ 3 3 è¯´æ˜: å¦‚æœä½ å¯ä»¥è¿ç”¨é€’å½’å’Œè¿­ä»£ä¸¤ç§æ–¹æ³•è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä¼šå¾ˆåŠ åˆ†ã€‚ 1234567891011121314151617181920212223class Solution(object): def isSymmetric(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; if root is None: return True queue = [root, root] while queue: t1 = queue.pop(0) t2 = queue.pop(0) if t1 is None and t2 is None: continue if t1 is None or t2 is None: return False if t1.val != t2.val: return False queue.append(t1.left) queue.append(t2.right) queue.append(t1.right) queue.append(t2.left) return True 111. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å°æ·±åº¦ã€‚ æœ€å°æ·±åº¦æ˜¯ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿‘å¶å­èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°é‡ã€‚ è¯´æ˜: å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚ ç¤ºä¾‹: ç»™å®šäºŒå‰æ ‘ [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 è¿”å›å®ƒçš„æœ€å°æ·±åº¦ 2. 123456789101112131415161718192021class Solution(object): def minDepth(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; if root is None: return 0 depth = 0 queue = [root] while queue: sz = len(queue) depth += 1 for i in xrange(sz): node = queue.pop(0) if node.left is None and node.right is None: return depth if node.left: queue.append(node.left) if node.right: queue.append(node.right) 127. å•è¯æ¥é¾™ [n]ç»™å®šä¸¤ä¸ªå•è¯ï¼ˆbeginWord å’Œ endWordï¼‰å’Œä¸€ä¸ªå­—å…¸ï¼Œæ‰¾åˆ°ä» beginWord åˆ° endWord çš„æœ€çŸ­è½¬æ¢åºåˆ—çš„é•¿åº¦ã€‚è½¬æ¢éœ€éµå¾ªå¦‚ä¸‹è§„åˆ™ï¼š æ¯æ¬¡è½¬æ¢åªèƒ½æ”¹å˜ä¸€ä¸ªå­—æ¯ã€‚è½¬æ¢è¿‡ç¨‹ä¸­çš„ä¸­é—´å•è¯å¿…é¡»æ˜¯å­—å…¸ä¸­çš„å•è¯ã€‚ è¯´æ˜: å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„è½¬æ¢åºåˆ—ï¼Œè¿”å› 0ã€‚ æ‰€æœ‰å•è¯å…·æœ‰ç›¸åŒçš„é•¿åº¦ã€‚ æ‰€æœ‰å•è¯åªç”±å°å†™å­—æ¯ç»„æˆã€‚ å­—å…¸ä¸­ä¸å­˜åœ¨é‡å¤çš„å•è¯ã€‚ ä½ å¯ä»¥å‡è®¾ beginWord å’Œ endWord æ˜¯éç©ºçš„ï¼Œä¸”äºŒè€…ä¸ç›¸åŒã€‚ ç¤ºä¾‹ 1: è¾“å…¥: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"] è¾“å‡º: 5 è§£é‡Š: ä¸€ä¸ªæœ€çŸ­è½¬æ¢åºåˆ—æ˜¯ \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", è¿”å›å®ƒçš„é•¿åº¦ 5ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: beginWord = \"hit\" endWord = \"cog\" wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"] è¾“å‡º: 0 è§£é‡Š: endWord \"cog\" ä¸åœ¨å­—å…¸ä¸­ï¼Œæ‰€ä»¥æ— æ³•è¿›è¡Œè½¬æ¢ã€‚ 1234567891011121314151617181920212223242526272829303132333435class Solution(object): def ladderLength(self, beginWord, endWord, wordList): &quot;&quot;&quot; :type beginWord: str :type endWord: str :type wordList: List[str] :rtype: int &quot;&quot;&quot; word_set = set(wordList) if endWord not in word_set: return 0 chrs = [chr(ord(&#x27;a&#x27;) + i) for i in xrange(26)] step = 0 queue = [beginWord] used = &#123;beginWord:True&#125; n = len(beginWord) while queue: sz = len(queue) step += 1 for i in xrange(sz): word = list(queue.pop(0)) for j in xrange(n): original_c = word[j] for c in chrs: word[j] = c tmp = &#x27;&#x27;.join(word) if tmp in used: continue if tmp == endWord: return step + 1 if tmp in word_set: queue.append(tmp) used[tmp] = True word[j] = original_c return 0 130. è¢«å›´ç»•çš„åŒºåŸŸ [n]ç»™å®šä¸€ä¸ªäºŒç»´çš„çŸ©é˜µï¼ŒåŒ…å« â€˜Xâ€™ å’Œ â€˜Oâ€™ï¼ˆå­—æ¯ Oï¼‰ã€‚ æ‰¾åˆ°æ‰€æœ‰è¢« â€˜Xâ€™ å›´ç»•çš„åŒºåŸŸï¼Œå¹¶å°†è¿™äº›åŒºåŸŸé‡Œæ‰€æœ‰çš„ â€˜Oâ€™ ç”¨ â€˜Xâ€™ å¡«å……ã€‚ ç¤ºä¾‹: X X X X X O O X X X O X X O X X è¿è¡Œä½ çš„å‡½æ•°åï¼ŒçŸ©é˜µå˜ä¸ºï¼š X X X X X X X X X X X X X O X X è§£é‡Š: è¢«å›´ç»•çš„åŒºé—´ä¸ä¼šå­˜åœ¨äºè¾¹ç•Œä¸Šï¼Œæ¢å¥è¯è¯´ï¼Œä»»ä½•è¾¹ç•Œä¸Šçš„ 'O' éƒ½ä¸ä¼šè¢«å¡«å……ä¸º 'X'ã€‚ ä»»ä½•ä¸åœ¨è¾¹ç•Œä¸Šï¼Œæˆ–ä¸ä¸è¾¹ç•Œä¸Šçš„ 'O' ç›¸è¿çš„ 'O' æœ€ç»ˆéƒ½ä¼šè¢«å¡«å……ä¸º 'X'ã€‚å¦‚æœä¸¤ä¸ªå…ƒç´ åœ¨æ°´å¹³æˆ–å‚ç›´æ–¹å‘ç›¸é‚»ï¼Œåˆ™ç§°å®ƒä»¬æ˜¯â€œç›¸è¿â€çš„ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution(object): def solve(self, board): &quot;&quot;&quot; :type board: List[List[str]] :rtype: None Do not return anything, modify board in-place instead. &quot;&quot;&quot; if board is None or len(board) == 0 or len(board[0]) == 0: return rows, cols = len(board), len(board[0]) for i in xrange(rows): if board[i][0] == &#x27;O&#x27;: self.bfs(board, i, 0, rows, cols) if board[i][cols - 1] == &#x27;O&#x27;: self.bfs(board, i, cols - 1, rows, cols) for j in xrange(cols): if board[0][j] == &#x27;O&#x27;: self.bfs(board, 0, j, rows, cols) if board[rows - 1][j] == &#x27;O&#x27;: self.bfs(board, rows - 1, j, rows, cols) for i in xrange(rows): for j in xrange(cols): if board[i][j] == &#x27;G&#x27;: board[i][j] = &#x27;O&#x27; elif board[i][j] == &#x27;O&#x27;: board[i][j] = &#x27;X&#x27; def bfs(self, board, i, j, rows, cols): board[i][j] = &#x27;G&#x27; queue = [(i, j)] while queue: x, y = queue.pop(0) if x &gt;= 1 and board[x - 1][y] == &#x27;O&#x27;: board[x - 1][y] = &#x27;G&#x27; queue.append((x - 1, y)) if x &lt; rows - 1 and board[x + 1][y] == &#x27;O&#x27;: board[x + 1][y] = &#x27;G&#x27; queue.append((x + 1, y)) if y &gt;= 1 and board[x][y - 1] == &#x27;O&#x27;: board[x][y - 1] = &#x27;G&#x27; queue.append((x, y - 1)) if y &lt; cols - 1 and board[x][y + 1] == &#x27;O&#x27;: board[x][y + 1] = &#x27;G&#x27; queue.append((x, y + 1)) 542. 01 çŸ©é˜µ [n]ç»™å®šä¸€ä¸ªç”± 0 å’Œ 1 ç»„æˆçš„çŸ©é˜µï¼Œæ‰¾å‡ºæ¯ä¸ªå…ƒç´ åˆ°æœ€è¿‘çš„ 0 çš„è·ç¦»ã€‚ ä¸¤ä¸ªç›¸é‚»å…ƒç´ é—´çš„è·ç¦»ä¸º 1 ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: 0 0 0 0 1 0 0 0 0 è¾“å‡º: 0 0 0 0 1 0 0 0 0 ç¤ºä¾‹ 2: è¾“å…¥: 0 0 0 0 1 0 1 1 1 è¾“å‡º: 0 0 0 0 1 0 1 2 1 æ³¨æ„: ç»™å®šçŸ©é˜µçš„å…ƒç´ ä¸ªæ•°ä¸è¶…è¿‡ 10000ã€‚ ç»™å®šçŸ©é˜µä¸­è‡³å°‘æœ‰ä¸€ä¸ªå…ƒç´ æ˜¯ 0ã€‚ çŸ©é˜µä¸­çš„å…ƒç´ åªåœ¨å››ä¸ªæ–¹å‘ä¸Šç›¸é‚»: ä¸Šã€ä¸‹ã€å·¦ã€å³ã€‚ 123456789101112131415161718192021222324class Solution(object): def updateMatrix(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: List[List[int]] &quot;&quot;&quot; m, n = len(matrix), len(matrix[0]) res = [[-1 for _ in xrange(n)] for _ in xrange(m)] queue = [] for i in xrange(m): for j in xrange(n): if matrix[i][j] == 0: res[i][j] = 0 queue.append((i, j)) dires = [(0, 1), (0, -1), (1, 0), (-1, 0)] while queue: x, y = queue.pop(0) for dire in dires: a = x + dire[0] b = y + dire[1] if 0 &lt;= a &lt; m and 0 &lt;= b &lt; n and res[a][b] == -1: res[a][b] = res[x][y] + 1 queue.append((a, b)) return res 841. é’¥åŒ™å’Œæˆ¿é—´ [n]æœ‰ N ä¸ªæˆ¿é—´ï¼Œå¼€å§‹æ—¶ä½ ä½äº 0 å·æˆ¿é—´ã€‚æ¯ä¸ªæˆ¿é—´æœ‰ä¸åŒçš„å·ç ï¼š0ï¼Œ1ï¼Œ2ï¼Œâ€¦ï¼ŒN-1ï¼Œå¹¶ä¸”æˆ¿é—´é‡Œå¯èƒ½æœ‰ä¸€äº›é’¥åŒ™èƒ½ä½¿ä½ è¿›å…¥ä¸‹ä¸€ä¸ªæˆ¿é—´ã€‚ åœ¨å½¢å¼ä¸Šï¼Œå¯¹äºæ¯ä¸ªæˆ¿é—´ i éƒ½æœ‰ä¸€ä¸ªé’¥åŒ™åˆ—è¡¨ rooms[i]ï¼Œæ¯ä¸ªé’¥åŒ™ rooms[i][j] ç”± [0,1ï¼Œâ€¦ï¼ŒN-1] ä¸­çš„ä¸€ä¸ªæ•´æ•°è¡¨ç¤ºï¼Œå…¶ä¸­ N = rooms.lengthã€‚ é’¥åŒ™ rooms[i][j] = v å¯ä»¥æ‰“å¼€ç¼–å·ä¸º v çš„æˆ¿é—´ã€‚ æœ€åˆï¼Œé™¤ 0 å·æˆ¿é—´å¤–çš„å…¶ä½™æ‰€æœ‰æˆ¿é—´éƒ½è¢«é”ä½ã€‚ ä½ å¯ä»¥è‡ªç”±åœ°åœ¨æˆ¿é—´ä¹‹é—´æ¥å›èµ°åŠ¨ã€‚ å¦‚æœèƒ½è¿›å…¥æ¯ä¸ªæˆ¿é—´è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥: [[1],[2],[3],[]] è¾“å‡º: true è§£é‡Š: æˆ‘ä»¬ä» 0 å·æˆ¿é—´å¼€å§‹ï¼Œæ‹¿åˆ°é’¥åŒ™ 1ã€‚ ä¹‹åæˆ‘ä»¬å» 1 å·æˆ¿é—´ï¼Œæ‹¿åˆ°é’¥åŒ™ 2ã€‚ ç„¶åæˆ‘ä»¬å» 2 å·æˆ¿é—´ï¼Œæ‹¿åˆ°é’¥åŒ™ 3ã€‚ æœ€åæˆ‘ä»¬å»äº† 3 å·æˆ¿é—´ã€‚ ç”±äºæˆ‘ä»¬èƒ½å¤Ÿè¿›å…¥æ¯ä¸ªæˆ¿é—´ï¼Œæˆ‘ä»¬è¿”å› trueã€‚ ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼š[[1,3],[3,0,1],[2],[0]] è¾“å‡ºï¼šfalse è§£é‡Šï¼šæˆ‘ä»¬ä¸èƒ½è¿›å…¥ 2 å·æˆ¿é—´ã€‚ æç¤ºï¼š 1 &lt;= rooms.length &lt;= 1000 0 &lt;= rooms[i].length &lt;= 1000 æ‰€æœ‰æˆ¿é—´ä¸­çš„é’¥åŒ™æ•°é‡æ€»è®¡ä¸è¶…è¿‡ 3000 123456789101112131415161718class Solution(object): def canVisitAllRooms(self, rooms): &quot;&quot;&quot; :type rooms: List[List[int]] :rtype: bool &quot;&quot;&quot; visited = [0 for _ in xrange(len(rooms))] queue = [0] while queue: sz = len(queue) for i in xrange(sz): room_idx = queue.pop(0) if visited[room_idx] == 1: continue visited[room_idx] = 1 for j in rooms[room_idx]: queue.append(j) return sum(visited) == len(rooms) 863. äºŒå‰æ ‘ä¸­æ‰€æœ‰è·ç¦»ä¸º K çš„ç»“ç‚¹ [n]ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼ˆå…·æœ‰æ ¹ç»“ç‚¹ rootï¼‰ï¼Œ ä¸€ä¸ªç›®æ ‡ç»“ç‚¹ target ï¼Œå’Œä¸€ä¸ªæ•´æ•°å€¼ K ã€‚ è¿”å›åˆ°ç›®æ ‡ç»“ç‚¹ target è·ç¦»ä¸º K çš„æ‰€æœ‰ç»“ç‚¹çš„å€¼çš„åˆ—è¡¨ã€‚ ç­”æ¡ˆå¯ä»¥ä»¥ä»»ä½•é¡ºåºè¿”å›ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šroot = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2 è¾“å‡ºï¼š[7,4,1] è§£é‡Šï¼š æ‰€æ±‚ç»“ç‚¹ä¸ºä¸ç›®æ ‡ç»“ç‚¹ï¼ˆå€¼ä¸º 5ï¼‰è·ç¦»ä¸º 2 çš„ç»“ç‚¹ï¼Œ å€¼åˆ†åˆ«ä¸º 7ï¼Œ4ï¼Œä»¥åŠ 1 æç¤ºï¼š ç»™å®šçš„æ ‘æ˜¯éç©ºçš„ï¼Œä¸”æœ€å¤šæœ‰ K ä¸ªç»“ç‚¹ã€‚ æ ‘ä¸Šçš„æ¯ä¸ªç»“ç‚¹éƒ½å…·æœ‰å”¯ä¸€çš„å€¼ 0 &lt;= node.val &lt;= 500 ã€‚ ç›®æ ‡ç»“ç‚¹ target æ˜¯æ ‘ä¸Šçš„ç»“ç‚¹ã€‚ 0 &lt;= K &lt;= 1000. 123456789101112131415161718192021222324252627282930313233class Solution(object): def distanceK(self, root, target, K): &quot;&quot;&quot; :type root: TreeNode :type target: TreeNode :type K: int :rtype: List[int] &quot;&quot;&quot; m = collections.defaultdict(list) self.helper(None, root, m) queue = [target.val] visited = set([target.val]) for _ in xrange(K): sz = len(queue) for _ in xrange(sz): v = queue.pop(0) for i in m[v]: if i not in visited: visited.add(i) queue.append(i) return queue def helper(self, parent, child, m): if parent and child: m[child.val].append(parent.val) m[parent.val].append(child.val) if child.left: self.helper(child, child.left, m) if child.right: self.helper(child, child.right, m) 993. äºŒå‰æ ‘çš„å ‚å…„å¼ŸèŠ‚ç‚¹ [n]åœ¨äºŒå‰æ ‘ä¸­ï¼Œæ ¹èŠ‚ç‚¹ä½äºæ·±åº¦ 0 å¤„ï¼Œæ¯ä¸ªæ·±åº¦ä¸º k çš„èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ä½äºæ·±åº¦ k+1 å¤„ã€‚ å¦‚æœäºŒå‰æ ‘çš„ä¸¤ä¸ªèŠ‚ç‚¹æ·±åº¦ç›¸åŒï¼Œä½†çˆ¶èŠ‚ç‚¹ä¸åŒï¼Œåˆ™å®ƒä»¬æ˜¯ä¸€å¯¹å ‚å…„å¼ŸèŠ‚ç‚¹ã€‚ æˆ‘ä»¬ç»™å‡ºäº†å…·æœ‰å”¯ä¸€å€¼çš„äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ rootï¼Œä»¥åŠæ ‘ä¸­ä¸¤ä¸ªä¸åŒèŠ‚ç‚¹çš„å€¼ x å’Œ yã€‚ åªæœ‰ä¸å€¼ x å’Œ y å¯¹åº”çš„èŠ‚ç‚¹æ˜¯å ‚å…„å¼ŸèŠ‚ç‚¹æ—¶ï¼Œæ‰è¿”å› trueã€‚å¦åˆ™ï¼Œè¿”å› falseã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šroot = [1,2,3,4], x = 4, y = 3 è¾“å‡ºï¼šfalse ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šroot = [1,2,3,null,4,null,5], x = 5, y = 4 è¾“å‡ºï¼štrue ç¤ºä¾‹ 3ï¼š è¾“å…¥ï¼šroot = [1,2,3,null,4], x = 2, y = 3 è¾“å‡ºï¼šfalse 12345678910111213141516171819202122232425262728class Solution(object): def isCousins(self, root, x, y): &quot;&quot;&quot; :type root: TreeNode :type x: int :type y: int :rtype: bool &quot;&quot;&quot; if root is None: return False queue = [(root, None)] m = &#123;&#125; depth = 0 while queue: sz = len(queue) for i in xrange(sz): node, parent = queue.pop(0) m[node.val] = (parent, depth) if node.left: queue.append((node.left, node)) if node.right: queue.append((node.right, node)) depth += 1 px, dx = m[x] py, dy = m[y] return px != py and dx == dy","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"æµ·é‡æ•°æ®å¤„ç†å¸¸ç”¨æŠ€æ³•","slug":"æŠ€æœ¯é¢è¯•ä¹‹æµ·é‡æ•°æ®å¤„ç†","date":"2021-03-06T09:45:17.000Z","updated":"2021-03-06T10:26:46.945Z","comments":false,"path":"posts/1322695096.html","link":"","permalink":"https://leel0330.github.io/posts/1322695096.html","excerpt":"ä¹‹å‰é¢è¯•æœ‰ç¢°åˆ°è¿‡å¦‚ä½•å¤„ç†èµ„æºæœ‰é™(æ—¶é—´æœ‰é™æˆ–ç©ºé—´æœ‰é™)ä½†æ•°æ®è§„æ¨¡åºå¤§çš„é¢è¯•é¢˜ï¼Œç„¶åæŸ¥é˜…äº†ç½‘ä¸Šçš„ä¸€äº›èµ„æ–™ï¼Œè¿™é‡Œåšä¸ªç®€å•çš„æ€»ç»“ã€‚","text":"ä¹‹å‰é¢è¯•æœ‰ç¢°åˆ°è¿‡å¦‚ä½•å¤„ç†èµ„æºæœ‰é™(æ—¶é—´æœ‰é™æˆ–ç©ºé—´æœ‰é™)ä½†æ•°æ®è§„æ¨¡åºå¤§çš„é¢è¯•é¢˜ï¼Œç„¶åæŸ¥é˜…äº†ç½‘ä¸Šçš„ä¸€äº›èµ„æ–™ï¼Œè¿™é‡Œåšä¸ªç®€å•çš„æ€»ç»“ã€‚ å¸¸è§çš„å¤„ç†æ–¹æ³•HashHashï¼Œå³å“ˆå¸Œï¼Œå°±æ˜¯æŠŠä»»æ„é•¿åº¦çš„è¾“å…¥ï¼ˆåˆå«åšé¢„æ˜ å°„ï¼Œ pre-imageï¼‰ï¼Œé€šè¿‡æ•£åˆ—ç®—æ³•ï¼Œå˜æ¢æˆå›ºå®šé•¿åº¦çš„è¾“å‡ºï¼Œè¯¥è¾“å‡ºå°±æ˜¯æ•£åˆ—å€¼ã€‚è¿™ç§è½¬æ¢æ˜¯ä¸€ç§å‹ç¼©æ˜ å°„ï¼Œä¹Ÿå°±æ˜¯ï¼Œæ•£åˆ—å€¼çš„ç©ºé—´é€šå¸¸è¿œå°äºè¾“å…¥çš„ç©ºé—´ï¼Œä¸åŒçš„è¾“å…¥å¯èƒ½ä¼šæ•£åˆ—æˆç›¸åŒçš„è¾“å‡ºï¼Œè€Œä¸å¯èƒ½ä»æ•£åˆ—å€¼æ¥å”¯ä¸€çš„ç¡®å®šè¾“å…¥å€¼(å¯ä»¥ç†è§£ä¸ºHashç¢°æ’)ã€‚ç®€å•çš„è¯´å°±æ˜¯ä¸€ç§å°†ä»»æ„é•¿åº¦çš„æ¶ˆæ¯å‹ç¼©åˆ°æŸä¸€å›ºå®šé•¿åº¦çš„æ¶ˆæ¯æ‘˜è¦çš„å‡½æ•°ã€‚ BitMapæ‰€è°“çš„BitMapå°±æ˜¯ç”¨ä¸€ä¸ªbitä½æ¥æ ‡è®°æŸä¸ªå…ƒç´ å¯¹åº”çš„å€¼ã€‚ç”±äºé‡‡ç”¨äº†Bitä¸ºå•ä½æ¥å­˜å‚¨æ•°æ®ï¼Œå› æ­¤åœ¨å­˜å‚¨ç©ºé—´æ–¹é¢ï¼Œå¯ä»¥å¤§å¤§èŠ‚çœã€‚ ä¸¾ä¸ªä¾‹å­ï¼Œä¸€ä¸ªintæ˜¯32bit(å³4ä¸ªå­—èŠ‚)ã€‚æˆ‘ä»¬å¯ä»¥ç”¨4ä¸ªå­—èŠ‚æ¥è¡¨ç¤º32ä¸ªæ•°ï¼Œå¦‚0-31ã€‚ä¸€å¼€å§‹æ‰€æœ‰ä½ä¸º0ï¼Œå¦‚æœæŸä¸ªæ•°å­˜åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠç›¸åº”ä½ç½®1ï¼Œç”¨æ­¤æ³•è¡¨ç¤ºè¯¥æ•°å­˜åœ¨ã€‚ Bloom FilterBloom Filterï¼ˆBFï¼‰æ˜¯ä¸€ç§ç©ºé—´æ•ˆç‡å¾ˆé«˜çš„éšæœºæ•°æ®ç»“æ„ï¼Œå®ƒåˆ©ç”¨ä½æ•°ç»„å¾ˆç®€æ´åœ°è¡¨ç¤ºä¸€ä¸ªé›†åˆï¼Œå¹¶èƒ½åˆ¤æ–­ä¸€ä¸ªå…ƒç´ æ˜¯å¦å±äºè¿™ä¸ªé›†åˆã€‚å®ƒæ˜¯ä¸€ä¸ªåˆ¤æ–­å…ƒç´ æ˜¯å¦å­˜åœ¨é›†åˆçš„å¿«é€Ÿçš„æ¦‚ç‡ç®—æ³•ã€‚Bloom Filteræœ‰å¯èƒ½ä¼šå‡ºç°é”™è¯¯åˆ¤æ–­ï¼Œä½†ä¸ä¼šæ¼æ‰åˆ¤æ–­ã€‚ä¹Ÿå°±æ˜¯Bloom Filteråˆ¤æ–­å…ƒç´ ä¸åœ¨é›†åˆï¼Œé‚£è‚¯å®šä¸åœ¨ã€‚å¦‚æœåˆ¤æ–­å…ƒç´ å­˜åœ¨é›†åˆä¸­ï¼Œæœ‰ä¸€å®šçš„æ¦‚ç‡åˆ¤æ–­é”™è¯¯ã€‚å› æ­¤ï¼ŒBloom Filterä¸é€‚åˆé‚£äº›â€œé›¶é”™è¯¯â€çš„åº”ç”¨åœºåˆã€‚ è€Œåœ¨èƒ½å®¹å¿ä½é”™è¯¯ç‡çš„åº”ç”¨åœºåˆä¸‹ï¼ŒBloom Filteræ¯”å…¶ä»–å¸¸è§çš„ç®—æ³•ï¼ˆå¦‚hashï¼ŒæŠ˜åŠæŸ¥æ‰¾ï¼‰æå¤§èŠ‚çœäº†ç©ºé—´ã€‚ Heapå †æ˜¯ä¸€ç§ç‰¹æ®Šçš„äºŒå‰æ ‘ï¼Œå…·å¤‡ä»¥ä¸‹ä¸¤ç§æ€§è´¨: æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½å¤§äºï¼ˆæˆ–è€…éƒ½å°äºï¼Œç§°ä¸ºæœ€å°å †ï¼‰å…¶å­èŠ‚ç‚¹çš„å€¼ æ ‘æ˜¯å®Œå…¨å¹³è¡¡çš„ï¼Œå¹¶ä¸”æœ€åä¸€å±‚çš„æ ‘å¶éƒ½åœ¨æœ€å·¦è¾¹è¿™æ ·å°±å®šä¹‰äº†ä¸€ä¸ªæœ€å¤§å †ã€‚ å¦‚ä¸‹å›¾ç”¨ä¸€ä¸ªæ•°ç»„æ¥è¡¨ç¤ºå †ï¼š Trieå¦‚ä¸‹å›¾æ¥è¡¨ç¤ºTrieæ ‘: Trieæ ‘æœ‰ä»¥ä¸‹å‡ ä¸ªç‰¹æ€§: æ ¹èŠ‚ç‚¹ä¸åŒ…å«å­—ç¬¦ï¼Œé™¤æ ¹èŠ‚ç‚¹å¤–çš„æ¯ä¸€ä¸ªå­èŠ‚ç‚¹éƒ½åŒ…å«ä¸€ä¸ªå­—ç¬¦ã€‚ ä»æ ¹èŠ‚ç‚¹åˆ°æŸä¸€èŠ‚ç‚¹ï¼Œè·¯å¾„ä¸Šç»è¿‡çš„å­—ç¬¦è¿æ¥èµ·æ¥ï¼Œå°±æ˜¯è¯¥èŠ‚ç‚¹å¯¹åº”çš„å­—ç¬¦ä¸²ã€‚ æ¯ä¸ªå•è¯çš„å…¬å…±å‰ç¼€ä½œä¸ºä¸€ä¸ªå­—ç¬¦èŠ‚ç‚¹ä¿å­˜ã€‚ é¢˜ç›®å®æˆ˜1. æµ·é‡æ—¥å¿—æ•°æ®ï¼Œæå–å‡ºæŸæ—¥è®¿é—®ç™¾åº¦æ¬¡æ•°æœ€å¤šçš„é‚£ä¸ªIPã€‚ç®—æ³•æ€æƒ³ï¼šåˆ†è€Œæ²»ä¹‹+Hash 1.IPåœ°å€æœ€å¤šæœ‰2^32=4Gç§å–å€¼æƒ…å†µï¼Œæ‰€ä»¥ä¸èƒ½å®Œå…¨åŠ è½½åˆ°å†…å­˜ä¸­å¤„ç†ï¼›2.å¯ä»¥è€ƒè™‘é‡‡ç”¨â€œåˆ†è€Œæ²»ä¹‹â€çš„æ€æƒ³ï¼ŒæŒ‰ç…§IPåœ°å€çš„Hash(IP)%1024å€¼ï¼ŒæŠŠæµ·é‡IPæ—¥å¿—åˆ†åˆ«å­˜å‚¨åˆ°1024ä¸ªå°æ–‡ä»¶ä¸­ã€‚è¿™æ ·ï¼Œæ¯ä¸ªå°æ–‡ä»¶æœ€å¤šåŒ…å«4MBä¸ªIPåœ°å€ï¼›3.å¯¹äºæ¯ä¸€ä¸ªå°æ–‡ä»¶ï¼Œå¯ä»¥æ„å»ºä¸€ä¸ªIPä¸ºkeyï¼Œå‡ºç°æ¬¡æ•°ä¸ºvalueçš„Hash mapï¼ŒåŒæ—¶è®°å½•å½“å‰å‡ºç°æ¬¡æ•°æœ€å¤šçš„é‚£ä¸ªIPåœ°å€ï¼›4.å¯ä»¥å¾—åˆ°1024ä¸ªå°æ–‡ä»¶ä¸­çš„å‡ºç°æ¬¡æ•°æœ€å¤šçš„IPï¼Œå†ä¾æ®å¸¸è§„çš„æ’åºç®—æ³•å¾—åˆ°æ€»ä½“ä¸Šå‡ºç°æ¬¡æ•°æœ€å¤šçš„IPï¼› 2. æœç´¢å¼•æ“ä¼šé€šè¿‡æ—¥å¿—æ–‡ä»¶æŠŠç”¨æˆ·æ¯æ¬¡æ£€ç´¢ä½¿ç”¨çš„æ‰€æœ‰æ£€ç´¢ä¸²éƒ½è®°å½•ä¸‹æ¥ï¼Œæ¯ä¸ªæŸ¥è¯¢ä¸²çš„é•¿åº¦ä¸º1-255å­—èŠ‚ã€‚å‡è®¾ç›®å‰æœ‰ä¸€åƒä¸‡ä¸ªè®°å½•ï¼ˆè¿™äº›æŸ¥è¯¢ä¸²çš„é‡å¤åº¦æ¯”è¾ƒé«˜ï¼Œè™½ç„¶æ€»æ•°æ˜¯1åƒä¸‡ï¼Œä½†å¦‚æœé™¤å»é‡å¤åï¼Œä¸è¶…è¿‡3ç™¾ä¸‡ä¸ªã€‚ä¸€ä¸ªæŸ¥è¯¢ä¸²çš„é‡å¤åº¦è¶Šé«˜ï¼Œè¯´æ˜æŸ¥è¯¢å®ƒçš„ç”¨æˆ·è¶Šå¤šï¼Œä¹Ÿå°±æ˜¯è¶Šçƒ­é—¨ã€‚ï¼‰ï¼Œè¯·ä½ ç»Ÿè®¡æœ€çƒ­é—¨çš„10ä¸ªæŸ¥è¯¢ä¸²ï¼Œè¦æ±‚ä½¿ç”¨çš„å†…å­˜ä¸èƒ½è¶…è¿‡1Gã€‚ç®—æ³•æ€æƒ³ï¼šhashmap+å † 1.å…ˆå¯¹è¿™æ‰¹æµ·é‡æ•°æ®é¢„å¤„ç†ï¼Œåœ¨Oï¼ˆNï¼‰çš„æ—¶é—´å†…ç”¨Hashè¡¨å®Œæˆç»Ÿè®¡ï¼›2.å€ŸåŠ©å †è¿™ä¸ªæ•°æ®ç»“æ„ï¼Œæ‰¾å‡ºTop Kï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(N*logK)ã€‚ æˆ–è€…ï¼šé‡‡ç”¨trieæ ‘ï¼Œå…³é”®å­—åŸŸå­˜è¯¥æŸ¥è¯¢ä¸²å‡ºç°çš„æ¬¡æ•°ï¼Œæ²¡æœ‰å‡ºç°ä¸º0ã€‚æœ€åç”¨10ä¸ªå…ƒç´ çš„æœ€å°å †æ¥å¯¹å‡ºç°é¢‘ç‡è¿›è¡Œæ’åºã€‚ 3. æœ‰ä¸€ä¸ª1Gå¤§å°çš„ä¸€ä¸ªæ–‡ä»¶ï¼Œé‡Œé¢æ¯ä¸€è¡Œæ˜¯ä¸€ä¸ªè¯ï¼Œè¯çš„å¤§å°ä¸è¶…è¿‡16å­—èŠ‚ï¼Œå†…å­˜é™åˆ¶å¤§å°æ˜¯1Mã€‚è¿”å›é¢‘æ•°æœ€é«˜çš„100ä¸ªè¯ã€‚ç®—æ³•æ€æƒ³ï¼šåˆ†è€Œæ²»ä¹‹ + hashç»Ÿè®¡ + å †æ’åº 1.é¡ºåºè¯»æ–‡ä»¶ä¸­ï¼Œå¯¹äºæ¯ä¸ªè¯xï¼Œå–hash(x)%5000ï¼Œç„¶åæŒ‰ç…§è¯¥å€¼å­˜åˆ°5000ä¸ªå°æ–‡ä»¶ï¼ˆè®°ä¸ºx0,x1,â€¦x4999ï¼‰ä¸­ã€‚è¿™æ ·æ¯ä¸ªæ–‡ä»¶å¤§æ¦‚æ˜¯200kå·¦å³ã€‚å¦‚æœå…¶ä¸­çš„æœ‰çš„æ–‡ä»¶è¶…è¿‡äº†1Må¤§å°ï¼Œè¿˜å¯ä»¥æŒ‰ç…§ç±»ä¼¼çš„æ–¹æ³•ç»§ç»­å¾€ä¸‹åˆ†ï¼Œç›´åˆ°åˆ†è§£å¾—åˆ°çš„å°æ–‡ä»¶çš„å¤§å°éƒ½ä¸è¶…è¿‡1Mã€‚ 2.å¯¹æ¯ä¸ªå°æ–‡ä»¶ï¼Œé‡‡ç”¨trieæ ‘/hash_mapç­‰ç»Ÿè®¡æ¯ä¸ªæ–‡ä»¶ä¸­å‡ºç°çš„è¯ä»¥åŠç›¸åº”çš„é¢‘ç‡ã€‚ 3.å–å‡ºå‡ºç°é¢‘ç‡æœ€å¤§çš„100ä¸ªè¯ï¼ˆå¯ä»¥ç”¨å«100ä¸ªç»“ç‚¹çš„æœ€å°å †ï¼‰åï¼Œå†æŠŠ100ä¸ªè¯åŠç›¸åº”çš„é¢‘ç‡å­˜å…¥æ–‡ä»¶ï¼Œè¿™æ ·åˆå¾—åˆ°äº†5000ä¸ªæ–‡ä»¶ã€‚æœ€åå°±æ˜¯æŠŠè¿™5000ä¸ªæ–‡ä»¶è¿›è¡Œå½’å¹¶ï¼ˆç±»ä¼¼äºå½’å¹¶æ’åºï¼‰çš„è¿‡ç¨‹äº†ã€‚ 4. æœ‰10ä¸ªæ–‡ä»¶ï¼Œæ¯ä¸ªæ–‡ä»¶1Gï¼Œæ¯ä¸ªæ–‡ä»¶çš„æ¯ä¸€è¡Œå­˜æ”¾çš„éƒ½æ˜¯ç”¨æˆ·çš„queryï¼Œæ¯ä¸ªæ–‡ä»¶çš„queryéƒ½å¯èƒ½é‡å¤ã€‚è¦æ±‚ä½ æŒ‰ç…§queryçš„é¢‘åº¦æ’åºã€‚æ–¹æ³•1: ç®—æ³•æ€æƒ³ï¼šåˆ†è€Œæ²»ä¹‹ + hashç»Ÿè®¡ + å †æ’åº é¡ºåºè¯»å–10ä¸ªæ–‡ä»¶ï¼ŒæŒ‰ç…§hash(query)%10çš„ç»“æœå°†queryå†™å…¥åˆ°å¦å¤–10ä¸ªæ–‡ä»¶ä¸­ã€‚è¿™æ ·æ–°ç”Ÿæˆçš„æ–‡ä»¶æ¯ä¸ªçš„å¤§å°å¤§çº¦ä¹Ÿ1Gï¼Œå¤§äº1Gç»§ç»­æŒ‰ç…§ä¸Šè¿°æ€è·¯åˆ†ã€‚ æ‰¾ä¸€å°å†…å­˜åœ¨2Gå·¦å³çš„æœºå™¨ï¼Œä¾æ¬¡å¯¹ç”¨hash_map(query, query_count)æ¥ç»Ÿè®¡æ¯ä¸ªqueryå‡ºç°çš„æ¬¡æ•°ã€‚åˆ©ç”¨å¿«é€Ÿ/å †/å½’å¹¶æ’åºæŒ‰ç…§å‡ºç°æ¬¡æ•°è¿›è¡Œæ’åºã€‚å°†æ’åºå¥½çš„queryå’Œå¯¹åº”çš„query_coutè¾“å‡ºåˆ°æ–‡ä»¶ä¸­ã€‚è¿™æ ·å¾—åˆ°äº†10ä¸ªæ’å¥½åºçš„æ–‡ä»¶ï¼ˆè®°ä¸ºï¼‰ã€‚ å¯¹è¿™10ä¸ªæ–‡ä»¶è¿›è¡Œå½’å¹¶æ’åºï¼ˆå†…æ’åºä¸å¤–æ’åºç›¸ç»“åˆï¼‰ã€‚ æ–¹æ³•2: ç®—æ³•æ€æƒ³ï¼šhashmap+å † ä¸€èˆ¬queryçš„æ€»é‡æ˜¯æœ‰é™çš„ï¼Œåªæ˜¯é‡å¤çš„æ¬¡æ•°æ¯”è¾ƒå¤šè€Œå·²ï¼Œå¯èƒ½å¯¹äºæ‰€æœ‰çš„queryï¼Œä¸€æ¬¡æ€§å°±å¯ä»¥åŠ å…¥åˆ°å†…å­˜äº†ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬å°±å¯ä»¥é‡‡ç”¨trieæ ‘/hash_mapç­‰ç›´æ¥æ¥ç»Ÿè®¡æ¯ä¸ªqueryå‡ºç°çš„æ¬¡æ•°ï¼Œç„¶åæŒ‰å‡ºç°æ¬¡æ•°åšå¿«é€Ÿ/å †/å½’å¹¶æ’åºå°±å¯ä»¥äº†ã€‚ 5. ç»™å®šaã€bä¸¤ä¸ªæ–‡ä»¶ï¼Œå„å­˜æ”¾50äº¿ä¸ªurlï¼Œæ¯ä¸ªurlå„å 64å­—èŠ‚ï¼Œå†…å­˜é™åˆ¶æ˜¯4Gï¼Œè®©ä½ æ‰¾å‡ºaã€bæ–‡ä»¶å…±åŒçš„urlã€‚ç®—æ³•æ€æƒ³ï¼šåˆ†è€Œæ²»ä¹‹ + hashç»Ÿè®¡ éå†æ–‡ä»¶aï¼Œå¯¹æ¯ä¸ªurlæ±‚å–hash(url)%1000ï¼Œç„¶åæ ¹æ®æ‰€å–å¾—çš„å€¼å°†urlåˆ†åˆ«å­˜å‚¨åˆ°1000ä¸ªå°æ–‡ä»¶ï¼ˆè®°ä¸ºa0,a1,â€¦,a999ï¼‰ä¸­ã€‚è¿™æ ·æ¯ä¸ªå°æ–‡ä»¶çš„å¤§çº¦ä¸º300Mã€‚ éå†æ–‡ä»¶bï¼Œé‡‡å–å’Œaç›¸åŒçš„æ–¹å¼å°†urlåˆ†åˆ«å­˜å‚¨åˆ°1000å°æ–‡ä»¶ï¼ˆè®°ä¸ºb0,b1,â€¦,b999ï¼‰ã€‚è¿™æ ·å¤„ç†åï¼Œæ‰€æœ‰å¯èƒ½ç›¸åŒçš„urléƒ½åœ¨å¯¹åº”çš„å°æ–‡ä»¶ï¼ˆa0vsb0,a1vsb1,â€¦,a999vsb999ï¼‰ä¸­ï¼Œä¸å¯¹åº”çš„å°æ–‡ä»¶ä¸å¯èƒ½æœ‰ç›¸åŒçš„urlã€‚ç„¶åæˆ‘ä»¬åªè¦æ±‚å‡º1000å¯¹å°æ–‡ä»¶ä¸­ç›¸åŒçš„urlå³å¯ã€‚ æ±‚æ¯å¯¹å°æ–‡ä»¶ä¸­ç›¸åŒçš„urlæ—¶ï¼Œå¯ä»¥æŠŠå…¶ä¸­ä¸€ä¸ªå°æ–‡ä»¶çš„urlå­˜å‚¨åˆ°hash_setä¸­ã€‚ç„¶åéå†å¦ä¸€ä¸ªå°æ–‡ä»¶çš„æ¯ä¸ªurlï¼Œçœ‹å…¶æ˜¯å¦åœ¨åˆšæ‰æ„å»ºçš„hash_setä¸­ï¼Œå¦‚æœæ˜¯ï¼Œé‚£ä¹ˆå°±æ˜¯å…±åŒçš„urlï¼Œå­˜åˆ°æ–‡ä»¶é‡Œé¢å°±å¯ä»¥äº†ã€‚ 6. åœ¨2.5äº¿ä¸ªæ•´æ•°ä¸­æ‰¾å‡ºä¸é‡å¤çš„æ•´æ•°ï¼Œæ³¨ï¼Œå†…å­˜ä¸è¶³ä»¥å®¹çº³è¿™2.5äº¿ä¸ªæ•´æ•°ã€‚BitMapå˜ç§ é‡‡ç”¨2-Bitmapï¼ˆæ¯ä¸ªæ•°åˆ†é…2bitï¼Œ00è¡¨ç¤ºä¸å­˜åœ¨ï¼Œ01è¡¨ç¤ºå‡ºç°ä¸€æ¬¡ï¼Œ10è¡¨ç¤ºå¤šæ¬¡ï¼Œ11æ— æ„ä¹‰ï¼‰è¿›è¡Œï¼Œå…±éœ€å†…å­˜2^32 * 2 bit=1 GBå†…å­˜ï¼Œè¿˜å¯ä»¥æ¥å—ã€‚ç„¶åæ‰«æè¿™2.5äº¿ä¸ªæ•´æ•°ï¼ŒæŸ¥çœ‹Bitmapä¸­ç›¸å¯¹åº”ä½ï¼Œå¦‚æœæ˜¯00å˜01ï¼Œ01å˜10ï¼Œ10ä¿æŒä¸å˜ã€‚æ‰€æå®Œäº‹åï¼ŒæŸ¥çœ‹bitmapï¼ŒæŠŠå¯¹åº”ä½æ˜¯01çš„æ•´æ•°è¾“å‡ºå³å¯ã€‚ 7. ç»™40äº¿ä¸ªä¸é‡å¤çš„unsigned intçš„æ•´æ•°ï¼Œæ²¡æ’è¿‡åºçš„ï¼Œç„¶åå†ç»™ä¸€ä¸ªæ•°ï¼Œå¦‚ä½•å¿«é€Ÿåˆ¤æ–­è¿™ä¸ªæ•°æ˜¯å¦åœ¨é‚£40äº¿ä¸ªæ•°å½“ä¸­ï¼Ÿç®—æ³•æ€æƒ³ï¼šBitMap ç”³è¯·512Mçš„å†…å­˜ï¼Œä¸€ä¸ªbitä½ä»£è¡¨ä¸€ä¸ªunsigned intå€¼ã€‚è¯»å…¥40äº¿ä¸ªæ•°ï¼Œè®¾ç½®ç›¸åº”çš„bitä½ï¼Œè¯»å…¥è¦æŸ¥è¯¢çš„æ•°ï¼ŒæŸ¥çœ‹ç›¸åº”bitä½æ˜¯å¦ä¸º1ï¼Œä¸º1è¡¨ç¤ºå­˜åœ¨ï¼Œä¸º0è¡¨ç¤ºä¸å­˜åœ¨ã€‚ å‚è€ƒèµ„æ–™ https://www.jianshu.com/p/ac5cad6d64a8","categories":[{"name":"Tech","slug":"Tech","permalink":"https://leel0330.github.io/categories/Tech/"}],"tags":[]},{"title":"å‰‘æŒ‡Offeré€‰é¢˜é¢˜è§£","slug":"å‰‘æŒ‡Offer","date":"2021-02-28T04:28:04.000Z","updated":"2021-02-28T04:58:03.664Z","comments":false,"path":"posts/3717340568.html","link":"","permalink":"https://leel0330.github.io/posts/3717340568.html","excerpt":"æŠŠå‰‘æŒ‡Offerçš„é¢˜è¿‡äº†ä¸€éï¼Œåœ¨è¿™é‡Œæ±‡æ€»ä¸€ä¸‹ã€‚","text":"æŠŠå‰‘æŒ‡Offerçš„é¢˜è¿‡äº†ä¸€éï¼Œåœ¨è¿™é‡Œæ±‡æ€»ä¸€ä¸‹ã€‚ é¢è¯•é¢˜07. é‡å»ºäºŒå‰æ ‘è¾“å…¥æŸäºŒå‰æ ‘çš„å‰åºéå†å’Œä¸­åºéå†çš„ç»“æœï¼Œè¯·é‡å»ºè¯¥äºŒå‰æ ‘ã€‚å‡è®¾è¾“å…¥çš„å‰åºéå†å’Œä¸­åºéå†çš„ç»“æœä¸­éƒ½ä¸å«é‡å¤çš„æ•°å­—ã€‚ ä¾‹å¦‚ï¼Œç»™å‡º å‰åºéå† preorder = [3,9,20,15,7] ä¸­åºéå† inorder = [9,3,15,20,7] è¿”å›å¦‚ä¸‹çš„äºŒå‰æ ‘ï¼š 3 / \\ 9 20 / \\ 15 7 é™åˆ¶ï¼š 0 &lt;= èŠ‚ç‚¹ä¸ªæ•° &lt;= 5000 PythonCpp12345678910111213141516171819202122class Solution(object): def buildTree(self, preorder, inorder): &quot;&quot;&quot; :type preorder: List[int] :type inorder: List[int] :rtype: TreeNode &quot;&quot;&quot; m = &#123;&#125; for idx, v in enumerate(inorder): m[v] = idx return self.helper(preorder, 0, len(preorder) - 1, inorder, 0, len(inorder) - 1, m) def helper(self, preorder, pre_s, pre_e, inorder, in_s, in_e, m): if pre_s &gt; pre_e or in_s &gt; in_e: return None root_v = preorder[pre_s] root_idx = m[root_v] left_len = root_idx - in_s root = TreeNode(root_v) root.left = self.helper(preorder, pre_s + 1, pre_s + left_len, inorder, in_s, root_idx - 1, m) root.right = self.helper(preorder, pre_s + left_len + 1, pre_e, inorder, root_idx + 1, in_e, m) return root1234567891011121314151617181920212223242526272829class Solution&#123;public: TreeNode *buildTree(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder) &#123; unordered_map&lt;int, int&gt; m; for (int i = 0; i &lt; inorder.size(); i++) &#123; m[inorder[i]] = i; &#125; return helper(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1, m); &#125; TreeNode *helper(vector&lt;int&gt; &amp;preorder, int pLeft, int pRight, vector&lt;int&gt; &amp;inorder, int iLeft, int iRight, unordered_map&lt;int, int&gt;&amp; m) &#123; if (pLeft &gt; pRight || iLeft &gt; iRight) &#123; return nullptr; &#125; int rootV = preorder[pLeft]; int rootIdx = m[rootV]; int leftLen = rootIdx - iLeft; TreeNode *root = new TreeNode(rootV); root-&gt;left = helper(preorder, pLeft + 1, pLeft + leftLen, inorder, iLeft, rootIdx - 1, m); root-&gt;right = helper(preorder, pLeft + leftLen + 1, pRight, inorder, rootIdx + 1, iRight, m); return root; &#125;&#125;; é¢è¯•é¢˜11. æ—‹è½¬æ•°ç»„çš„æœ€å°æ•°å­—æŠŠä¸€ä¸ªæ•°ç»„æœ€å¼€å§‹çš„è‹¥å¹²ä¸ªå…ƒç´ æ¬åˆ°æ•°ç»„çš„æœ«å°¾ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºæ•°ç»„çš„æ—‹è½¬ã€‚è¾“å…¥ä¸€ä¸ªé€’å¢æ’åºçš„æ•°ç»„çš„ä¸€ä¸ªæ—‹è½¬ï¼Œè¾“å‡ºæ—‹è½¬æ•°ç»„çš„æœ€å°å…ƒç´ ã€‚ä¾‹å¦‚ï¼Œæ•°ç»„ [3,4,5,1,2] ä¸º [1,2,3,4,5] çš„ä¸€ä¸ªæ—‹è½¬ï¼Œè¯¥æ•°ç»„çš„æœ€å°å€¼ä¸º1ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼š[3,4,5,1,2] è¾“å‡ºï¼š1 ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼š[2,2,2,0,1] è¾“å‡ºï¼š0 PythonCpp123456789101112131415161718class Solution(object): def minArray(self, numbers): &quot;&quot;&quot; :type numbers: List[int] :rtype: int &quot;&quot;&quot; if numbers is None or len(numbers) == 0: return -1 left, right = 0, len(numbers) - 1 while left &lt; right: mid = (left + right) / 2 if numbers[mid] &lt; numbers[right]: right = mid elif numbers[mid] == numbers[right]: right -= 1 else: left = mid + 1 return numbers[left]123456789101112131415161718192021222324252627282930class Solution&#123;public: int minArray(vector&lt;int&gt; &amp;numbers) &#123; if (numbers.size() == 0) &#123; return -1; &#125; int n = numbers.size(); int left = 0, right = n - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (numbers[mid] &lt; numbers[right]) &#123; right = mid; &#125; else if (numbers[mid] == numbers[right]) &#123; right -= 1; &#125; else &#123; left = mid + 1; &#125; &#125; return numbers[left]; &#125;&#125;; é¢è¯•é¢˜14- I. å‰ªç»³å­ [n]ç»™ä½ ä¸€æ ¹é•¿åº¦ä¸º n çš„ç»³å­ï¼Œè¯·æŠŠç»³å­å‰ªæˆæ•´æ•°é•¿åº¦çš„ m æ®µï¼ˆmã€néƒ½æ˜¯æ•´æ•°ï¼Œn&gt;1å¹¶ä¸”m&gt;1ï¼‰ï¼Œæ¯æ®µç»³å­çš„é•¿åº¦è®°ä¸º k[0],k[1]â€¦k[m] ã€‚è¯·é—® k[0]k[1]â€¦*k[m] å¯èƒ½çš„æœ€å¤§ä¹˜ç§¯æ˜¯å¤šå°‘ï¼Ÿä¾‹å¦‚ï¼Œå½“ç»³å­çš„é•¿åº¦æ˜¯8æ—¶ï¼Œæˆ‘ä»¬æŠŠå®ƒå‰ªæˆé•¿åº¦åˆ†åˆ«ä¸º2ã€3ã€3çš„ä¸‰æ®µï¼Œæ­¤æ—¶å¾—åˆ°çš„æœ€å¤§ä¹˜ç§¯æ˜¯18ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥: 2 è¾“å‡º: 1 è§£é‡Š: 2 = 1 + 1, 1 Ã— 1 = 1 ç¤ºä¾‹ 2: è¾“å…¥: 10 è¾“å‡º: 36 è§£é‡Š: 10 = 3 + 3 + 4, 3 Ã— 3 Ã— 4 = 36 æç¤ºï¼š 2 &lt;= n &lt;= 58 PythonCpp12345678910111213141516171819class Solution(object): def cuttingRope(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; cache = [0 for i in xrange(n + 1)] return self.helper(n, cache) def helper(self, n, cache): if n == 2: return 1 if cache[n] != 0: return cache[n] res = -1 for i in xrange(1, n): res = max(res, i * (n - i), i * self.helper(n - i, cache)) cache[n] = res return res12345678910111213141516171819202122232425262728class Solution&#123;public: int cuttingRope(int n) &#123; vector&lt;int&gt; cache(n + 1, 0); return helper(n, cache); &#125; int helper(int n, vector&lt;int&gt; &amp;cache) &#123; int res = 0; if (n == 2) &#123; return 1; &#125; if (cache[n] != 0) &#123; return cache[n]; &#125; for (int i = 1; i &lt; n; i++) &#123; int v = max(i * (n - i), i * helper(n - i, cache)); res = max(res, v); &#125; cache[n] = res; return res; &#125;&#125;; é¢è¯•é¢˜19. æ­£åˆ™è¡¨è¾¾å¼åŒ¹é… [n]è¯·å®ç°ä¸€ä¸ªå‡½æ•°ç”¨æ¥åŒ¹é…åŒ…å«â€™. â€˜å’Œâ€™â€˜çš„æ­£åˆ™è¡¨è¾¾å¼ã€‚æ¨¡å¼ä¸­çš„å­—ç¬¦â€™.â€™è¡¨ç¤ºä»»æ„ä¸€ä¸ªå­—ç¬¦ï¼Œè€Œâ€™â€˜è¡¨ç¤ºå®ƒå‰é¢çš„å­—ç¬¦å¯ä»¥å‡ºç°ä»»æ„æ¬¡ï¼ˆå«0æ¬¡ï¼‰ã€‚åœ¨æœ¬é¢˜ä¸­ï¼ŒåŒ¹é…æ˜¯æŒ‡å­—ç¬¦ä¸²çš„æ‰€æœ‰å­—ç¬¦åŒ¹é…æ•´ä¸ªæ¨¡å¼ã€‚ä¾‹å¦‚ï¼Œå­—ç¬¦ä¸²â€aaaâ€ä¸æ¨¡å¼â€a.aâ€å’Œâ€abacaâ€åŒ¹é…ï¼Œä½†ä¸â€aa.aâ€å’Œâ€ab*aâ€å‡ä¸åŒ¹é…ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: s = \"aa\" p = \"a\" è¾“å‡º: false è§£é‡Š: \"a\" æ— æ³•åŒ¹é… \"aa\" æ•´ä¸ªå­—ç¬¦ä¸²ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: s = \"aa\" p = \"a*\" è¾“å‡º: true è§£é‡Š: å› ä¸º '*' ä»£è¡¨å¯ä»¥åŒ¹é…é›¶ä¸ªæˆ–å¤šä¸ªå‰é¢çš„é‚£ä¸€ä¸ªå…ƒç´ , åœ¨è¿™é‡Œå‰é¢çš„å…ƒç´ å°±æ˜¯ 'a'ã€‚å› æ­¤ï¼Œå­—ç¬¦ä¸² \"aa\" å¯è¢«è§†ä¸º 'a' é‡å¤äº†ä¸€æ¬¡ã€‚ ç¤ºä¾‹ 3: è¾“å…¥: s = \"ab\" p = \".*\" è¾“å‡º: true è§£é‡Š: \".*\" è¡¨ç¤ºå¯åŒ¹é…é›¶ä¸ªæˆ–å¤šä¸ªï¼ˆ'*'ï¼‰ä»»æ„å­—ç¬¦ï¼ˆ'.'ï¼‰ã€‚ ç¤ºä¾‹ 4: è¾“å…¥: s = \"aab\" p = \"c*a*b\" è¾“å‡º: true è§£é‡Š: å› ä¸º '*' è¡¨ç¤ºé›¶ä¸ªæˆ–å¤šä¸ªï¼Œè¿™é‡Œ 'c' ä¸º 0 ä¸ª, 'a' è¢«é‡å¤ä¸€æ¬¡ã€‚å› æ­¤å¯ä»¥åŒ¹é…å­—ç¬¦ä¸² \"aab\"ã€‚ ç¤ºä¾‹ 5: è¾“å…¥: s = \"mississippi\" p = \"mis*is*p*.\" è¾“å‡º: false s å¯èƒ½ä¸ºç©ºï¼Œä¸”åªåŒ…å«ä» a-z çš„å°å†™å­—æ¯ã€‚ p å¯èƒ½ä¸ºç©ºï¼Œä¸”åªåŒ…å«ä» a-z çš„å°å†™å­—æ¯ï¼Œä»¥åŠå­—ç¬¦ . å’Œ *ã€‚ 1234567891011121314class Solution(object): def isMatch(self, s, p): &quot;&quot;&quot; :type s: str :type p: str :rtype: bool &quot;&quot;&quot; if not p: return not s first_match = bool(s) and p[0] in [s[0], &#x27;.&#x27;] if len(p) &gt;= 2 and p[1] == &#x27;*&#x27;: return (self.isMatch(s, p[2:])) or (first_match and self.isMatch(s[1:], p)) else: return first_match and self.isMatch(s[1:], p[1:]) é¢è¯•é¢˜26. æ ‘çš„å­ç»“æ„è¾“å…¥ä¸¤æ£µäºŒå‰æ ‘Aå’ŒBï¼Œåˆ¤æ–­Bæ˜¯ä¸æ˜¯Açš„å­ç»“æ„ã€‚(çº¦å®šç©ºæ ‘ä¸æ˜¯ä»»æ„ä¸€ä¸ªæ ‘çš„å­ç»“æ„) Bæ˜¯Açš„å­ç»“æ„ï¼Œ å³ Aä¸­æœ‰å‡ºç°å’ŒBç›¸åŒçš„ç»“æ„å’ŒèŠ‚ç‚¹å€¼ã€‚ ä¾‹å¦‚: ç»™å®šçš„æ ‘ A: 3 / \\ 4 5 / \\ 1 2 ç»™å®šçš„æ ‘ Bï¼š 4 / 1 è¿”å› trueï¼Œå› ä¸º B ä¸ A çš„ä¸€ä¸ªå­æ ‘æ‹¥æœ‰ç›¸åŒçš„ç»“æ„å’ŒèŠ‚ç‚¹å€¼ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šA = [1,2,3], B = [3,1] è¾“å‡ºï¼šfalse ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šA = [3,4,5,1,2], B = [4,1] è¾“å‡ºï¼štrue é™åˆ¶ï¼š 0 &lt;= èŠ‚ç‚¹ä¸ªæ•° &lt;= 10000 PythonCpp1234567891011121314151617class Solution(object): def isSubStructure(self, A, B): &quot;&quot;&quot; :type A: TreeNode :type B: TreeNode :rtype: bool &quot;&quot;&quot; if A is None or B is None: return False return self.helper(A, B) or self.isSubStructure(A.left, B) or self.isSubStructure(A.right, B) def helper(self, A, B): if A is None or B is None: return True if B is None else False if A.val != B.val: return False return self.helper(A.left, B.left) and self.helper(A.right, B.right)12345678910111213141516171819202122232425class Solution&#123;public: bool isSubStructure(TreeNode *A, TreeNode *B) &#123; if (A == nullptr || B == nullptr) &#123; return false; &#125; return helper(A, B) || isSubStructure(A-&gt;left, B) || isSubStructure(A-&gt;right, B); &#125; bool helper(TreeNode *A, TreeNode *B) &#123; if (A == nullptr || B == nullptr) &#123; return B == nullptr ? true : false; &#125; if (A-&gt;val != B-&gt;val) &#123; return false; &#125; return helper(A-&gt;left, B-&gt;left) &amp;&amp; helper(A-&gt;right, B-&gt;right); &#125;&#125;; é¢è¯•é¢˜27. äºŒå‰æ ‘çš„é•œåƒè¯·å®Œæˆä¸€ä¸ªå‡½æ•°ï¼Œè¾“å…¥ä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¯¥å‡½æ•°è¾“å‡ºå®ƒçš„é•œåƒã€‚ ä¾‹å¦‚è¾“å…¥ï¼š 4 / \\ 2 7 / \\ / \\ 1 3 6 9 é•œåƒè¾“å‡ºï¼š 4 / \\ 7 2 / \\ / \\ 9 6 3 1 ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šroot = [4,2,7,1,3,6,9] è¾“å‡ºï¼š[4,7,2,9,6,3,1] é™åˆ¶ï¼š 0 &lt;= èŠ‚ç‚¹ä¸ªæ•° &lt;= 1000 PythonCpp12345678910111213141516171819class Solution(object): def mirrorTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; if root is None: return root queue = [root] while queue: sz = len(queue) for i in xrange(sz): node = queue.pop(0) node.left, node.right = node.right, node.left if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root123456789101112131415161718192021222324252627282930class Solution&#123;public: TreeNode *mirrorTree(TreeNode *root) &#123; if (root == nullptr) &#123; return root; &#125; queue&lt;TreeNode *&gt; treeQ; treeQ.push(root); while (!treeQ.empty()) &#123; TreeNode *node = treeQ.front(); treeQ.pop(); swap(node-&gt;left, node-&gt;right); if (node-&gt;left) &#123; treeQ.push(node-&gt;left); &#125; if (node-&gt;right) &#123; treeQ.push(node-&gt;right); &#125; &#125; return root; &#125;&#125;; é¢è¯•é¢˜28. å¯¹ç§°çš„äºŒå‰æ ‘è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨æ¥åˆ¤æ–­ä¸€æ£µäºŒå‰æ ‘æ˜¯ä¸æ˜¯å¯¹ç§°çš„ã€‚å¦‚æœä¸€æ£µäºŒå‰æ ‘å’Œå®ƒçš„é•œåƒä¸€æ ·ï¼Œé‚£ä¹ˆå®ƒæ˜¯å¯¹ç§°çš„ã€‚ ä¾‹å¦‚ï¼ŒäºŒå‰æ ‘ [1,2,2,3,4,4,3] æ˜¯å¯¹ç§°çš„ã€‚ 1 / \\ 2 2 / \\ / \\ 3 4 4 3 ä½†æ˜¯ä¸‹é¢è¿™ä¸ª [1,2,2,null,3,null,3] åˆ™ä¸æ˜¯é•œåƒå¯¹ç§°çš„: 1 / \\ 2 2 \\ \\ 3 3 ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šroot = [1,2,2,3,4,4,3] è¾“å‡ºï¼štrue ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šroot = [1,2,2,null,3,null,3] è¾“å‡ºï¼šfalse é™åˆ¶ï¼š 0 &lt;= èŠ‚ç‚¹ä¸ªæ•° &lt;= 1000 PythonCpp12345678910111213141516class Solution(object): def isSymmetric(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; return self.helper(root, root) def helper(self, rootA, rootB): if rootA is None and rootB is None: return True if rootA is None or rootB is None: return False if rootA.val != rootB.val: return False return self.helper(rootA.left, rootB.right) and self.helper(rootA.right, rootB.left)12345678910111213141516171819202122232425class Solution&#123;public: bool isSymmetric(TreeNode *root) &#123; return helper(root, root); &#125; bool helper(TreeNode *p, TreeNode *q) &#123; if (p == nullptr &amp;&amp; q == nullptr) &#123; return true; &#125; if (p == nullptr || q == nullptr) &#123; return false; &#125; if (p-&gt;val != q-&gt;val) &#123; return false; &#125; return helper(p-&gt;left, q-&gt;right) &amp;&amp; helper(p-&gt;right, q-&gt;left); &#125;&#125;; é¢è¯•é¢˜29. é¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µè¾“å…¥ä¸€ä¸ªçŸ©é˜µï¼ŒæŒ‰ç…§ä»å¤–å‘é‡Œä»¥é¡ºæ—¶é’ˆçš„é¡ºåºä¾æ¬¡æ‰“å°å‡ºæ¯ä¸€ä¸ªæ•°å­—ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šmatrix = [[1,2,3],[4,5,6],[7,8,9]] è¾“å‡ºï¼š[1,2,3,6,9,8,7,4,5] ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šmatrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] è¾“å‡ºï¼š[1,2,3,4,8,12,11,10,9,5,6,7] é™åˆ¶ï¼š 0 &lt;= matrix.length &lt;= 100 0 &lt;= matrix[i].length &lt;= 100 123456789101112131415161718192021222324252627282930313233class Solution(object): def spiralOrder(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: List[int] &quot;&quot;&quot; if matrix is None or len(matrix) == 0 or len(matrix[0]) == 0: return [] m, n = len(matrix), len(matrix[0]) res = [] top, bottom, left, right = 0, m - 1, 0, n - 1 while True: for i in xrange(left, right + 1): res.append(matrix[top][i]) top += 1 if top &gt; bottom: break for i in xrange(top, bottom + 1): res.append(matrix[i][right]) right -= 1 if right &lt; left: break for i in xrange(right, left - 1, -1): res.append(matrix[bottom][i]) bottom -= 1 if bottom &lt; top: break for i in xrange(bottom, top - 1, -1): res.append(matrix[i][left]) left += 1 if left &gt; right: break return res é¢è¯•é¢˜33. äºŒå‰æœç´¢æ ‘çš„ååºéå†åºåˆ—è¾“å…¥ä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œåˆ¤æ–­è¯¥æ•°ç»„æ˜¯ä¸æ˜¯æŸäºŒå‰æœç´¢æ ‘çš„ååºéå†ç»“æœã€‚å¦‚æœæ˜¯åˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚å‡è®¾è¾“å…¥çš„æ•°ç»„çš„ä»»æ„ä¸¤ä¸ªæ•°å­—éƒ½äº’ä¸ç›¸åŒã€‚ å‚è€ƒä»¥ä¸‹è¿™é¢—äºŒå‰æœç´¢æ ‘ï¼š 5 / \\ 2 6 / \\ 1 3 ç¤ºä¾‹ 1ï¼š è¾“å…¥: [1,6,3,2,5] è¾“å‡º: false ç¤ºä¾‹ 2ï¼š è¾“å…¥: [1,3,2,6,5] è¾“å‡º: true æç¤ºï¼š æ•°ç»„é•¿åº¦ &lt;= 1000 PythonCpp12345678910111213141516171819202122class Solution(object): def verifyPostorder(self, postorder): &quot;&quot;&quot; :type postorder: List[int] :rtype: bool &quot;&quot;&quot; n = len(postorder) if n == 0 or n == 1: return True return self.helper(postorder, 0, n - 1) def helper(self, postorder, left, right): if left &gt;= right: return True root_v = postorder[right] i = left while postorder[i] &lt; root_v: i += 1 for j in xrange(i, right): if postorder[j] &lt;= root_v: return False return self.helper(postorder, left, i - 1) and self.helper(postorder, i, right - 1)123456789101112131415161718192021222324252627282930class Solution&#123;public: bool verifyPostorder(vector&lt;int&gt; &amp;postorder) &#123; return helper(postorder, 0, postorder.size() - 1); &#125; bool helper(vector&lt;int&gt; &amp;postorder, int left, int right) &#123; if (left &gt;= right) &#123; return true; &#125; int rootV = postorder[right]; int left_end = left; while (left_end &lt; right &amp;&amp; postorder[left_end] &lt; rootV) &#123; left_end += 1; &#125; for (int i = left_end; i &lt; right; i++) &#123; if (postorder[i] &lt;= rootV) &#123; return false; &#125; &#125; return helper(postorder, left, left_end - 1) &amp;&amp; helper(postorder, left_end, right - 1); &#125;&#125;; é¢è¯•é¢˜36. äºŒå‰æœç´¢æ ‘ä¸åŒå‘é“¾è¡¨ [n]è¾“å…¥ä¸€æ£µäºŒå‰æœç´¢æ ‘ï¼Œå°†è¯¥äºŒå‰æœç´¢æ ‘è½¬æ¢æˆä¸€ä¸ªæ’åºçš„å¾ªç¯åŒå‘é“¾è¡¨ã€‚è¦æ±‚ä¸èƒ½åˆ›å»ºä»»ä½•æ–°çš„èŠ‚ç‚¹ï¼Œåªèƒ½è°ƒæ•´æ ‘ä¸­èŠ‚ç‚¹æŒ‡é’ˆçš„æŒ‡å‘ã€‚ PythonCpp1234567891011121314151617181920212223242526272829class Solution(object): def __init__(self): self.head = None self.prev = None self.tail = None def treeToDoublyList(self, root): &quot;&quot;&quot; :type root: Node :rtype: Node &quot;&quot;&quot; if root is None: return root self.inorder(root) self.head.left = self.tail self.tail.right = self.head return self.head def inorder(self, root): if root is None: return self.inorder(root.left) if self.prev is None: self.head = root else: self.prev.right = root root.left = self.prev self.prev = root self.tail = root self.inorder(root.right)123456789101112131415161718192021222324252627282930313233343536373839class Solution&#123;public: Node *treeToDoublyList(Node *root) &#123; if (root == nullptr) &#123; return root; &#125; inorder(root); _head-&gt;left = _tail; _tail-&gt;right = _head; return _head; &#125; void inorder(Node *root) &#123; if (root == nullptr) &#123; return; &#125; inorder(root-&gt;left); if (_prev == nullptr) &#123; _head = root; &#125; else &#123; _prev-&gt;right = root; &#125; root-&gt;left = _prev; _prev = root; _tail = root; inorder(root-&gt;right); &#125;private: Node *_head, *_tail, *_prev;&#125;; é¢è¯•é¢˜37. åºåˆ—åŒ–äºŒå‰æ ‘ [n]è¯·å®ç°ä¸¤ä¸ªå‡½æ•°ï¼Œåˆ†åˆ«ç”¨æ¥åºåˆ—åŒ–å’Œååºåˆ—åŒ–äºŒå‰æ ‘ã€‚ ç¤ºä¾‹: ä½ å¯ä»¥å°†ä»¥ä¸‹äºŒå‰æ ‘ï¼š 1 / \\ 2 3 / \\ 4 5 åºåˆ—åŒ–ä¸º \"[1,2,3,null,null,4,5]\" PythonCpp12345678910111213141516171819202122232425262728293031323334353637class Codec: def serialize(self, root): &quot;&quot;&quot;Encodes a tree to a single string. :type root: TreeNode :rtype: str &quot;&quot;&quot; res = [] def preorder(root): if root is None: res.append(&#x27;null&#x27;) else: res.append(str(root.val)) preorder(root.left) preorder(root.right) preorder(root) return &#x27;,&#x27;.join(res) def deserialize(self, data): &quot;&quot;&quot;Decodes your encoded data to tree. :type data: str :rtype: TreeNode &quot;&quot;&quot; res = data.split(&#x27;,&#x27;) def buildTree(): if res: val = res.pop(0) if val == &#x27;null&#x27;: return None root = TreeNode(int(val)) root.left = buildTree() root.right = buildTree() return root return buildTree()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Codec&#123;public: // Encodes a tree to a single string. string serialize(TreeNode *root) &#123; string res; tree2str(root, res); return res; &#125; void tree2str(TreeNode *root, string &amp;res) &#123; if (root == nullptr) &#123; res += &quot;# &quot;; return; &#125; res += std::to_string(root-&gt;val) + &quot; &quot;; tree2str(root-&gt;left, res); tree2str(root-&gt;right, res); &#125; // Decodes your encoded data to tree. TreeNode *deserialize(string data) &#123; int idx = 0; return str2tree(data, idx); &#125; TreeNode *str2tree(string data, int &amp;idx) &#123; if (idx == data.size()) &#123; return nullptr; &#125; int endIdx = idx; while (data[endIdx] != &#x27; &#x27;) &#123; endIdx += 1; &#125; if (data[idx] == &#x27;#&#x27;) &#123; idx = endIdx + 1; return nullptr; &#125; int val = 0; bool sign = false; if(data[idx] == &#x27;-&#x27;) &#123; idx = idx + 1; sign = true; &#125; for (int i = idx; i &lt; endIdx; i++) &#123; val = val * 10 + (data[i] - &#x27;0&#x27;); &#125; val = sign ? -val:val; idx = endIdx + 1; TreeNode *root = new TreeNode(val); root-&gt;left = str2tree(data, idx); root-&gt;right = str2tree(data, idx); return root; &#125;&#125;; é¢è¯•é¢˜44. æ•°å­—åºåˆ—ä¸­æŸä¸€ä½çš„æ•°å­—æ•°å­—ä»¥0123456789101112131415â€¦çš„æ ¼å¼åºåˆ—åŒ–åˆ°ä¸€ä¸ªå­—ç¬¦åºåˆ—ä¸­ã€‚åœ¨è¿™ä¸ªåºåˆ—ä¸­ï¼Œç¬¬5ä½ï¼ˆä»ä¸‹æ ‡0å¼€å§‹è®¡æ•°ï¼‰æ˜¯5ï¼Œç¬¬13ä½æ˜¯1ï¼Œç¬¬19ä½æ˜¯4ï¼Œç­‰ç­‰ã€‚ è¯·å†™ä¸€ä¸ªå‡½æ•°ï¼Œæ±‚ä»»æ„ç¬¬nä½å¯¹åº”çš„æ•°å­—ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šn = 3 è¾“å‡ºï¼š3 ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šn = 11 è¾“å‡ºï¼š0 é™åˆ¶ï¼š 0 &lt;= n &lt; 2^31 123456789101112131415161718class Solution(object): def findNthDigit(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; if n == 0: return 0 _len = 1 cnt = 9 start = 1 while n &gt; _len * cnt: n -= _len * cnt _len += 1 cnt *= 10 start *= 10 start += (n - 1) / _len return int(str(start)[(n - 1) % _len]) é¢è¯•é¢˜46. æŠŠæ•°å­—ç¿»è¯‘æˆå­—ç¬¦ä¸² [n]ç»™å®šä¸€ä¸ªæ•°å­—ï¼Œæˆ‘ä»¬æŒ‰ç…§å¦‚ä¸‹è§„åˆ™æŠŠå®ƒç¿»è¯‘ä¸ºå­—ç¬¦ä¸²ï¼š0 ç¿»è¯‘æˆ â€œaâ€ ï¼Œ1 ç¿»è¯‘æˆ â€œbâ€ï¼Œâ€¦â€¦ï¼Œ11 ç¿»è¯‘æˆ â€œlâ€ï¼Œâ€¦â€¦ï¼Œ25 ç¿»è¯‘æˆ â€œzâ€ã€‚ä¸€ä¸ªæ•°å­—å¯èƒ½æœ‰å¤šä¸ªç¿»è¯‘ã€‚è¯·ç¼–ç¨‹å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨æ¥è®¡ç®—ä¸€ä¸ªæ•°å­—æœ‰å¤šå°‘ç§ä¸åŒçš„ç¿»è¯‘æ–¹æ³•ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: 12258 è¾“å‡º: 5 è§£é‡Š: 12258æœ‰5ç§ä¸åŒçš„ç¿»è¯‘ï¼Œåˆ†åˆ«æ˜¯\"bccfi\", \"bwfi\", \"bczi\", \"mcfi\"å’Œ\"mzi\" æç¤ºï¼š 0 &lt;= num &lt; 231 PythonCpp12345678910111213141516171819class Solution(object): def translateNum(self, num): &quot;&quot;&quot; :type num: int :rtype: int &quot;&quot;&quot; num_str = str(num) slen = len(num_str) dp = [0 for i in xrange(slen + 1)] dp[0] = 1 dp[1] = 1 for i in xrange(2, slen + 1): a = num_str[i - 2:i] b = num_str[i - 1:i] if 10 &lt;= int(a) &lt;= 25: dp[i] += dp[i - 2] if 0 &lt;= int(b) &lt;= 9: dp[i] += dp[i - 1] return dp[slen]12345678910111213141516171819202122232425262728class Solution&#123;public: int translateNum(int num) &#123; string num_str = std::to_string(num); int sLen = num_str.size(); vector&lt;int&gt; dp(sLen + 1, 0); dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;= sLen; i++) &#123; string a = num_str.substr(i - 2, 2); string b = num_str.substr(i - 1, 1); int m = std::stoi(a); int n = std::stoi(b); if (m &gt;= 10 &amp;&amp; m &lt;= 25) &#123; dp[i] += dp[i - 2]; &#125; if (n &gt;= 0 &amp;&amp; n &lt;= 9) &#123; dp[i] += dp[i - 1]; &#125; &#125; return dp[sLen]; &#125;&#125;; é¢è¯•é¢˜49. ä¸‘æ•°æˆ‘ä»¬æŠŠåªåŒ…å«å› å­ 2ã€3 å’Œ 5 çš„æ•°ç§°ä½œä¸‘æ•°ï¼ˆUgly Numberï¼‰ã€‚æ±‚æŒ‰ä»å°åˆ°å¤§çš„é¡ºåºçš„ç¬¬ n ä¸ªä¸‘æ•°ã€‚ ç¤ºä¾‹: è¾“å…¥: n = 10 è¾“å‡º: 12 è§£é‡Š: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 æ˜¯å‰ 10 ä¸ªä¸‘æ•°ã€‚ è¯´æ˜: 1 æ˜¯ä¸‘æ•°ã€‚ n ä¸è¶…è¿‡1690ã€‚ PythonCpp123456789101112131415161718class Solution(object): def nthUglyNumber(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; dp = [1 for i in xrange(n)] i2, i3, i5 = 0, 0, 0 for i in xrange(1, n): min_v = min(dp[i2] * 2, dp[i3] * 3, dp[i5] * 5) dp[i] = min_v if min_v == dp[i2] * 2: i2 += 1 if min_v == dp[i3] * 3: i3 += 1 if min_v == dp[i5] * 5: i5 += 1 return dp[n - 1]123456789101112131415161718192021222324252627class Solution&#123;public: int nthUglyNumber(int n) &#123; vector&lt;int&gt; dp(n, 1); int i2 = 0, i3 = 0, i5 = 0; for (int i = 1; i &lt; n; i++) &#123; int min_v = min(min(dp[i2] * 2, dp[i3] * 3), dp[i5] * 5); dp[i] = min_v; if (min_v == dp[i2] * 2) &#123; i2 += 1; &#125; if (min_v == dp[i3] * 3) &#123; i3 += 1; &#125; if (min_v == dp[i5] * 5) &#123; i5 += 1; &#125; &#125; return dp[n - 1]; &#125;&#125;; é¢è¯•é¢˜56 - II. æ•°ç»„ä¸­æ•°å­—å‡ºç°çš„æ¬¡æ•° [n]åœ¨ä¸€ä¸ªæ•°ç»„ nums ä¸­é™¤ä¸€ä¸ªæ•°å­—åªå‡ºç°ä¸€æ¬¡ä¹‹å¤–ï¼Œå…¶ä»–æ•°å­—éƒ½å‡ºç°äº†ä¸‰æ¬¡ã€‚è¯·æ‰¾å‡ºé‚£ä¸ªåªå‡ºç°ä¸€æ¬¡çš„æ•°å­—ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šnums = [3,4,3,3] è¾“å‡ºï¼š4 ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šnums = [9,1,7,9,7,9,7] è¾“å‡ºï¼š1 é™åˆ¶ï¼š 1 &lt;= nums.length &lt;= 10000 1 &lt;= nums[i] &lt; 2^31 PythonCpp123456789101112131415161718class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; res = 0 for i in range(32): cnt = 0 # è®°å½•å½“å‰ bit æœ‰å¤šå°‘ä¸ª1 bit = 1 &lt;&lt; i # è®°å½•å½“å‰è¦æ“ä½œçš„ bit for num in nums: if num &amp; bit != 0: cnt += 1 if cnt % 3 != 0: # ä¸ç­‰äº0è¯´æ˜å”¯ä¸€å‡ºç°çš„æ•°å­—åœ¨è¿™ä¸ª bit ä¸Šæ˜¯1 res |= bit return res - 2 ** 32 if res &gt; 2 ** 31 - 1 else res12345678910111213141516171819202122232425class Solution&#123;public: int singleNumber(vector&lt;int&gt; &amp;nums) &#123; int res = 0; for (int i = 0; i &lt; 32; i++) &#123; int bit = 1 &lt;&lt; i; int cnt = 0; for (auto n : nums) &#123; if ((n &amp; bit) != 0) &#123; cnt += 1; &#125; &#125; if (cnt % 3 != 0) &#123; res |= bit; &#125; &#125; return res; &#125;&#125;; é¢è¯•é¢˜57 - II. å’Œä¸ºsçš„è¿ç»­æ­£æ•°åºåˆ— [n]è¾“å…¥ä¸€ä¸ªæ­£æ•´æ•° target ï¼Œè¾“å‡ºæ‰€æœ‰å’Œä¸º target çš„è¿ç»­æ­£æ•´æ•°åºåˆ—ï¼ˆè‡³å°‘å«æœ‰ä¸¤ä¸ªæ•°ï¼‰ã€‚ åºåˆ—å†…çš„æ•°å­—ç”±å°åˆ°å¤§æ’åˆ—ï¼Œä¸åŒåºåˆ—æŒ‰ç…§é¦–ä¸ªæ•°å­—ä»å°åˆ°å¤§æ’åˆ—ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼štarget = 9 è¾“å‡ºï¼š[[2,3,4],[4,5]] ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼štarget = 15 è¾“å‡ºï¼š[[1,2,3,4,5],[4,5,6],[7,8]] é™åˆ¶ï¼š 1 &lt;= target &lt;= 10^5 PythonCpp123456789101112131415161718192021class Solution(object): def findContinuousSequence(self, target): &quot;&quot;&quot; :type target: int :rtype: List[List[int]] &quot;&quot;&quot; left, right, total = 1, 0, 0 res = [] flag = (target + 1) / 2 while right &lt;= flag: if total == target: res.append([i for i in xrange(left, right + 1)]) right += 1 total += right elif total &lt; target: right += 1 total += right else: total -= left left += 1 return res1234567891011121314151617181920212223242526272829303132333435class Solution&#123;public: vector&lt;vector&lt;int&gt;&gt; findContinuousSequence(int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; int left = 1, right = 0, total = 0; int flag = (target + 1) / 2; while (right &lt;= flag) &#123; if (total == target) &#123; vector&lt;int&gt; item; for (int i = left; i &lt;= right; i++) &#123; item.push_back(i); &#125; res.push_back(item); right += 1; total += right; &#125; else if (total &lt; target) &#123; right += 1; total += right; &#125; else &#123; total -= left; left += 1; &#125; &#125; return res; &#125;&#125;; é¢è¯•é¢˜59 - I. æ»‘åŠ¨çª—å£çš„æœ€å¤§å€¼ [n]ç»™å®šä¸€ä¸ªæ•°ç»„ nums å’Œæ»‘åŠ¨çª—å£çš„å¤§å° kï¼Œè¯·æ‰¾å‡ºæ‰€æœ‰æ»‘åŠ¨çª—å£é‡Œçš„æœ€å¤§å€¼ã€‚ ç¤ºä¾‹: è¾“å…¥: nums = [1,3,-1,-3,5,3,6,7], å’Œ k = 3 è¾“å‡º: [3,3,5,5,6,7] è§£é‡Š: æ»‘åŠ¨çª—å£çš„ä½ç½® æœ€å¤§å€¼ --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 æç¤ºï¼š ä½ å¯ä»¥å‡è®¾ k æ€»æ˜¯æœ‰æ•ˆçš„ï¼Œåœ¨è¾“å…¥æ•°ç»„ä¸ä¸ºç©ºçš„æƒ…å†µä¸‹ï¼Œ1 â‰¤ k â‰¤ è¾“å…¥æ•°ç»„çš„å¤§å°ã€‚ 1234567891011121314151617181920from collections import dequeclass Solution(object): def maxSlidingWindow(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: List[int] &quot;&quot;&quot; dq = deque() res = [] for i, v in enumerate(nums): while dq and dq[0] &lt;= i - k: dq.popleft() while dq and v &gt; nums[dq[-1]]: dq.pop() dq.append(i) if i &gt;= k - 1: res.append(nums[dq[0]]) return res é¢è¯•é¢˜62. åœ†åœˆä¸­æœ€åå‰©ä¸‹çš„æ•°å­— [n]0,1,,n-1è¿™nä¸ªæ•°å­—æ’æˆä¸€ä¸ªåœ†åœˆï¼Œä»æ•°å­—0å¼€å§‹ï¼Œæ¯æ¬¡ä»è¿™ä¸ªåœ†åœˆé‡Œåˆ é™¤ç¬¬mä¸ªæ•°å­—ã€‚æ±‚å‡ºè¿™ä¸ªåœ†åœˆé‡Œå‰©ä¸‹çš„æœ€åä¸€ä¸ªæ•°å­—ã€‚ ä¾‹å¦‚ï¼Œ0ã€1ã€2ã€3ã€4è¿™5ä¸ªæ•°å­—ç»„æˆä¸€ä¸ªåœ†åœˆï¼Œä»æ•°å­—0å¼€å§‹æ¯æ¬¡åˆ é™¤ç¬¬3ä¸ªæ•°å­—ï¼Œåˆ™åˆ é™¤çš„å‰4ä¸ªæ•°å­—ä¾æ¬¡æ˜¯2ã€0ã€4ã€1ï¼Œå› æ­¤æœ€åå‰©ä¸‹çš„æ•°å­—æ˜¯3ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥: n = 5, m = 3 è¾“å‡º: 3 ç¤ºä¾‹ 2ï¼š è¾“å…¥: n = 10, m = 17 è¾“å‡º: 2 é™åˆ¶ï¼š 1 &lt;= n &lt;= 10^5 1 &lt;= m &lt;= 10^6 PythonCpp12345678910111213class Solution(object): def lastRemaining(self, n, m): &quot;&quot;&quot; :type n: int :type m: int :rtype: int &quot;&quot;&quot; nums = [i for i in xrange(n)] c = (m - 1) % n while len(nums) != 1: nums.pop(c) c = (c + m - 1) % len(nums) return nums[0]12345678910111213class Solution&#123;public: int lastRemaining(int n, int m) &#123; int last = 0; for (int i = 2; i &lt;= n; i++) &#123; last = (last + m) % i; &#125; return last; &#125;&#125;; é¢è¯•é¢˜68 - II. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆç»™å®šä¸€ä¸ªäºŒå‰æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚ PythonCpp123456789101112131415class Solution(object): def lowestCommonAncestor(self, root, p, q): &quot;&quot;&quot; :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode &quot;&quot;&quot; if root is None or root == p or root == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if left and right: return root return left if left else right123456789101112131415161718class Solution&#123;public: TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) &#123; if (root == nullptr || root == p || root == q) &#123; return root; &#125; TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode *right = lowestCommonAncestor(root-&gt;right, p, q); if (left &amp;&amp; right) &#123; return root; &#125; return left == nullptr ? right : left; &#125;&#125;;","categories":[{"name":"Tech","slug":"Tech","permalink":"https://leel0330.github.io/categories/Tech/"}],"tags":[]},{"title":"LeetCodeä¹‹åŠ¨æ€è§„åˆ’(ä¸­ç­‰)","slug":"LeetCode-åŠ¨æ€è§„åˆ’-ä¸­ç­‰","date":"2021-02-26T12:13:18.000Z","updated":"2021-02-26T12:41:15.564Z","comments":false,"path":"posts/903350571.html","link":"","permalink":"https://leel0330.github.io/posts/903350571.html","excerpt":"åŠ¨æ€è§„åˆ’(ä¸­ç­‰)çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚","text":"åŠ¨æ€è§„åˆ’(ä¸­ç­‰)çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ 5. æœ€é•¿å›æ–‡å­ä¸²ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œæ‰¾åˆ° s ä¸­æœ€é•¿çš„å›æ–‡å­ä¸²ã€‚ä½ å¯ä»¥å‡è®¾ s çš„æœ€å¤§é•¿åº¦ä¸º 1000ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥: \"babad\" è¾“å‡º: \"bab\" æ³¨æ„: \"aba\" ä¹Ÿæ˜¯ä¸€ä¸ªæœ‰æ•ˆç­”æ¡ˆã€‚ ç¤ºä¾‹ 2ï¼š è¾“å…¥: \"cbbd\" è¾“å‡º: \"bb\" 12345678910111213141516171819202122232425262728class Solution &#123; private int len; private String res; public String longestPalindrome(String s) &#123; len = 0; res = &quot;&quot;; int n = s.length(); for (int i = 0; i &lt; n; i++) &#123; helper(s, i, i); helper(s, i, i + 1); &#125; return res; &#125; private void helper(String s, int left, int right) &#123; int i = left, j = right; int n = s.length(); while (i &gt; -1 &amp;&amp; j &lt; n &amp;&amp; s.charAt(i) == s.charAt(j)) &#123; i -= 1; j += 1; &#125; if (j - i - 1 &gt; len) &#123; len = j - i - 1; res = s.substring(i + 1, j); &#125; &#125;&#125; 91. è§£ç æ–¹æ³•ä¸€æ¡åŒ…å«å­—æ¯ A-Z çš„æ¶ˆæ¯é€šè¿‡ä»¥ä¸‹æ–¹å¼è¿›è¡Œäº†ç¼–ç ï¼š 'A' -> 1 'B' -> 2 ... 'Z' -> 26 ç»™å®šä¸€ä¸ªåªåŒ…å«æ•°å­—çš„éç©ºå­—ç¬¦ä¸²ï¼Œè¯·è®¡ç®—è§£ç æ–¹æ³•çš„æ€»æ•°ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: \"12\" è¾“å‡º: 2 è§£é‡Š: å®ƒå¯ä»¥è§£ç ä¸º \"AB\"ï¼ˆ1 2ï¼‰æˆ–è€… \"L\"ï¼ˆ12ï¼‰ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: \"226\" è¾“å‡º: 3 è§£é‡Š: å®ƒå¯ä»¥è§£ç ä¸º \"BZ\" (2 26), \"VF\" (22 6), æˆ–è€… \"BBF\" (2 2 6) ã€‚ PythonJava123456789101112131415161718class Solution(object): def numDecodings(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; n = len(s) dp = [0 for _ in xrange(n + 1)] dp[0] = 1 dp[1] = 1 if s[0] != &#x27;0&#x27; else 0 for i in xrange(2, n + 1): one_c = int(s[i - 1: i]) two_c = int(s[i - 2: i]) if 1 &lt;= one_c &lt;= 9: dp[i] += dp[i - 1] if 10 &lt;= two_c &lt;= 26: dp[i] += dp[i - 2] return dp[n]123456789101112131415161718192021class Solution &#123; public int numDecodings(String s) &#123; int n = s.length(); int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = s.charAt(0) == &#x27;0&#x27; ? 0 : 1; for (int i = 2; i &lt; n + 1; i++) &#123; String one_s = s.substring(i - 1, i); String two_s = s.substring(i - 2, i); int one = Integer.parseInt(one_s); if (1 &lt;= one &amp;&amp; one &lt;= 9) &#123; dp[i] += dp[i - 1]; &#125; int two = Integer.parseInt(two_s); if (two &gt;= 10 &amp;&amp; two &lt;= 26) &#123; dp[i] += dp[i - 2]; &#125; &#125; return dp[n]; &#125;&#125; 120. ä¸‰è§’å½¢æœ€å°è·¯å¾„å’Œ [n]ç»™å®šä¸€ä¸ªä¸‰è§’å½¢ï¼Œæ‰¾å‡ºè‡ªé¡¶å‘ä¸‹çš„æœ€å°è·¯å¾„å’Œã€‚æ¯ä¸€æ­¥åªèƒ½ç§»åŠ¨åˆ°ä¸‹ä¸€è¡Œä¸­ç›¸é‚»çš„ç»“ç‚¹ä¸Šã€‚ ä¾‹å¦‚ï¼Œç»™å®šä¸‰è§’å½¢ï¼š [ [2], [3,4], [6,5,7], [4,1,8,3] ] è‡ªé¡¶å‘ä¸‹çš„æœ€å°è·¯å¾„å’Œä¸º 11ï¼ˆå³ï¼Œ2 + 3 + 5 + 1 = 11ï¼‰ã€‚ PythonJava12345678910111213141516171819202122class Solution(object): def minimumTotal(self, triangle): &quot;&quot;&quot; :type triangle: List[List[int]] :rtype: int &quot;&quot;&quot; rows = len(triangle) cols = len(triangle[rows - 1]) dp = [[0 for _ in xrange(cols)] for _ in xrange(rows)] dp[0][0] = triangle[0][0] for i in xrange(1, rows): for j in xrange(0, i + 1): if j == 0: dp[i][j] = dp[i - 1][j] + triangle[i][j] elif i == j: dp[i][j] = dp[i - 1][j - 1] + triangle[i][j] else: dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + triangle[i][j] res = dp[rows - 1][0] for i in xrange(1, cols): res = min(res, dp[rows - 1][i]) return res12345678910111213141516171819202122232425class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int rows = triangle.size(); int cols = triangle.get(rows - 1).size(); int[][] dp = new int[rows][cols]; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; i + 1; j++) &#123; if (i == 0 &amp;&amp; j == 0) &#123; dp[i][j] = triangle.get(i).get(j); &#125; else if (j == 0) &#123; dp[i][j] = triangle.get(i).get(j) + dp[i - 1][j]; &#125; else if (j == i) &#123; dp[i][j] = triangle.get(i).get(j) + dp[i - 1][j - 1]; &#125; else &#123; dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1]) + triangle.get(i).get(j); &#125; &#125; &#125; int res = dp[rows - 1][0]; for (int i = 1; i &lt; cols; i++) &#123; res = Math.min(res, dp[rows - 1][i]); &#125; return res; &#125;&#125; 139. å•è¯æ‹†åˆ† [n]ç»™å®šä¸€ä¸ªéç©ºå­—ç¬¦ä¸² s å’Œä¸€ä¸ªåŒ…å«éç©ºå•è¯åˆ—è¡¨çš„å­—å…¸ wordDictï¼Œåˆ¤å®š s æ˜¯å¦å¯ä»¥è¢«ç©ºæ ¼æ‹†åˆ†ä¸ºä¸€ä¸ªæˆ–å¤šä¸ªåœ¨å­—å…¸ä¸­å‡ºç°çš„å•è¯ã€‚ è¯´æ˜ï¼š æ‹†åˆ†æ—¶å¯ä»¥é‡å¤ä½¿ç”¨å­—å…¸ä¸­çš„å•è¯ã€‚ ä½ å¯ä»¥å‡è®¾å­—å…¸ä¸­æ²¡æœ‰é‡å¤çš„å•è¯ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥: s = \"leetcode\", wordDict = [\"leet\", \"code\"] è¾“å‡º: true è§£é‡Š: è¿”å› true å› ä¸º \"leetcode\" å¯ä»¥è¢«æ‹†åˆ†æˆ \"leet code\"ã€‚ ç¤ºä¾‹ 2ï¼š è¾“å…¥: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"] è¾“å‡º: true è§£é‡Š: è¿”å› true å› ä¸º \"applepenapple\" å¯ä»¥è¢«æ‹†åˆ†æˆ \"apple pen apple\"ã€‚ æ³¨æ„ä½ å¯ä»¥é‡å¤ä½¿ç”¨å­—å…¸ä¸­çš„å•è¯ã€‚ ç¤ºä¾‹ 3ï¼š è¾“å…¥: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"] è¾“å‡º: false PythonJava123456789101112131415161718class Solution(object): def wordBreak(self, s, wordDict): &quot;&quot;&quot; :type s: str :type wordDict: List[str] :rtype: bool &quot;&quot;&quot; word_set = set() for word in wordDict: word_set.add(word) dp = [False for _ in xrange(len(s) + 1)] dp[0] = True for i in xrange(1, len(s) + 1): for j in xrange(i): if dp[j] and s[j: i] in word_set: dp[i] = True break return dp[len(s)] 12345678910111213141516class Solution &#123; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordDict); boolean[] dp = new boolean[s.length() + 1]; dp[0] = true; for (int i = 0; i &lt; s.length() + 1; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (dp[j] &amp;&amp; wordSet.contains(s.substring(j, i))) &#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.length()]; &#125;&#125; 152. ä¹˜ç§¯æœ€å¤§å­æ•°ç»„ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œè¯·ä½ æ‰¾å‡ºæ•°ç»„ä¸­ä¹˜ç§¯æœ€å¤§çš„è¿ç»­å­æ•°ç»„ï¼ˆè¯¥å­æ•°ç»„ä¸­è‡³å°‘åŒ…å«ä¸€ä¸ªæ•°å­—ï¼‰ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [2,3,-2,4] è¾“å‡º: 6 è§£é‡Š: å­æ•°ç»„ [2,3] æœ‰æœ€å¤§ä¹˜ç§¯ 6ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: [-2,0,-1] è¾“å‡º: 0 è§£é‡Š: ç»“æœä¸èƒ½ä¸º 2, å› ä¸º [-2,-1] ä¸æ˜¯å­æ•°ç»„ã€‚ 1234567891011121314class Solution(object): def maxProduct(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; max_n, min_n, res = nums[0], nums[0], nums[0] for i in xrange(1, len(nums)): tmp = max_n max_n = max(max_n * nums[i], min_n * nums[i], nums[i]) min_n = min(tmp * nums[i], min_n * nums[i], nums[i]) if max_n &gt; res: res = max_n return res 221. æœ€å¤§æ­£æ–¹å½¢ [n]åœ¨ä¸€ä¸ªç”± 0 å’Œ 1 ç»„æˆçš„äºŒç»´çŸ©é˜µå†…ï¼Œæ‰¾åˆ°åªåŒ…å« 1 çš„æœ€å¤§æ­£æ–¹å½¢ï¼Œå¹¶è¿”å›å…¶é¢ç§¯ã€‚ ç¤ºä¾‹: è¾“å…¥: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 è¾“å‡º: 4 1234567891011121314151617class Solution(object): def maximalSquare(self, matrix): &quot;&quot;&quot; :type matrix: List[List[str]] :rtype: int &quot;&quot;&quot; if matrix is None or len(matrix) == 0 or len(matrix[0]) == 0: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0 for _ in xrange(cols + 1)] for _ in xrange(rows + 1)] max_edge = 0 for i in xrange(1, rows + 1): for j in xrange(1, cols + 1): if matrix[i - 1][j - 1] == &#x27;1&#x27;: dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]) + 1 max_edge = max(max_edge, dp[i][j]) return max_edge * max_edge 264. ä¸‘æ•° IIç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œæ‰¾å‡ºç¬¬ n ä¸ªä¸‘æ•°ã€‚ ä¸‘æ•°å°±æ˜¯åªåŒ…å«è´¨å› æ•° 2, 3, 5 çš„æ­£æ•´æ•°ã€‚ ç¤ºä¾‹: è¾“å…¥: n = 10 è¾“å‡º: 12 è§£é‡Š: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 æ˜¯å‰ 10 ä¸ªä¸‘æ•°ã€‚ è¯´æ˜: 1 æ˜¯ä¸‘æ•°ã€‚ n ä¸è¶…è¿‡1690ã€‚ PythonJava123456789101112131415161718class Solution(object): def nthUglyNumber(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; dp = [1 for i in xrange(n)] i2, i3, i5 = 0, 0, 0 for i in xrange(1, n): min_v = min(dp[i2] * 2, dp[i3] * 3, dp[i5] * 5) dp[i] = min_v if min_v == dp[i2] * 2: i2 += 1 if min_v == dp[i3] * 3: i3 += 1 if min_v == dp[i5] * 5: i5+= 1 return dp[n - 1]123456789101112131415161718192021class Solution &#123; public int nthUglyNumber(int n) &#123; int idx2 = 0, idx3 = 0, idx5 = 0; int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i &lt; n; i++) &#123; int minV = Math.min(dp[idx2] * 2, Math.min(dp[idx3] * 3, dp[idx5] * 5)); dp[i] = minV; if (minV == dp[idx2] * 2) &#123; idx2 += 1; &#125; if (minV == dp[idx3] * 3) &#123; idx3 += 1; &#125; if (minV == dp[idx5] * 5) &#123; idx5 += 1; &#125; &#125; return dp[n - 1]; &#125;&#125; 279. å®Œå…¨å¹³æ–¹æ•° [n]ç»™å®šæ­£æ•´æ•° nï¼Œæ‰¾åˆ°è‹¥å¹²ä¸ªå®Œå…¨å¹³æ–¹æ•°ï¼ˆæ¯”å¦‚ 1, 4, 9, 16, â€¦ï¼‰ä½¿å¾—å®ƒä»¬çš„å’Œç­‰äº nã€‚ä½ éœ€è¦è®©ç»„æˆå’Œçš„å®Œå…¨å¹³æ–¹æ•°çš„ä¸ªæ•°æœ€å°‘ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: n = 12 è¾“å‡º: 3 è§£é‡Š: 12 = 4 + 4 + 4. ç¤ºä¾‹ 2: è¾“å…¥: n = 13 è¾“å‡º: 2 è§£é‡Š: 13 = 4 + 9. PythonJava1234567891011121314class Solution(object): def numSquares(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; dp = [0 for _ in xrange(n + 1)] for i in xrange(1, n + 1): j = 1 dp[i] = i while i - j * j &gt;= 0: dp[i] = min(dp[i], dp[i - j * j] + 1) j += 1 return dp[n]1234567891011121314class Solution &#123; public int numSquares(int n) &#123; int[] dp = new int[n + 1]; for (int i = 0; i &lt;= n; i++) &#123; dp[i] = i; int j = 1; while (i - j * j &gt;= 0) &#123; dp[i] = Math.min(dp[i], dp[i - j * j] + 1); j += 1; &#125; &#125; return dp[n]; &#125;&#125; 300. æœ€é•¿ä¸Šå‡å­åºåˆ—ç»™å®šä¸€ä¸ªæ— åºçš„æ•´æ•°æ•°ç»„ï¼Œæ‰¾åˆ°å…¶ä¸­æœ€é•¿ä¸Šå‡å­åºåˆ—çš„é•¿åº¦ã€‚ ç¤ºä¾‹: è¾“å…¥: [10,9,2,5,3,7,101,18] è¾“å‡º: 4 è§£é‡Š: æœ€é•¿çš„ä¸Šå‡å­åºåˆ—æ˜¯ [2,3,7,101]ï¼Œå®ƒçš„é•¿åº¦æ˜¯ 4ã€‚ è¯´æ˜: å¯èƒ½ä¼šæœ‰å¤šç§æœ€é•¿ä¸Šå‡å­åºåˆ—çš„ç»„åˆï¼Œä½ åªéœ€è¦è¾“å‡ºå¯¹åº”çš„é•¿åº¦å³å¯ã€‚ ä½ ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦åº”è¯¥ä¸º O(n2) ã€‚ PythonJava1234567891011121314151617class Solution(object): def lengthOfLIS(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if nums is None or len(nums) == 0: return 0 dp = [0 for _ in xrange(len(nums))] res = 0 for i in xrange(len(nums)): dp[i] = 1 for j in xrange(i): if nums[i] &gt; nums[j]: dp[i] = max(dp[i], dp[j] + 1) res = max(dp[i], res) return res12345678910111213141516171819class Solution &#123; public int lengthOfLIS(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int res = 0; int[] dp = new int[nums.length]; for (int i = 0; i &lt; nums.length; i++) &#123; dp[i] = 1; for (int j = 0; j &lt; i; j++) &#123; if (nums[i] &gt; nums[j]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; &#125; res = Math.max(dp[i], res); &#125; return res; &#125;&#125; 309. æœ€ä½³ä¹°å–è‚¡ç¥¨æ—¶æœºå«å†·å†»æœŸ [n]ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œå…¶ä¸­ç¬¬ i ä¸ªå…ƒç´ ä»£è¡¨äº†ç¬¬ i å¤©çš„è‚¡ç¥¨ä»·æ ¼ ã€‚â€‹ è®¾è®¡ä¸€ä¸ªç®—æ³•è®¡ç®—å‡ºæœ€å¤§åˆ©æ¶¦ã€‚åœ¨æ»¡è¶³ä»¥ä¸‹çº¦æŸæ¡ä»¶ä¸‹ï¼Œä½ å¯ä»¥å°½å¯èƒ½åœ°å®Œæˆæ›´å¤šçš„äº¤æ˜“ï¼ˆå¤šæ¬¡ä¹°å–ä¸€æ”¯è‚¡ç¥¨ï¼‰: ä½ ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ï¼ˆä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ï¼‰ã€‚å–å‡ºè‚¡ç¥¨åï¼Œä½ æ— æ³•åœ¨ç¬¬äºŒå¤©ä¹°å…¥è‚¡ç¥¨ (å³å†·å†»æœŸä¸º 1 å¤©)ã€‚ ç¤ºä¾‹: è¾“å…¥: [1,2,3,0,2] è¾“å‡º: 3 è§£é‡Š: å¯¹åº”çš„äº¤æ˜“çŠ¶æ€ä¸º: [ä¹°å…¥, å–å‡º, å†·å†»æœŸ, ä¹°å…¥, å–å‡º] 12345678910111213class Solution(object): def maxProfit(self, prices): &quot;&quot;&quot; :type prices: List[int] :rtype: int &quot;&quot;&quot; hold, sold, rest = -1 &lt;&lt; 32, 0, 0 for price in prices: prev_sold = sold sold = hold + price hold = max(hold, rest - price) rest = max(rest, prev_sold) return max(rest, sold) 322. é›¶é’±å…‘æ¢ [n]ç»™å®šä¸åŒé¢é¢çš„ç¡¬å¸ coins å’Œä¸€ä¸ªæ€»é‡‘é¢ amountã€‚ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥è®¡ç®—å¯ä»¥å‡‘æˆæ€»é‡‘é¢æ‰€éœ€çš„æœ€å°‘çš„ç¡¬å¸ä¸ªæ•°ã€‚å¦‚æœæ²¡æœ‰ä»»ä½•ä¸€ç§ç¡¬å¸ç»„åˆèƒ½ç»„æˆæ€»é‡‘é¢ï¼Œè¿”å› -1ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: coins = [1, 2, 5], amount = 11 è¾“å‡º: 3 è§£é‡Š: 11 = 5 + 5 + 1 ç¤ºä¾‹ 2: è¾“å…¥: coins = [2], amount = 3 è¾“å‡º: -1 è¯´æ˜: ä½ å¯ä»¥è®¤ä¸ºæ¯ç§ç¡¬å¸çš„æ•°é‡æ˜¯æ— é™çš„ã€‚ PythonJava123456789101112131415161718class Solution(object): def coinChange(self, coins, amount): &quot;&quot;&quot; :type coins: List[int] :type amount: int :rtype: int &quot;&quot;&quot; INT_MAX = (1 &lt;&lt; 31) - 1 dp = [INT_MAX for _ in xrange(amount + 1)] dp[0] = 0 for i in xrange(1, amount + 1): for j in coins: if i &gt;= j: dp[i] = min(dp[i], dp[i - j] + 1) if dp[amount] == INT_MAX: return -1 else: return dp[amount]123456789101112131415161718class Solution &#123; public int coinChange(int[] coins, int amount) &#123; int[] dp = new int[amount + 1]; final int max = amount + 1; for (int i = 0; i &lt; dp.length; i++) &#123; dp[i] = max; &#125; dp[0] = 0; for (int i = 1; i &lt; amount + 1; i++) &#123; for (int coin : coins) &#123; if (i &gt;= coin) &#123; dp[i] = Math.min(dp[i], dp[i - coin] + 1); &#125; &#125; &#125; return dp[amount] == max ? -1 : dp[amount]; &#125;&#125; 343. æ•´æ•°æ‹†åˆ† [n]ç»™å®šä¸€ä¸ªæ­£æ•´æ•° nï¼Œå°†å…¶æ‹†åˆ†ä¸ºè‡³å°‘ä¸¤ä¸ªæ­£æ•´æ•°çš„å’Œï¼Œå¹¶ä½¿è¿™äº›æ•´æ•°çš„ä¹˜ç§¯æœ€å¤§åŒ–ã€‚ è¿”å›ä½ å¯ä»¥è·å¾—çš„æœ€å¤§ä¹˜ç§¯ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: 2 è¾“å‡º: 1 è§£é‡Š: 2 = 1 + 1, 1 Ã— 1 = 1ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: 10 è¾“å‡º: 36 è§£é‡Š: 10 = 3 + 3 + 4, 3 Ã— 3 Ã— 4 = 36ã€‚ è¯´æ˜: ä½ å¯ä»¥å‡è®¾ n ä¸å°äº 2 ä¸”ä¸å¤§äº 58ã€‚ PythonJava12345678910111213class Solution(object): def integerBreak(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; dp = [0 for _ in xrange(n + 1)] for i in xrange(2, n + 1): cur_max = 0 for j in xrange(1, i): cur_max = max(cur_max, j * (i - j), j * dp[i - j]) dp[i] = cur_max return dp[n]1234567891011121314class Solution &#123; public int integerBreak(int n) &#123; int[] dp = new int[n + 1]; dp[0] = dp[1] = 0; for (int i = 2; i &lt;= n; i++) &#123; int curMax = 0; for (int j = 1; j &lt; i; j++) &#123; curMax = Math.max(curMax, Math.max(j * (i - j), j * dp[i - j])); &#125; dp[i] = curMax; &#125; return dp[n]; &#125;&#125; 357. è®¡ç®—å„ä¸ªä½æ•°ä¸åŒçš„æ•°å­—ä¸ªæ•°ç»™å®šä¸€ä¸ªéè´Ÿæ•´æ•° nï¼Œè®¡ç®—å„ä½æ•°å­—éƒ½ä¸åŒçš„æ•°å­— x çš„ä¸ªæ•°ï¼Œå…¶ä¸­ 0 â‰¤ x &lt; 10^n ã€‚ ç¤ºä¾‹: è¾“å…¥: 2 è¾“å‡º: 91 è§£é‡Š: ç­”æ¡ˆåº”ä¸ºé™¤å» 11,22,33,44,55,66,77,88,99 å¤–ï¼Œåœ¨ [0,100) åŒºé—´å†…çš„æ‰€æœ‰æ•°å­—ã€‚ PythonJava1234567891011121314151617class Solution(object): def countNumbersWithUniqueDigits(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; if n == 0: return 1 dp = [0 for _ in xrange(11)] dp[1] = 10 dp[2] = 9 * 9 for i in xrange(3, 11): dp[i] = dp[i - 1] * (10 - i + 1) res = 0 for i in xrange(min(n, 10) + 1): res += dp[i] return res123456789101112131415161718class Solution &#123; public int countNumbersWithUniqueDigits(int n) &#123; if (n == 0) &#123; return 1; &#125; int[] dp = new int[11]; dp[1] = 10; dp[2] = 9 * 9; for (int i = 3; i &lt;= 10; i++) &#123; dp[i] = dp[i - 1] * (10 - i + 1); &#125; int res = 0; for (int i = 1; i &lt;= Math.min(10, n); i++) &#123; res += dp[i]; &#125; return res; &#125;&#125; 377. ç»„åˆæ€»å’Œ â…£ [n]ç»™å®šä¸€ä¸ªç”±æ­£æ•´æ•°ç»„æˆä¸”ä¸å­˜åœ¨é‡å¤æ•°å­—çš„æ•°ç»„ï¼Œæ‰¾å‡ºå’Œä¸ºç»™å®šç›®æ ‡æ­£æ•´æ•°çš„ç»„åˆçš„ä¸ªæ•°ã€‚ ç¤ºä¾‹: nums = [1, 2, 3] target = 4 æ‰€æœ‰å¯èƒ½çš„ç»„åˆä¸ºï¼š (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) è¯·æ³¨æ„ï¼Œé¡ºåºä¸åŒçš„åºåˆ—è¢«è§†ä½œä¸åŒçš„ç»„åˆã€‚ å› æ­¤è¾“å‡ºä¸º 7ã€‚ PythonJava1234567891011121314class Solution(object): def combinationSum4(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; dp = [0 for _ in xrange(target + 1)] dp[0] = 1 for i in xrange(1, target + 1): for n in nums: if i &gt;= n: dp[i] += dp[i - n] return dp[target]1234567891011121314class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 1; i &lt;= target; i++) &#123; for (int n : nums) &#123; if (i &gt;= n) &#123; dp[i] += dp[i - n]; &#125; &#125; &#125; return dp[target]; &#125;&#125; 416. åˆ†å‰²ç­‰å’Œå­é›† [n]ç»™å®šä¸€ä¸ªåªåŒ…å«æ­£æ•´æ•°çš„éç©ºæ•°ç»„ã€‚æ˜¯å¦å¯ä»¥å°†è¿™ä¸ªæ•°ç»„åˆ†å‰²æˆä¸¤ä¸ªå­é›†ï¼Œä½¿å¾—ä¸¤ä¸ªå­é›†çš„å…ƒç´ å’Œç›¸ç­‰ã€‚ æ³¨æ„: æ¯ä¸ªæ•°ç»„ä¸­çš„å…ƒç´ ä¸ä¼šè¶…è¿‡ 100 æ•°ç»„çš„å¤§å°ä¸ä¼šè¶…è¿‡ 200 ç¤ºä¾‹ 1: è¾“å…¥: [1, 5, 11, 5] è¾“å‡º: true è§£é‡Š: æ•°ç»„å¯ä»¥åˆ†å‰²æˆ [1, 5, 5] å’Œ [11]. ç¤ºä¾‹ 2: è¾“å…¥: [1, 2, 3, 5] è¾“å‡º: false è§£é‡Š: æ•°ç»„ä¸èƒ½åˆ†å‰²æˆä¸¤ä¸ªå…ƒç´ å’Œç›¸ç­‰çš„å­é›†. PythonJava123456789101112131415161718192021class Solution(object): def canPartition(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; n = len(nums) total = sum(nums) if total % 2 == 1: return False total = total / 2 dp = [[False for _ in xrange(total + 1)] for _ in xrange(n + 1)] for i in xrange(n + 1): dp[i][0] = True for i in xrange(1, n + 1): for j in xrange(1, total + 1): if j - nums[i - 1] &lt; 0: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j - nums[i - 1]] or dp[i - 1][j] return dp[n][total]1234567891011121314151617181920212223242526272829class Solution &#123; public boolean canPartition(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return false; &#125; int total = 0; for (int n : nums) &#123; total += n; &#125; if (total % 2 == 1) &#123; return false; &#125; int target = total / 2; boolean[][] dp = new boolean[nums.length + 1][target + 1]; for (int i = 0; i &lt;= nums.length; i++) &#123; dp[i][0] = true; &#125; for (int i = 1; i &lt;= nums.length; i++) &#123; for (int j = 1; j &lt;= target; j++) &#123; if (j - nums[i - 1] &lt; 0) &#123; dp[i][j] = dp[i - 1][j]; &#125; else &#123; dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]]; &#125; &#125; &#125; return dp[nums.length][target]; &#125;&#125; 494. ç›®æ ‡å’Œ [n]ç»™å®šä¸€ä¸ªéè´Ÿæ•´æ•°æ•°ç»„ï¼Œa1, a2, â€¦, an, å’Œä¸€ä¸ªç›®æ ‡æ•°ï¼ŒSã€‚ç°åœ¨ä½ æœ‰ä¸¤ä¸ªç¬¦å· + å’Œ -ã€‚å¯¹äºæ•°ç»„ä¸­çš„ä»»æ„ä¸€ä¸ªæ•´æ•°ï¼Œä½ éƒ½å¯ä»¥ä» + æˆ– -ä¸­é€‰æ‹©ä¸€ä¸ªç¬¦å·æ·»åŠ åœ¨å‰é¢ã€‚ è¿”å›å¯ä»¥ä½¿æœ€ç»ˆæ•°ç»„å’Œä¸ºç›®æ ‡æ•° S çš„æ‰€æœ‰æ·»åŠ ç¬¦å·çš„æ–¹æ³•æ•°ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: nums: [1, 1, 1, 1, 1], S: 3 è¾“å‡º: 5 è§£é‡Š: -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3 ä¸€å…±æœ‰5ç§æ–¹æ³•è®©æœ€ç»ˆç›®æ ‡å’Œä¸º3ã€‚ æ³¨æ„: æ•°ç»„éç©ºï¼Œä¸”é•¿åº¦ä¸ä¼šè¶…è¿‡20ã€‚ åˆå§‹çš„æ•°ç»„çš„å’Œä¸ä¼šè¶…è¿‡1000ã€‚ ä¿è¯è¿”å›çš„æœ€ç»ˆç»“æœèƒ½è¢«32ä½æ•´æ•°å­˜ä¸‹ã€‚ PythonJava1234567891011121314151617class Solution(object): def findTargetSumWays(self, nums, S): &quot;&quot;&quot; :type nums: List[int] :type S: int :rtype: int &quot;&quot;&quot; total = sum(nums) if S &gt; total or (S + total) % 2 != 0: return 0 P = (S + total) / 2 dp = [0 for _ in xrange(P + 1)] dp[0] = 1 for n in nums: for i in xrange(P, n - 1, -1): dp[i] += dp[i - n] return dp[P]1234567891011121314151617181920class Solution &#123; public int findTargetSumWays(int[] nums, int S) &#123; int total = 0; for (int n : nums) &#123; total += n; &#125; if (S &gt; total || (S + total) % 2 != 0) &#123; return 0; &#125; int P = (S + total) / 2; int[] dp = new int[P + 1]; dp[0] = 1; for (int n : nums) &#123; for (int i = P; i &gt;= n; i--) &#123; dp[i] += dp[i - n]; &#125; &#125; return dp[P]; &#125;&#125; 516. æœ€é•¿å›æ–‡å­åºåˆ—ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²sï¼Œæ‰¾åˆ°å…¶ä¸­æœ€é•¿çš„å›æ–‡å­åºåˆ—ã€‚å¯ä»¥å‡è®¾sçš„æœ€å¤§é•¿åº¦ä¸º1000ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: \"bbbab\" è¾“å‡º: 4 ä¸€ä¸ªå¯èƒ½çš„æœ€é•¿å›æ–‡å­åºåˆ—ä¸º \"bbbb\"ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: \"cbbd\" è¾“å‡º: 2 ä¸€ä¸ªå¯èƒ½çš„æœ€é•¿å›æ–‡å­åºåˆ—ä¸º \"bb\"ã€‚ 12345678910111213141516class Solution(object): def longestPalindromeSubseq(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; n = len(s) dp = [[0 for _ in xrange(n)] for _ in xrange(n)] for i in xrange(n - 1, -1, -1): dp[i][i] = 1 for j in xrange(i + 1, n): if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1] 650. åªæœ‰ä¸¤ä¸ªé”®çš„é”®ç›˜æœ€åˆåœ¨ä¸€ä¸ªè®°äº‹æœ¬ä¸Šåªæœ‰ä¸€ä¸ªå­—ç¬¦ â€˜Aâ€™ã€‚ä½ æ¯æ¬¡å¯ä»¥å¯¹è¿™ä¸ªè®°äº‹æœ¬è¿›è¡Œä¸¤ç§æ“ä½œï¼š Copy All (å¤åˆ¶å…¨éƒ¨) : ä½ å¯ä»¥å¤åˆ¶è¿™ä¸ªè®°äº‹æœ¬ä¸­çš„æ‰€æœ‰å­—ç¬¦(éƒ¨åˆ†çš„å¤åˆ¶æ˜¯ä¸å…è®¸çš„)ã€‚Paste (ç²˜è´´) : ä½ å¯ä»¥ç²˜è´´ä½ ä¸Šä¸€æ¬¡å¤åˆ¶çš„å­—ç¬¦ã€‚ç»™å®šä¸€ä¸ªæ•°å­— n ã€‚ä½ éœ€è¦ä½¿ç”¨æœ€å°‘çš„æ“ä½œæ¬¡æ•°ï¼Œåœ¨è®°äº‹æœ¬ä¸­æ‰“å°å‡ºæ°å¥½ n ä¸ª â€˜Aâ€™ã€‚è¾“å‡ºèƒ½å¤Ÿæ‰“å°å‡º n ä¸ª â€˜Aâ€™ çš„æœ€å°‘æ“ä½œæ¬¡æ•°ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: 3 è¾“å‡º: 3 è§£é‡Š: æœ€åˆ, æˆ‘ä»¬åªæœ‰ä¸€ä¸ªå­—ç¬¦ 'A'ã€‚ ç¬¬ 1 æ­¥, æˆ‘ä»¬ä½¿ç”¨ Copy All æ“ä½œã€‚ ç¬¬ 2 æ­¥, æˆ‘ä»¬ä½¿ç”¨ Paste æ“ä½œæ¥è·å¾— 'AA'ã€‚ ç¬¬ 3 æ­¥, æˆ‘ä»¬ä½¿ç”¨ Paste æ“ä½œæ¥è·å¾— 'AAA'ã€‚ è¯´æ˜: n çš„å–å€¼èŒƒå›´æ˜¯ [1, 1000] ã€‚ 12345678910111213class Solution(object): def minSteps(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; dp = [n] * (n + 1) dp[0] = dp[1] = 0 for i in xrange(2, n + 1): for j in xrange(1, i): if i % j == 0: dp[i] = min(dp[i], dp[j] + i / j) return dp[n] 673. æœ€é•¿é€’å¢å­åºåˆ—çš„ä¸ªæ•°ç»™å®šä¸€ä¸ªæœªæ’åºçš„æ•´æ•°æ•°ç»„ï¼Œæ‰¾åˆ°æœ€é•¿é€’å¢å­åºåˆ—çš„ä¸ªæ•°ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [1,3,5,4,7] è¾“å‡º: 2 è§£é‡Š: æœ‰ä¸¤ä¸ªæœ€é•¿é€’å¢å­åºåˆ—ï¼Œåˆ†åˆ«æ˜¯ [1, 3, 4, 7] å’Œ[1, 3, 5, 7]ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: [2,2,2,2,2] è¾“å‡º: 5 è§£é‡Š: æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦æ˜¯1ï¼Œå¹¶ä¸”å­˜åœ¨5ä¸ªå­åºåˆ—çš„é•¿åº¦ä¸º1ï¼Œå› æ­¤è¾“å‡º5ã€‚ æ³¨æ„: ç»™å®šçš„æ•°ç»„é•¿åº¦ä¸è¶…è¿‡ 2000 å¹¶ä¸”ç»“æœä¸€å®šæ˜¯32ä½æœ‰ç¬¦å·æ•´æ•°ã€‚ 12345678910111213141516171819202122232425class Solution(object): def findNumberOfLIS(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if nums is None or len(nums) == 0: return 0 n = len(nums) dp = [1 for _ in xrange(n)] counter = [1 for _ in xrange(n)] for i in xrange(n): for j in xrange(i): if nums[i] &gt; nums[j]: if dp[j] + 1 &gt; dp[i]: dp[i] = dp[j] + 1 counter[i] = counter[j] elif dp[j] + 1 == dp[i]: counter[i] += counter[j] max_len = max(dp) res = 0 for i in xrange(n): if dp[i] == max_len: res += counter[i] return res","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCodeä¹‹æ•°ç»„(ç®€å•)","slug":"LeetCode-æ•°ç»„-ç®€å•","date":"2021-01-02T05:34:23.000Z","updated":"2021-01-02T06:03:34.985Z","comments":false,"path":"posts/3027083408.html","link":"","permalink":"https://leel0330.github.io/posts/3027083408.html","excerpt":"æ•°ç»„(ç®€å•)çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚","text":"æ•°ç»„(ç®€å•)çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ 53. æœ€å¤§å­åºå’Œç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œæ‰¾åˆ°ä¸€ä¸ªå…·æœ‰æœ€å¤§å’Œçš„è¿ç»­å­æ•°ç»„ï¼ˆå­æ•°ç»„æœ€å°‘åŒ…å«ä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œè¿”å›å…¶æœ€å¤§å’Œã€‚ ç¤ºä¾‹: è¾“å…¥: [-2,1,-3,4,-1,2,1,-5,4], è¾“å‡º: 6 è§£é‡Š: è¿ç»­å­æ•°ç»„ [4,-1,2,1] çš„å’Œæœ€å¤§ï¼Œä¸º 6ã€‚ PythonC++12345678910111213class Solution(object): def maxSubArray(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; dp = [0 for _ in xrange(len(nums))] res = nums[0] dp[0] = nums[0] for i in xrange(1, len(nums)): dp[i] = max(dp[i - 1] + nums[i], nums[i]) res = max(res, dp[i]) return res12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n == 0) &#123; return 0; &#125; vector&lt;int&gt; dp(n, 0); dp[0] = nums[0]; int res = dp[0]; for (int i = 1; i &lt; n; i++) &#123; dp[i] = max(dp[i - 1] + nums[i], nums[i]); res = max(res, dp[i]); &#125; return res; &#125;&#125;; 118. æ¨è¾‰ä¸‰è§’ [n]ç»™å®šä¸€ä¸ªéè´Ÿæ•´æ•° numRowsï¼Œç”Ÿæˆæ¨è¾‰ä¸‰è§’çš„å‰ numRows è¡Œã€‚ ç¤ºä¾‹: è¾“å…¥: 5 è¾“å‡º: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] PythonC++1234567891011121314class Solution(object): def generate(self, numRows): &quot;&quot;&quot; :type numRows: int :rtype: List[List[int]] &quot;&quot;&quot; res = [] item = [] for i in xrange(numRows): item.insert(0, 1) for j in xrange(1, len(item) - 1): item[j] = item[j] + item[j + 1] res.append(item[:]) return res123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: vector&lt;vector&lt;int&gt; &gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt; &gt; res; vector&lt;int&gt; tmp; for (int i = 0; i &lt; numRows; i++) &#123; tmp.insert(tmp.begin(), 1); for (int j = 1; j &lt; tmp.size() - 1; j++) &#123; tmp[j] = tmp[j] + tmp[j + 1]; &#125; vector&lt;int&gt; row = tmp; res.push_back(row); &#125; return res; &#125;&#125;; 119. æ¨è¾‰ä¸‰è§’ IIç»™å®šä¸€ä¸ªéè´Ÿç´¢å¼• kï¼Œå…¶ä¸­ k â‰¤ 33ï¼Œè¿”å›æ¨è¾‰ä¸‰è§’çš„ç¬¬ k è¡Œã€‚ ç¤ºä¾‹: è¾“å…¥: 3 è¾“å‡º: [1,3,3,1] PythonC++123456789101112class Solution(object): def getRow(self, rowIndex): &quot;&quot;&quot; :type rowIndex: int :rtype: List[int] &quot;&quot;&quot; item = [] for i in xrange(rowIndex + 1): item.insert(0, 1) for j in xrange(1, len(item) - 1): item[j] = item[j] + item[j + 1] return item123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; res; for (int i = 0; i &lt; rowIndex + 1; i++) &#123; res.insert(res.begin(), 1); for (int j = 1; j &lt; res.size() - 1; j++) &#123; res[j] = res[j] + res[j + 1]; &#125; &#125; return res; &#125;&#125;; 121. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œå®ƒçš„ç¬¬ i ä¸ªå…ƒç´ æ˜¯ä¸€æ”¯ç»™å®šè‚¡ç¥¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚ å¦‚æœä½ æœ€å¤šåªå…è®¸å®Œæˆä¸€ç¬”äº¤æ˜“ï¼ˆå³ä¹°å…¥å’Œå–å‡ºä¸€æ”¯è‚¡ç¥¨ï¼‰ï¼Œè®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚ æ³¨æ„ä½ ä¸èƒ½åœ¨ä¹°å…¥è‚¡ç¥¨å‰å–å‡ºè‚¡ç¥¨ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [7,1,5,3,6,4] è¾“å‡º: 5 è§£é‡Š: åœ¨ç¬¬ 2 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 1ï¼‰çš„æ—¶å€™ä¹°å…¥ï¼Œåœ¨ç¬¬ 5 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 6ï¼‰çš„æ—¶å€™å–å‡ºï¼Œæœ€å¤§åˆ©æ¶¦ = 6-1 = 5 ã€‚ æ³¨æ„åˆ©æ¶¦ä¸èƒ½æ˜¯ 7-1 = 6, å› ä¸ºå–å‡ºä»·æ ¼éœ€è¦å¤§äºä¹°å…¥ä»·æ ¼ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: [7,6,4,3,1] è¾“å‡º: 0 è§£é‡Š: åœ¨è¿™ç§æƒ…å†µä¸‹, æ²¡æœ‰äº¤æ˜“å®Œæˆ, æ‰€ä»¥æœ€å¤§åˆ©æ¶¦ä¸º0ã€‚ PythonC++1234567891011class Solution(object): def maxProfit(self, prices): &quot;&quot;&quot; :type prices: List[int] :rtype: int &quot;&quot;&quot; min_v, max_v = 1 &lt;&lt; 32 -1, 0 for price in prices: min_v = min(min_v, price) max_v = max(max_v, price - min_v) return max_v123456789101112131415161718#include &lt;climits&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int max_v = 0; int min_v = INT_MAX; for (auto iter = prices.cbegin(); iter != prices.cend(); iter++) &#123; min_v = min(min_v, *iter); max_v = max(max_v, *iter - min_v); &#125; return max_v; &#125;&#125;; 122. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº IIç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œå®ƒçš„ç¬¬ i ä¸ªå…ƒç´ æ˜¯ä¸€æ”¯ç»™å®šè‚¡ç¥¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚ è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚ä½ å¯ä»¥å°½å¯èƒ½åœ°å®Œæˆæ›´å¤šçš„äº¤æ˜“ï¼ˆå¤šæ¬¡ä¹°å–ä¸€æ”¯è‚¡ç¥¨ï¼‰ã€‚ æ³¨æ„ï¼šä½ ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ï¼ˆä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ï¼‰ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [7,1,5,3,6,4] è¾“å‡º: 7 è§£é‡Š: åœ¨ç¬¬ 2 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 1ï¼‰çš„æ—¶å€™ä¹°å…¥ï¼Œåœ¨ç¬¬ 3 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 5ï¼‰çš„æ—¶å€™å–å‡º, è¿™ç¬”äº¤æ˜“æ‰€èƒ½è·å¾—åˆ©æ¶¦ = 5-1 = 4 ã€‚ éšåï¼Œåœ¨ç¬¬ 4 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 3ï¼‰çš„æ—¶å€™ä¹°å…¥ï¼Œåœ¨ç¬¬ 5 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 6ï¼‰çš„æ—¶å€™å–å‡º, è¿™ç¬”äº¤æ˜“æ‰€èƒ½è·å¾—åˆ©æ¶¦ = 6-3 = 3 ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: [1,2,3,4,5] è¾“å‡º: 4 è§£é‡Š: åœ¨ç¬¬ 1 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 1ï¼‰çš„æ—¶å€™ä¹°å…¥ï¼Œåœ¨ç¬¬ 5 å¤© ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 5ï¼‰çš„æ—¶å€™å–å‡º, è¿™ç¬”äº¤æ˜“æ‰€èƒ½è·å¾—åˆ©æ¶¦ = 5-1 = 4 ã€‚ æ³¨æ„ä½ ä¸èƒ½åœ¨ç¬¬ 1 å¤©å’Œç¬¬ 2 å¤©æ¥è¿è´­ä¹°è‚¡ç¥¨ï¼Œä¹‹åå†å°†å®ƒä»¬å–å‡ºã€‚ å› ä¸ºè¿™æ ·å±äºåŒæ—¶å‚ä¸äº†å¤šç¬”äº¤æ˜“ï¼Œä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ã€‚ ç¤ºä¾‹ 3: è¾“å…¥: [7,6,4,3,1] è¾“å‡º: 0 è§£é‡Š: åœ¨è¿™ç§æƒ…å†µä¸‹, æ²¡æœ‰äº¤æ˜“å®Œæˆ, æ‰€ä»¥æœ€å¤§åˆ©æ¶¦ä¸º 0ã€‚ PythonC++1234567891011121314151617class Solution(object): def maxProfit(self, prices): &quot;&quot;&quot; :type prices: List[int] :rtype: int &quot;&quot;&quot; res, i, n = 0, 0, len(prices) while i &lt; n: while i &lt; n - 1 and prices[i + 1] &lt;= prices[i]: i += 1 min_v = prices[i] i += 1 while i &lt; n - 1 and prices[i + 1] &gt;= prices[i]: i += 1 if i &lt; n: res += prices[i] - min_v return res123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); int res = 0, i = 0; int min_v = 0; while (i &lt; n) &#123; while (i &lt; n - 1 &amp;&amp; prices[i + 1] &lt;= prices[i]) &#123; i += 1; &#125; min_v = prices[i]; i += 1; while (i &lt; n - 1 &amp;&amp; prices[i + 1] &gt;= prices[i]) &#123; i += 1; &#125; if (i &lt; n) &#123; res += (prices[i] - min_v); &#125; &#125; return res; &#125;&#125;; 448. æ‰¾åˆ°æ‰€æœ‰æ•°ç»„ä¸­æ¶ˆå¤±çš„æ•°å­—ç»™å®šä¸€ä¸ªèŒƒå›´åœ¨ 1 â‰¤ a[i] â‰¤ n ( n = æ•°ç»„å¤§å° ) çš„ æ•´å‹æ•°ç»„ï¼Œæ•°ç»„ä¸­çš„å…ƒç´ ä¸€äº›å‡ºç°äº†ä¸¤æ¬¡ï¼Œå¦ä¸€äº›åªå‡ºç°ä¸€æ¬¡ã€‚ æ‰¾åˆ°æ‰€æœ‰åœ¨ [1, n] èŒƒå›´ä¹‹é—´æ²¡æœ‰å‡ºç°åœ¨æ•°ç»„ä¸­çš„æ•°å­—ã€‚ æ‚¨èƒ½åœ¨ä¸ä½¿ç”¨é¢å¤–ç©ºé—´ä¸”æ—¶é—´å¤æ‚åº¦ä¸ºO(n)çš„æƒ…å†µä¸‹å®Œæˆè¿™ä¸ªä»»åŠ¡å—? ä½ å¯ä»¥å‡å®šè¿”å›çš„æ•°ç»„ä¸ç®—åœ¨é¢å¤–ç©ºé—´å†…ã€‚ ç¤ºä¾‹: è¾“å…¥: [4,3,2,7,8,2,3,1] è¾“å‡º: [5,6] PythonC++123456789101112131415class Solution(object): def findDisappearedNumbers(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[int] &quot;&quot;&quot; for v in nums: idx = abs(v) - 1 if nums[idx] &gt; 0: nums[idx] = -nums[idx] res = [] for i in xrange(len(nums)): if nums[i] &gt; 0: res.append(i + 1) return res1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; for (int i = 0; i &lt; nums.size(); i++) &#123; int idx = abs(nums[i]) - 1; if (nums[idx] &gt; 0) &#123; nums[idx] = -nums[idx]; &#125; &#125; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] &gt; 0) &#123; res.push_back(i + 1); &#125; &#125; return res; &#125;&#125;; 532. æ•°ç»„ä¸­çš„K-diffæ•°å¯¹ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„å’Œä¸€ä¸ªæ•´æ•° k, ä½ éœ€è¦åœ¨æ•°ç»„é‡Œæ‰¾åˆ°ä¸åŒçš„ k-diff æ•°å¯¹ã€‚è¿™é‡Œå°† k-diff æ•°å¯¹å®šä¹‰ä¸ºä¸€ä¸ªæ•´æ•°å¯¹ (i, j), å…¶ä¸­ i å’Œ j éƒ½æ˜¯æ•°ç»„ä¸­çš„æ•°å­—ï¼Œä¸”ä¸¤æ•°ä¹‹å·®çš„ç»å¯¹å€¼æ˜¯ k. ç¤ºä¾‹ 1: è¾“å…¥: [3, 1, 4, 1, 5], k = 2 è¾“å‡º: 2 è§£é‡Š: æ•°ç»„ä¸­æœ‰ä¸¤ä¸ª 2-diff æ•°å¯¹, (1, 3) å’Œ (3, 5)ã€‚ å°½ç®¡æ•°ç»„ä¸­æœ‰ä¸¤ä¸ª1ï¼Œä½†æˆ‘ä»¬åªåº”è¿”å›ä¸åŒçš„æ•°å¯¹çš„æ•°é‡ã€‚ ç¤ºä¾‹ 2: è¾“å…¥:[1, 2, 3, 4, 5], k = 1 è¾“å‡º: 4 è§£é‡Š: æ•°ç»„ä¸­æœ‰å››ä¸ª 1-diff æ•°å¯¹, (1, 2), (2, 3), (3, 4) å’Œ (4, 5)ã€‚ ç¤ºä¾‹ 3: è¾“å…¥: [1, 3, 1, 5, 4], k = 0 è¾“å‡º: 1 è§£é‡Š: æ•°ç»„ä¸­åªæœ‰ä¸€ä¸ª 0-diff æ•°å¯¹ï¼Œ(1, 1)ã€‚ æ³¨æ„: æ•°å¯¹ (i, j) å’Œæ•°å¯¹ (j, i) è¢«ç®—ä½œåŒä¸€æ•°å¯¹ã€‚ æ•°ç»„çš„é•¿åº¦ä¸è¶…è¿‡10,000ã€‚ æ‰€æœ‰è¾“å…¥çš„æ•´æ•°çš„èŒƒå›´åœ¨ [-1e7, 1e7]ã€‚ PythonC++123456789101112131415161718192021222324class Solution(object): def findPairs(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; if nums is None or len(nums) == 0 or k &lt; 0: return 0 m = &#123;&#125; for v in nums: if v not in m: m[v] = 1 else: m[v] += 1 res = 0 for key, val in m.iteritems(): if k == 0: if val &gt;= 2: res += 1 else: if key + k in m: res += 1 return res12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: int findPairs(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_map&lt;int, int&gt; m; int res = 0; for (auto n : nums) &#123; m[n]++; &#125; for (auto item : m) &#123; if (k == 0) &#123; if (item.second &gt; 1) &#123; res += 1; &#125; &#125; else if (k &gt; 0) &#123; if (m.find(item.first + k) != m.end()) &#123; res += 1; &#125; &#125; &#125; return res; &#125;&#125;; 581. æœ€çŸ­æ— åºè¿ç»­å­æ•°ç»„ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œä½ éœ€è¦å¯»æ‰¾ä¸€ä¸ªè¿ç»­çš„å­æ•°ç»„ï¼Œå¦‚æœå¯¹è¿™ä¸ªå­æ•°ç»„è¿›è¡Œå‡åºæ’åºï¼Œé‚£ä¹ˆæ•´ä¸ªæ•°ç»„éƒ½ä¼šå˜ä¸ºå‡åºæ’åºã€‚ ä½ æ‰¾åˆ°çš„å­æ•°ç»„åº”æ˜¯æœ€çŸ­çš„ï¼Œè¯·è¾“å‡ºå®ƒçš„é•¿åº¦ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [2, 6, 4, 8, 10, 9, 15] è¾“å‡º: 5 è§£é‡Š: ä½ åªéœ€è¦å¯¹ [6, 4, 8, 10, 9] è¿›è¡Œå‡åºæ’åºï¼Œé‚£ä¹ˆæ•´ä¸ªè¡¨éƒ½ä¼šå˜ä¸ºå‡åºæ’åºã€‚ è¯´æ˜ : è¾“å…¥çš„æ•°ç»„é•¿åº¦èŒƒå›´åœ¨ [1, 10,000]ã€‚ è¾“å…¥çš„æ•°ç»„å¯èƒ½åŒ…å«é‡å¤å…ƒç´  ï¼Œæ‰€ä»¥å‡åºçš„æ„æ€æ˜¯&lt;= PythonC++12345678910111213141516171819202122class Solution(object): def findUnsortedSubarray(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; sorted_nums = sorted(nums[:]) left, right = 0, len(nums) - 1 while left &lt; right: if sorted_nums[left] == nums[left]: left += 1 else: break while right &gt; left: if sorted_nums[right] == nums[right]: right -= 1 else: break if left &lt; right: return right - left + 1 else: return 012345678910111213141516171819202122232425#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; sorted_nums = nums; sort(sorted_nums.begin(), sorted_nums.end()); int left = 0, right = n - 1; while (left &lt; right &amp;&amp; nums[left] == sorted_nums[left]) &#123; left += 1; &#125; while (left &lt; right &amp;&amp; nums[right] == sorted_nums[right]) &#123; right -= 1; &#125; if (left &lt; right) &#123; return right - left + 1; &#125; return 0; &#125;&#125;; 605. ç§èŠ±é—®é¢˜å‡è®¾ä½ æœ‰ä¸€ä¸ªå¾ˆé•¿çš„èŠ±å›ï¼Œä¸€éƒ¨åˆ†åœ°å—ç§æ¤äº†èŠ±ï¼Œå¦ä¸€éƒ¨åˆ†å´æ²¡æœ‰ã€‚å¯æ˜¯ï¼ŒèŠ±å‰ä¸èƒ½ç§æ¤åœ¨ç›¸é‚»çš„åœ°å—ä¸Šï¼Œå®ƒä»¬ä¼šäº‰å¤ºæ°´æºï¼Œä¸¤è€…éƒ½ä¼šæ­»å»ã€‚ ç»™å®šä¸€ä¸ªèŠ±å›ï¼ˆè¡¨ç¤ºä¸ºä¸€ä¸ªæ•°ç»„åŒ…å«0å’Œ1ï¼Œå…¶ä¸­0è¡¨ç¤ºæ²¡ç§æ¤èŠ±ï¼Œ1è¡¨ç¤ºç§æ¤äº†èŠ±ï¼‰ï¼Œå’Œä¸€ä¸ªæ•° n ã€‚èƒ½å¦åœ¨ä¸æ‰“ç ´ç§æ¤è§„åˆ™çš„æƒ…å†µä¸‹ç§å…¥ n æœµèŠ±ï¼Ÿèƒ½åˆ™è¿”å›Trueï¼Œä¸èƒ½åˆ™è¿”å›Falseã€‚ ç¤ºä¾‹ 1: è¾“å…¥: flowerbed = [1,0,0,0,1], n = 1 è¾“å‡º: True ç¤ºä¾‹ 2: è¾“å…¥: flowerbed = [1,0,0,0,1], n = 2 è¾“å‡º: False æ³¨æ„: æ•°ç»„å†…å·²ç§å¥½çš„èŠ±ä¸ä¼šè¿åç§æ¤è§„åˆ™ã€‚ è¾“å…¥çš„æ•°ç»„é•¿åº¦èŒƒå›´ä¸º [1, 20000]ã€‚ n æ˜¯éè´Ÿæ•´æ•°ï¼Œä¸”ä¸ä¼šè¶…è¿‡è¾“å…¥æ•°ç»„çš„å¤§å°ã€‚ PythonC++1234567891011121314151617class Solution(object): def canPlaceFlowers(self, flowerbed, n): &quot;&quot;&quot; :type flowerbed: List[int] :type n: int :rtype: bool &quot;&quot;&quot; nums = [0] + flowerbed + [0] i = 1 cnt = 0 while i &lt; len(flowerbed) + 1: if nums[i - 1] == 0 and nums[i] == 0 and nums[i + 1] == 0: cnt += 1 i += 2 else: i += 1 return cnt &gt;= n1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) &#123; vector&lt;int&gt; nums = flowerbed; nums.insert(nums.begin(), 0); nums.insert(nums.end(), 0); int i = 1, cnt = 0; while (i &lt; nums.size() - 1) &#123; if (nums[i - 1] == 0 &amp;&amp; nums[i] == 0 &amp;&amp; nums[i + 1] == 0) &#123; cnt += 1; i += 2; &#125; else &#123; i += 1; &#125; &#125; return cnt &gt;= n; &#125;&#125;; 643. å­æ•°ç»„æœ€å¤§å¹³å‡æ•° Iç»™å®š n ä¸ªæ•´æ•°ï¼Œæ‰¾å‡ºå¹³å‡æ•°æœ€å¤§ä¸”é•¿åº¦ä¸º k çš„è¿ç»­å­æ•°ç»„ï¼Œå¹¶è¾“å‡ºè¯¥æœ€å¤§å¹³å‡æ•°ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [1,12,-5,-6,50,3], k = 4 è¾“å‡º: 12.75 è§£é‡Š: æœ€å¤§å¹³å‡æ•° (12-5-6+50)/4 = 51/4 = 12.75 æ³¨æ„: 1 &lt;= k &lt;= n &lt;= 30,000ã€‚ æ‰€ç»™æ•°æ®èŒƒå›´ [-10,000ï¼Œ10,000]ã€‚ PythonC++12345678910111213class Solution(object): def findMaxAverage(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: float &quot;&quot;&quot; res = sum(nums[:k]) sub_sum = res for i in xrange(k, len(nums)): sub_sum = sub_sum + nums[i] - nums[i - k] res = max(res, sub_sum) return res / (k * 1.0)1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: double findMaxAverage(vector&lt;int&gt;&amp; nums, int k) &#123; int tmp_sum = 0, res_sum = 0; for (int i = 0; i &lt; k; i++) &#123; tmp_sum += nums[i]; &#125; res_sum = tmp_sum; for (int i = k; i &lt; nums.size(); i++) &#123; tmp_sum = tmp_sum - nums[i - k] + nums[i]; res_sum = max(res_sum, tmp_sum); &#125; return res_sum * 1.0 / k; &#125;&#125;; 665. éé€’å‡æ•°åˆ— [n]ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º n çš„æ•´æ•°æ•°ç»„ï¼Œä½ çš„ä»»åŠ¡æ˜¯åˆ¤æ–­åœ¨æœ€å¤šæ”¹å˜ 1 ä¸ªå…ƒç´ çš„æƒ…å†µä¸‹ï¼Œè¯¥æ•°ç»„èƒ½å¦å˜æˆä¸€ä¸ªéé€’å‡æ•°åˆ—ã€‚ æˆ‘ä»¬æ˜¯è¿™æ ·å®šä¹‰ä¸€ä¸ªéé€’å‡æ•°åˆ—çš„ï¼š å¯¹äºæ•°ç»„ä¸­æ‰€æœ‰çš„ i (1 &lt;= i &lt; n)ï¼Œæ»¡è¶³ array[i] &lt;= array[i + 1]ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [4,2,3] è¾“å‡º: True è§£é‡Š: ä½ å¯ä»¥é€šè¿‡æŠŠç¬¬ä¸€ä¸ª4å˜æˆ1æ¥ä½¿å¾—å®ƒæˆä¸ºä¸€ä¸ªéé€’å‡æ•°åˆ—ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: [4,2,1] è¾“å‡º: False è§£é‡Š: ä½ ä¸èƒ½åœ¨åªæ”¹å˜ä¸€ä¸ªå…ƒç´ çš„æƒ…å†µä¸‹å°†å…¶å˜ä¸ºéé€’å‡æ•°åˆ—ã€‚ è¯´æ˜: n çš„èŒƒå›´ä¸º [1, 10,000]ã€‚ PythonC++123456789101112131415class Solution(object): def checkPossibility(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; cnt = 0 for i in xrange(1, len(nums)): if nums[i - 1] &gt; nums[i]: cnt += 1 if i - 2 &lt; 0 or nums[i - 2] &lt;= nums[i]: nums[i - 1] = nums[i] else: nums[i] = nums[i - 1] return cnt &lt;= 11234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: bool checkPossibility(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int cnt = 0; for (int i = 1; i &lt; n; i++) &#123; if (nums[i - 1] &gt; nums[i]) &#123; cnt += 1; if (i - 2 &lt; 0 || nums[i - 2] &lt;= nums[i]) &#123; nums[i - 1] = nums[i]; &#125; else &#123; nums[i] = nums[i - 1]; &#125; &#125; &#125; return cnt &lt;= 1; &#125;&#125;; 674. æœ€é•¿è¿ç»­é€’å¢åºåˆ—ç»™å®šä¸€ä¸ªæœªç»æ’åºçš„æ•´æ•°æ•°ç»„ï¼Œæ‰¾åˆ°æœ€é•¿ä¸”è¿ç»­çš„çš„é€’å¢åºåˆ—ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [1,3,5,4,7] è¾“å‡º: 3 è§£é‡Š: æœ€é•¿è¿ç»­é€’å¢åºåˆ—æ˜¯ [1,3,5], é•¿åº¦ä¸º3ã€‚ å°½ç®¡ [1,3,5,7] ä¹Ÿæ˜¯å‡åºçš„å­åºåˆ—, ä½†å®ƒä¸æ˜¯è¿ç»­çš„ï¼Œå› ä¸º5å’Œ7åœ¨åŸæ•°ç»„é‡Œè¢«4éš”å¼€ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: [2,2,2,2,2] è¾“å‡º: 1 è§£é‡Š: æœ€é•¿è¿ç»­é€’å¢åºåˆ—æ˜¯ [2], é•¿åº¦ä¸º1ã€‚ æ³¨æ„ï¼šæ•°ç»„é•¿åº¦ä¸ä¼šè¶…è¿‡10000ã€‚ PythonC++123456789101112131415161718class Solution(object): def findLengthOfLCIS(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; cnt = 0 max_cnt = 0 for i, v in enumerate(nums): if i == 0: cnt, max_cnt = 1, 1 else: if nums[i - 1] &lt; v: cnt += 1 max_cnt = max(max_cnt, cnt) else: cnt = 1 return max_cnt123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n == 0) &#123; return 0; &#125; int cnt = 1, max_cnt = 1; for (int i = 1; i &lt; nums.size(); i++) &#123; if (nums[i - 1] &lt; nums[i]) &#123; cnt += 1; max_cnt = max(max_cnt, cnt); &#125; else &#123; cnt = 1; &#125; &#125; return max_cnt; &#125;&#125;; 697. æ•°ç»„çš„åº¦ [n]ç»™å®šä¸€ä¸ªéç©ºä¸”åªåŒ…å«éè´Ÿæ•°çš„æ•´æ•°æ•°ç»„nums, æ•°ç»„çš„åº¦çš„å®šä¹‰æ˜¯æŒ‡æ•°ç»„é‡Œä»»ä¸€å…ƒç´ å‡ºç°é¢‘æ•°çš„æœ€å¤§å€¼ã€‚ ä½ çš„ä»»åŠ¡æ˜¯æ‰¾åˆ°ä¸ nums æ‹¥æœ‰ç›¸åŒå¤§å°çš„åº¦çš„æœ€çŸ­è¿ç»­å­æ•°ç»„ï¼Œè¿”å›å…¶é•¿åº¦ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [1, 2, 2, 3, 1] è¾“å‡º: 2 è§£é‡Š: è¾“å…¥æ•°ç»„çš„åº¦æ˜¯2ï¼Œå› ä¸ºå…ƒç´ 1å’Œ2çš„å‡ºç°é¢‘æ•°æœ€å¤§ï¼Œå‡ä¸º2. è¿ç»­å­æ•°ç»„é‡Œé¢æ‹¥æœ‰ç›¸åŒåº¦çš„æœ‰å¦‚ä¸‹æ‰€ç¤º: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] æœ€çŸ­è¿ç»­å­æ•°ç»„[2, 2]çš„é•¿åº¦ä¸º2ï¼Œæ‰€ä»¥è¿”å›2. ç¤ºä¾‹ 2: è¾“å…¥: [1,2,2,3,1,4,2] è¾“å‡º: 6 æ³¨æ„: nums.length åœ¨1åˆ°50,000åŒºé—´èŒƒå›´å†…ã€‚ nums[i] æ˜¯ä¸€ä¸ªåœ¨0åˆ°49,999èŒƒå›´å†…çš„æ•´æ•°ã€‚ PythonC++123456789101112131415161718192021222324class Solution(object): def findShortestSubArray(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; m = &#123;&#125; for i, v in enumerate(nums): if v not in m: m[v] = [1, i, i] else: m[v][0] += 1 m[v][2] = i res = len(nums) max_cnt = 0 for key, item in m.iteritems(): if item[0] &gt; max_cnt: max_cnt = item[0] res = item[2] - item[1] + 1 elif item[0] == max_cnt: cur_len = item[2] - item[1] + 1 if res &gt; cur_len: res = cur_len return res1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: int findShortestSubArray(vector&lt;int&gt;&amp; nums) &#123; int max_cnt = 0; int n = nums.size(); int res = n; unordered_map&lt;int, int&gt; m; unordered_map&lt;int, pair&lt;int, int&gt; &gt; index; for (int i = 0; i &lt; nums.size(); i++) &#123; m[nums[i]]++; if (m[nums[i]] == 1) &#123; index[nums[i]] = make_pair(i, i); &#125; else &#123; index[nums[i]].second = i; &#125; max_cnt = max(max_cnt, m[nums[i]]); &#125; for (auto item : m) &#123; if (item.second == max_cnt) &#123; res = min(res, index[item.first].second - index[item.first].first + 1); &#125; &#125; return res; &#125;&#125;; 746. ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯ [n]æ•°ç»„çš„æ¯ä¸ªç´¢å¼•åšä¸ºä¸€ä¸ªé˜¶æ¢¯ï¼Œç¬¬ iä¸ªé˜¶æ¢¯å¯¹åº”ç€ä¸€ä¸ªéè´Ÿæ•°çš„ä½“åŠ›èŠ±è´¹å€¼ costiã€‚ æ¯å½“ä½ çˆ¬ä¸Šä¸€ä¸ªé˜¶æ¢¯ä½ éƒ½è¦èŠ±è´¹å¯¹åº”çš„ä½“åŠ›èŠ±è´¹å€¼ï¼Œç„¶åä½ å¯ä»¥é€‰æ‹©ç»§ç»­çˆ¬ä¸€ä¸ªé˜¶æ¢¯æˆ–è€…çˆ¬ä¸¤ä¸ªé˜¶æ¢¯ã€‚ æ‚¨éœ€è¦æ‰¾åˆ°è¾¾åˆ°æ¥¼å±‚é¡¶éƒ¨çš„æœ€ä½èŠ±è´¹ã€‚åœ¨å¼€å§‹æ—¶ï¼Œä½ å¯ä»¥é€‰æ‹©ä»ç´¢å¼•ä¸º 0 æˆ– 1 çš„å…ƒç´ ä½œä¸ºåˆå§‹é˜¶æ¢¯ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: cost = [10, 15, 20] è¾“å‡º: 15 è§£é‡Š: æœ€ä½èŠ±è´¹æ˜¯ä»cost[1]å¼€å§‹ï¼Œç„¶åèµ°ä¸¤æ­¥å³å¯åˆ°é˜¶æ¢¯é¡¶ï¼Œä¸€å…±èŠ±è´¹15ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] è¾“å‡º: 6 è§£é‡Š: æœ€ä½èŠ±è´¹æ–¹å¼æ˜¯ä»cost[0]å¼€å§‹ï¼Œé€ä¸ªç»è¿‡é‚£äº›1ï¼Œè·³è¿‡cost[3]ï¼Œä¸€å…±èŠ±è´¹6ã€‚ æ³¨æ„ï¼š cost çš„é•¿åº¦å°†ä¼šåœ¨ [2, 1000]ã€‚ æ¯ä¸€ä¸ª cost[i] å°†ä¼šæ˜¯ä¸€ä¸ªIntegerç±»å‹ï¼ŒèŒƒå›´ä¸º [0, 999]ã€‚ PythonC++1234567891011121314class Solution(object): def minCostClimbingStairs(self, cost): &quot;&quot;&quot; :type cost: List[int] :rtype: int &quot;&quot;&quot; n = len(cost) dp = [0 for _ in xrange(n + 1)] dp[0] = cost[0] dp[1] = cost[1] for i in xrange(2, n + 1): cost_v = cost[i] if i != n else 0 dp[i] = min(dp[i - 1], dp[i - 2]) + cost_v return dp[n]12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; int n = cost.size(); vector&lt;int&gt; dp(n + 1, 0); dp[0] = cost[0]; dp[1] = cost[1]; for (int i = 2; i &lt; n + 1; i++) &#123; int cur_cost = i == n ? 0 : cost[i]; dp[i] = min(dp[i - 1], dp[i - 2]) + cur_cost; &#125; return dp[n]; &#125;&#125;; 849. åˆ°æœ€è¿‘çš„äººçš„æœ€å¤§è·ç¦» [n]åœ¨ä¸€æ’åº§ä½ï¼ˆ seatsï¼‰ä¸­ï¼Œ1 ä»£è¡¨æœ‰äººååœ¨åº§ä½ä¸Šï¼Œ0 ä»£è¡¨åº§ä½ä¸Šæ˜¯ç©ºçš„ã€‚ è‡³å°‘æœ‰ä¸€ä¸ªç©ºåº§ä½ï¼Œä¸”è‡³å°‘æœ‰ä¸€äººååœ¨åº§ä½ä¸Šã€‚ äºšå†å…‹æ–¯å¸Œæœ›ååœ¨ä¸€ä¸ªèƒ½å¤Ÿä½¿ä»–ä¸ç¦»ä»–æœ€è¿‘çš„äººä¹‹é—´çš„è·ç¦»è¾¾åˆ°æœ€å¤§åŒ–çš„åº§ä½ä¸Šã€‚ è¿”å›ä»–åˆ°ç¦»ä»–æœ€è¿‘çš„äººçš„æœ€å¤§è·ç¦»ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼š[1,0,0,0,1,0,1] è¾“å‡ºï¼š2 è§£é‡Šï¼š å¦‚æœäºšå†å…‹æ–¯ååœ¨ç¬¬äºŒä¸ªç©ºä½ï¼ˆseats[2]ï¼‰ä¸Šï¼Œä»–åˆ°ç¦»ä»–æœ€è¿‘çš„äººçš„è·ç¦»ä¸º 2 ã€‚ å¦‚æœäºšå†å…‹æ–¯ååœ¨å…¶å®ƒä»»ä½•ä¸€ä¸ªç©ºä½ä¸Šï¼Œä»–åˆ°ç¦»ä»–æœ€è¿‘çš„äººçš„è·ç¦»ä¸º 1 ã€‚ å› æ­¤ï¼Œä»–åˆ°ç¦»ä»–æœ€è¿‘çš„äººçš„æœ€å¤§è·ç¦»æ˜¯ 2 ã€‚ ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼š[1,0,0,0] è¾“å‡ºï¼š3 è§£é‡Šï¼š å¦‚æœäºšå†å…‹æ–¯ååœ¨æœ€åä¸€ä¸ªåº§ä½ä¸Šï¼Œä»–ç¦»æœ€è¿‘çš„äººæœ‰ 3 ä¸ªåº§ä½è¿œã€‚ è¿™æ˜¯å¯èƒ½çš„æœ€å¤§è·ç¦»ï¼Œæ‰€ä»¥ç­”æ¡ˆæ˜¯ 3 ã€‚ æç¤ºï¼š 1 &lt;= seats.length &lt;= 20000 seats ä¸­åªå«æœ‰ 0 å’Œ 1ï¼Œè‡³å°‘æœ‰ä¸€ä¸ª 0ï¼Œä¸”è‡³å°‘æœ‰ä¸€ä¸ª 1ã€‚ PythonC++12345678910111213141516171819class Solution(object): def maxDistToClosest(self, seats): &quot;&quot;&quot; :type seats: List[int] :rtype: int &quot;&quot;&quot; left = -1 max_dis = 0 for i, v in enumerate(seats): if v == 0: continue if left == -1: max_dis = max(max_dis, i) else: max_dis = max(max_dis, (i - left) / 2) left = i if seats[-1] == 0: max_dis = max(max_dis, len(seats) - 1 - left) return max_dis1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: int maxDistToClosest(vector&lt;int&gt;&amp; seats) &#123; vector&lt;int&gt; persons; for (int i = 0; i &lt; seats.size(); i++) &#123; if (seats[i] == 1) &#123; persons.push_back(i); &#125; &#125; int n = persons.size(), m = seats.size(); int res = 0; for (int i = 0; i &lt; n; i++) &#123; if (i == 0) &#123; res = max(res, persons[i]); &#125; else &#123; res = max(res, (persons[i] - persons[i - 1]) / 2); &#125; &#125; if (n &gt; 0) &#123; res = max(res, m - 1 - persons.back()); &#125; return res; &#125;&#125;; 941. æœ‰æ•ˆçš„å±±è„‰æ•°ç»„ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ Aï¼Œå¦‚æœå®ƒæ˜¯æœ‰æ•ˆçš„å±±è„‰æ•°ç»„å°±è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚ è®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹ï¼Œå¦‚æœ A æ»¡è¶³ä¸‹è¿°æ¡ä»¶ï¼Œé‚£ä¹ˆå®ƒæ˜¯ä¸€ä¸ªå±±è„‰æ•°ç»„ï¼š A.length &gt;= 3 åœ¨ 0 &lt; i &lt; A.length - 1 æ¡ä»¶ä¸‹ï¼Œå­˜åœ¨ i ä½¿å¾—ï¼š A[0] &lt; A[1] &lt; â€¦ A[i-1] &lt; A[i] A[i] &gt; A[i+1] &gt; â€¦ &gt; A[B.length - 1] ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼š[2,1] è¾“å‡ºï¼šfalse ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼š[3,5,5] è¾“å‡ºï¼šfalse ç¤ºä¾‹ 3ï¼š è¾“å…¥ï¼š[0,3,2,1] è¾“å‡ºï¼štrue æç¤ºï¼š 0 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt;= 10000 PythonC++123456789101112class Solution(object): def validMountainArray(self, A): &quot;&quot;&quot; :type A: List[int] :rtype: bool &quot;&quot;&quot; left, right = 0, len(A) - 1 while left + 1 &lt; len(A) and A[left] &lt; A[left + 1]: left += 1 while right - 1 &gt;= 0 and A[right] &lt; A[right - 1]: right -= 1 return left != 0 and right != len(A) - 1 and left == right1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123; public: bool validMountainArray(vector&lt;int&gt;&amp; A) &#123; int n = A.size(); int left = 0; int right = n - 1; while (left &lt; n - 1 &amp;&amp; A[left] &lt; A[left + 1]) &#123; left += 1; &#125; while (right &gt; 0 &amp;&amp; A[right] &lt; A[right - 1]) &#123; right -= 1; &#125; return left != 0 &amp;&amp; right != n - 1 &amp;&amp; left == right; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCodeä¹‹æ•°ç»„(ä¸­ç­‰)","slug":"LeetCode-æ•°ç»„-ä¸­ç­‰","date":"2020-12-31T13:25:17.000Z","updated":"2021-01-02T05:33:37.278Z","comments":false,"path":"posts/3239008047.html","link":"","permalink":"https://leel0330.github.io/posts/3239008047.html","excerpt":"æ•°ç»„(ä¸­ç­‰)çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚","text":"æ•°ç»„(ä¸­ç­‰)çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ 31. ä¸‹ä¸€ä¸ªæ’åˆ— [n]å®ç°è·å–ä¸‹ä¸€ä¸ªæ’åˆ—çš„å‡½æ•°ï¼Œç®—æ³•éœ€è¦å°†ç»™å®šæ•°å­—åºåˆ—é‡æ–°æ’åˆ—æˆå­—å…¸åºä¸­ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ’åˆ—ã€‚ å¦‚æœä¸å­˜åœ¨ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ’åˆ—ï¼Œåˆ™å°†æ•°å­—é‡æ–°æ’åˆ—æˆæœ€å°çš„æ’åˆ—ï¼ˆå³å‡åºæ’åˆ—ï¼‰ã€‚ å¿…é¡»åŸåœ°ä¿®æ”¹ï¼Œåªå…è®¸ä½¿ç”¨é¢å¤–å¸¸æ•°ç©ºé—´ã€‚ ä»¥ä¸‹æ˜¯ä¸€äº›ä¾‹å­ï¼Œè¾“å…¥ä½äºå·¦ä¾§åˆ—ï¼Œå…¶ç›¸åº”è¾“å‡ºä½äºå³ä¾§åˆ—ã€‚ 1,2,3 â†’ 1,3,2 3,2,1 â†’ 1,2,3 1,1,5 â†’ 1,5,1 1234567891011121314151617181920212223class Solution(object): def nextPermutation(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. &quot;&quot;&quot; n = len(nums) i = n - 2 while i &gt;= 0 and nums[i + 1] &lt;= nums[i]: i -= 1 if i &gt;= 0: j = n - 1 while nums[j] &lt;= nums[i]: j -= 1 nums[i], nums[j] = nums[j], nums[i] self.helper(nums, i + 1, n - 1) def helper(self, nums, i, j): s, e = i, j while s &lt; e: nums[s], nums[e] = nums[e], nums[s] s += 1 e -= 1 40. ç»„åˆæ€»å’Œ IIç»™å®šä¸€ä¸ªæ•°ç»„ candidates å’Œä¸€ä¸ªç›®æ ‡æ•° target ï¼Œæ‰¾å‡º candidates ä¸­æ‰€æœ‰å¯ä»¥ä½¿æ•°å­—å’Œä¸º target çš„ç»„åˆã€‚ candidates ä¸­çš„æ¯ä¸ªæ•°å­—åœ¨æ¯ä¸ªç»„åˆä¸­åªèƒ½ä½¿ç”¨ä¸€æ¬¡ã€‚ è¯´æ˜ï¼š æ‰€æœ‰æ•°å­—ï¼ˆåŒ…æ‹¬ç›®æ ‡æ•°ï¼‰éƒ½æ˜¯æ­£æ•´æ•°ã€‚ è§£é›†ä¸èƒ½åŒ…å«é‡å¤çš„ç»„åˆã€‚ ç¤ºä¾‹ 1: è¾“å…¥: candidates = [10,1,2,7,6,1,5], target = 8, æ‰€æ±‚è§£é›†ä¸º: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] ç¤ºä¾‹ 2: è¾“å…¥: candidates = [2,5,2,1,2], target = 5, æ‰€æ±‚è§£é›†ä¸º: [ [1,2,2], [5] ] PythonJava123456789101112131415161718192021222324class Solution(object): def combinationSum2(self, candidates, target): &quot;&quot;&quot; :type candidates: List[int] :type target: int :rtype: List[List[int]] &quot;&quot;&quot; candidates = sorted(candidates) item, res = [], [] self.helper(candidates, target, 0, item, res) return res def helper(self, candidates, target, idx, item, res): if sum(item) == target: res.append(item[:]) return for i in xrange(idx, len(candidates)): if i &gt; idx and candidates[i] == candidates[i - 1]: continue if sum(item) + candidates[i] &gt; target: continue item.append(candidates[i]) self.helper(candidates, target, i + 1, item, res) item.pop(-1)123456789101112131415161718192021222324252627282930class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; item = new ArrayList&lt;&gt;(); helper(candidates, 0, target, item, res); return res; &#125; private void helper(int[] candidates, int idx, int target, List&lt;Integer&gt; item, List&lt;List&lt;Integer&gt;&gt; res) &#123; if (target &lt; 0) &#123; return; &#125; if (target == 0) &#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); tmp.addAll(item); res.add(tmp); return; &#125; for (int i = idx; i &lt; candidates.length; i++) &#123; if (i &gt; idx &amp;&amp; candidates[i] == candidates[i - 1]) &#123; continue; &#125; item.add(candidates[i]); helper(candidates, i + 1, target - candidates[i], item, res); item.remove(item.size() - 1); &#125; &#125;&#125; 55. è·³è·ƒæ¸¸æˆ [n]ç»™å®šä¸€ä¸ªéè´Ÿæ•´æ•°æ•°ç»„ï¼Œä½ æœ€åˆä½äºæ•°ç»„çš„ç¬¬ä¸€ä¸ªä½ç½®ã€‚ æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ä»£è¡¨ä½ åœ¨è¯¥ä½ç½®å¯ä»¥è·³è·ƒçš„æœ€å¤§é•¿åº¦ã€‚ åˆ¤æ–­ä½ æ˜¯å¦èƒ½å¤Ÿåˆ°è¾¾æœ€åä¸€ä¸ªä½ç½®ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [2,3,1,1,4] è¾“å‡º: true è§£é‡Š: ä»ä½ç½® 0 åˆ° 1 è·³ 1 æ­¥, ç„¶åè·³ 3 æ­¥åˆ°è¾¾æœ€åä¸€ä¸ªä½ç½®ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: [3,2,1,0,4] è¾“å‡º: false è§£é‡Š: æ— è®ºæ€æ ·ï¼Œä½ æ€»ä¼šåˆ°è¾¾ç´¢å¼•ä¸º 3 çš„ä½ç½®ã€‚ä½†è¯¥ä½ç½®çš„æœ€å¤§è·³è·ƒé•¿åº¦æ˜¯ 0 ï¼Œ æ‰€ä»¥ä½ æ°¸è¿œä¸å¯èƒ½åˆ°è¾¾æœ€åä¸€ä¸ªä½ç½®ã€‚ 1234567891011class Solution(object): def canJump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; last_pos = len(nums) - 1 for i in xrange(len(nums) - 1, -1, -1): if i + nums[i] &gt;= last_pos: last_pos = i return last_pos == 0 73. çŸ©é˜µç½®é›¶ç»™å®šä¸€ä¸ª m x n çš„çŸ©é˜µï¼Œå¦‚æœä¸€ä¸ªå…ƒç´ ä¸º 0ï¼Œåˆ™å°†å…¶æ‰€åœ¨è¡Œå’Œåˆ—çš„æ‰€æœ‰å…ƒç´ éƒ½è®¾ä¸º 0ã€‚è¯·ä½¿ç”¨åŸåœ°ç®—æ³•ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [ [1,1,1], [1,0,1], [1,1,1] ] è¾“å‡º: [ [1,0,1], [0,0,0], [1,0,1] ] ç¤ºä¾‹ 2: è¾“å…¥: [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] è¾“å‡º: [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] è¿›é˜¶: ä¸€ä¸ªç›´æ¥çš„è§£å†³æ–¹æ¡ˆæ˜¯ä½¿ç”¨ O(mn) çš„é¢å¤–ç©ºé—´ï¼Œä½†è¿™å¹¶ä¸æ˜¯ä¸€ä¸ªå¥½çš„è§£å†³æ–¹æ¡ˆã€‚ ä¸€ä¸ªç®€å•çš„æ”¹è¿›æ–¹æ¡ˆæ˜¯ä½¿ç”¨ O(m + n) çš„é¢å¤–ç©ºé—´ï¼Œä½†è¿™ä»ç„¶ä¸æ˜¯æœ€å¥½çš„è§£å†³æ–¹æ¡ˆã€‚ ä½ èƒ½æƒ³å‡ºä¸€ä¸ªå¸¸æ•°ç©ºé—´çš„è§£å†³æ–¹æ¡ˆå—ï¼Ÿ 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def setZeroes(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: None Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; rows = len(matrix) cols = len(matrix[0]) row0_flag = False col0_flag = False # æ‰¾ç¬¬ä¸€è¡Œæ˜¯å¦æœ‰0 for j in range(cols): if matrix[0][j] == 0: row0_flag = True break # ç¬¬ä¸€åˆ—æ˜¯å¦æœ‰0 for i in range(rows): if matrix[i][0] == 0: col0_flag = True break # æŠŠç¬¬ä¸€è¡Œæˆ–è€…ç¬¬ä¸€åˆ—ä½œä¸º æ ‡å¿—ä½ for i in range(1, rows): for j in range(1, cols): if matrix[i][j] == 0: matrix[i][0] = matrix[0][j] = 0 # ç½®0 for i in range(1, rows): for j in range(1, cols): if matrix[i][0] == 0 or matrix[0][j] == 0: matrix[i][j] = 0 if row0_flag: for j in range(cols): matrix[0][j] = 0 if col0_flag: for i in range(rows): matrix[i][0] = 0 81. æœç´¢æ—‹è½¬æ’åºæ•°ç»„ IIå‡è®¾æŒ‰ç…§å‡åºæ’åºçš„æ•°ç»„åœ¨é¢„å…ˆæœªçŸ¥çš„æŸä¸ªç‚¹ä¸Šè¿›è¡Œäº†æ—‹è½¬ã€‚ ( ä¾‹å¦‚ï¼Œæ•°ç»„ [0,0,1,2,2,5,6] å¯èƒ½å˜ä¸º [2,5,6,0,0,1,2] )ã€‚ ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥åˆ¤æ–­ç»™å®šçš„ç›®æ ‡å€¼æ˜¯å¦å­˜åœ¨äºæ•°ç»„ä¸­ã€‚è‹¥å­˜åœ¨è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚ ç¤ºä¾‹ 1: è¾“å…¥: nums = [2,5,6,0,0,1,2], target = 0 è¾“å‡º: true ç¤ºä¾‹ 2: è¾“å…¥: nums = [2,5,6,0,0,1,2], target = 3 è¾“å‡º: false è¿›é˜¶: è¿™æ˜¯ æœç´¢æ—‹è½¬æ’åºæ•°ç»„ çš„å»¶ä¼¸é¢˜ç›®ï¼Œæœ¬é¢˜ä¸­çš„ nums å¯èƒ½åŒ…å«é‡å¤å…ƒç´ ã€‚ è¿™ä¼šå½±å“åˆ°ç¨‹åºçš„æ—¶é—´å¤æ‚åº¦å—ï¼Ÿä¼šæœ‰æ€æ ·çš„å½±å“ï¼Œä¸ºä»€ä¹ˆï¼Ÿ PythonJava12345678910111213141516171819202122232425class Solution(object): def search(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: bool &quot;&quot;&quot; left, right = 0, len(nums) - 1 while left &lt;= right: mid = (left + right) / 2 if nums[mid] == target: return True if nums[mid] &gt; nums[left]: if nums[left] &lt;= target &lt; nums[mid]: right = mid - 1 else: left = mid + 1 elif nums[mid] &lt; nums[left]: if nums[mid] &lt; target &lt;= nums[right]: left = mid + 1 else: right = mid - 1 else: left += 1 return False123456789101112131415161718192021222324252627282930class Solution &#123; public boolean search(int[] nums, int target) &#123; if (nums == null || nums.length == 0) &#123; return false; &#125; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; return true; &#125; if (nums[mid] &gt; nums[left]) &#123; if (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; else if (nums[mid] &lt; nums[left]) &#123; if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; else &#123; left += 1; &#125; &#125; return false; &#125;&#125; 90. å­é›† IIç»™å®šä¸€ä¸ªå¯èƒ½åŒ…å«é‡å¤å…ƒç´ çš„æ•´æ•°æ•°ç»„ numsï¼Œè¿”å›è¯¥æ•°ç»„æ‰€æœ‰å¯èƒ½çš„å­é›†ï¼ˆå¹‚é›†ï¼‰ã€‚ è¯´æ˜ï¼šè§£é›†ä¸èƒ½åŒ…å«é‡å¤çš„å­é›†ã€‚ ç¤ºä¾‹: è¾“å…¥: [1,2,2] è¾“å‡º: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] PythonJava12345678910111213141516171819class Solution(object): def subsetsWithDup(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; nums = sorted(nums) item, res = [], [] self.helper(nums, 0, item, res) return res def helper(self, nums, idx, item, res): res.append(item[:]) for i in xrange(idx, len(nums)): if i &gt; idx and nums[i] == nums[i - 1]: continue item.append(nums[i]) self.helper(nums, i + 1, item, res) item.pop(-1)1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (nums == null || nums.length == 0) &#123; return res; &#125; Arrays.sort(nums); List&lt;Integer&gt; item = new ArrayList&lt;&gt;(); helper(nums, 0, item, res); return res; &#125; private void helper(int[] nums, int idx, List&lt;Integer&gt; item, List&lt;List&lt;Integer&gt;&gt; res) &#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); tmp.addAll(item); res.add(tmp); if (idx == nums.length) &#123; return; &#125; for (int i = idx; i &lt; nums.length; i++) &#123; if (i &gt; idx &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; item.add(nums[i]); helper(nums, i + 1, item, res); item.remove(item.size() - 1); &#125; &#125;&#125; 153. å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼å‡è®¾æŒ‰ç…§å‡åºæ’åºçš„æ•°ç»„åœ¨é¢„å…ˆæœªçŸ¥çš„æŸä¸ªç‚¹ä¸Šè¿›è¡Œäº†æ—‹è½¬ã€‚ ( ä¾‹å¦‚ï¼Œæ•°ç»„ [0,1,2,4,5,6,7] å¯èƒ½å˜ä¸º [4,5,6,7,0,1,2] )ã€‚ è¯·æ‰¾å‡ºå…¶ä¸­æœ€å°çš„å…ƒç´ ã€‚ ä½ å¯ä»¥å‡è®¾æ•°ç»„ä¸­ä¸å­˜åœ¨é‡å¤å…ƒç´ ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [3,4,5,1,2] è¾“å‡º: 1 ç¤ºä¾‹ 2: è¾“å…¥: [4,5,6,7,0,1,2] è¾“å‡º: 0 PythonJava1234567891011121314class Solution(object): def findMin(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; left, right = 0, len(nums) - 1 while left &lt; right: mid = left + (right - left) / 2 if nums[mid] &gt; nums[right]: left = mid + 1 else: right = mid return nums[left]1234567891011121314class Solution &#123; public int findMin(int[] nums) &#123; int left = 0, right = nums.length - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &gt; nums[right]) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return nums[left]; &#125;&#125; 287. å¯»æ‰¾é‡å¤æ•° [n]ç»™å®šä¸€ä¸ªåŒ…å« n + 1 ä¸ªæ•´æ•°çš„æ•°ç»„ numsï¼Œå…¶æ•°å­—éƒ½åœ¨ 1 åˆ° n ä¹‹é—´ï¼ˆåŒ…æ‹¬ 1 å’Œ nï¼‰ï¼Œå¯çŸ¥è‡³å°‘å­˜åœ¨ä¸€ä¸ªé‡å¤çš„æ•´æ•°ã€‚å‡è®¾åªæœ‰ä¸€ä¸ªé‡å¤çš„æ•´æ•°ï¼Œæ‰¾å‡ºè¿™ä¸ªé‡å¤çš„æ•°ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [1,3,4,2,2] è¾“å‡º: 2 ç¤ºä¾‹ 2: è¾“å…¥: [3,1,3,4,2] è¾“å‡º: 3 è¯´æ˜ï¼š ä¸èƒ½æ›´æ”¹åŸæ•°ç»„ï¼ˆå‡è®¾æ•°ç»„æ˜¯åªè¯»çš„ï¼‰ã€‚ åªèƒ½ä½¿ç”¨é¢å¤–çš„ O(1) çš„ç©ºé—´ã€‚ æ—¶é—´å¤æ‚åº¦å°äº O(n2) ã€‚ æ•°ç»„ä¸­åªæœ‰ä¸€ä¸ªé‡å¤çš„æ•°å­—ï¼Œä½†å®ƒå¯èƒ½ä¸æ­¢é‡å¤å‡ºç°ä¸€æ¬¡ã€‚ PythonJava1234567891011121314151617class Solution(object): def findDuplicate(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; fast, slow = nums[0], nums[0] while True: fast = nums[nums[fast]] slow = nums[slow] if fast == slow: break slow = nums[0] while slow != fast: slow = nums[slow] fast = nums[fast] return slow123456789101112131415161718class Solution &#123; public int findDuplicate(int[] nums) &#123; int slow = nums[0], fast = nums[0]; while (true) &#123; slow = nums[slow]; fast = nums[nums[fast]]; if (slow == fast) &#123; break; &#125; &#125; slow = nums[0]; while (slow != fast) &#123; slow = nums[slow]; fast = nums[fast]; &#125; return slow; &#125;&#125; 560. å’Œä¸ºKçš„å­æ•°ç»„ [n]ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„å’Œä¸€ä¸ªæ•´æ•° kï¼Œä½ éœ€è¦æ‰¾åˆ°è¯¥æ•°ç»„ä¸­å’Œä¸º k çš„è¿ç»­çš„å­æ•°ç»„çš„ä¸ªæ•°ã€‚ ç¤ºä¾‹ 1 : è¾“å…¥:nums = [1,1,1], k = 2 è¾“å‡º: 2 , [1,1] ä¸ [1,1] ä¸ºä¸¤ç§ä¸åŒçš„æƒ…å†µã€‚ è¯´æ˜ : æ•°ç»„çš„é•¿åº¦ä¸º [1, 20,000]ã€‚ æ•°ç»„ä¸­å…ƒç´ çš„èŒƒå›´æ˜¯ [-1000, 1000] ï¼Œä¸”æ•´æ•° k çš„èŒƒå›´æ˜¯ [-1e7, 1e7]ã€‚ 123456789101112131415161718class Solution(object): def subarraySum(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; res, cur_sum, m = 0, 0, &#123;0:1&#125; n = len(nums) for i in xrange(n): cur_sum += nums[i] if cur_sum - k in m: res += m[cur_sum - k] if cur_sum in m: m[cur_sum] += 1 else: m[cur_sum] = 1 return res 670. æœ€å¤§äº¤æ¢ç»™å®šä¸€ä¸ªéè´Ÿæ•´æ•°ï¼Œä½ è‡³å¤šå¯ä»¥äº¤æ¢ä¸€æ¬¡æ•°å­—ä¸­çš„ä»»æ„ä¸¤ä½ã€‚è¿”å›ä½ èƒ½å¾—åˆ°çš„æœ€å¤§å€¼ã€‚ ç¤ºä¾‹ 1 : è¾“å…¥: 2736 è¾“å‡º: 7236 è§£é‡Š: äº¤æ¢æ•°å­—2å’Œæ•°å­—7ã€‚ ç¤ºä¾‹ 2 : è¾“å…¥: 9973 è¾“å‡º: 9973 è§£é‡Š: ä¸éœ€è¦äº¤æ¢ã€‚ æ³¨æ„: ç»™å®šæ•°å­—çš„èŒƒå›´æ˜¯ [0, 108] 1234567891011121314151617181920class Solution(object): def maximumSwap(self, num): &quot;&quot;&quot; :type num: int :rtype: int &quot;&quot;&quot; nums = [int(c) for c in str(num)] sorted_nums = sorted(nums[:], reverse=True) i, n = 0, len(nums) while i &lt; n: if nums[i] != sorted_nums[i]: break i += 1 if i == n: return num j = n - 1 while j &gt; i and nums[j] != sorted_nums[i]: j -= 1 nums[i], nums[j] = nums[j], nums[i] return int(&#x27;&#x27;.join([str(c) for c in nums])) 713. ä¹˜ç§¯å°äºKçš„å­æ•°ç»„ç»™å®šä¸€ä¸ªæ­£æ•´æ•°æ•°ç»„ numsã€‚ æ‰¾å‡ºè¯¥æ•°ç»„å†…ä¹˜ç§¯å°äº k çš„è¿ç»­çš„å­æ•°ç»„çš„ä¸ªæ•°ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: nums = [10,5,2,6], k = 100 è¾“å‡º: 8 è§£é‡Š: 8ä¸ªä¹˜ç§¯å°äº100çš„å­æ•°ç»„åˆ†åˆ«ä¸º: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ [10,5,2] å¹¶ä¸æ˜¯ä¹˜ç§¯å°äº100çš„å­æ•°ç»„ã€‚ è¯´æ˜: 0 &lt; nums.length &lt;= 50000 0 &lt; nums[i] &lt; 1000 0 &lt;= k &lt; 10^6 123456789101112131415161718class Solution(object): def numSubarrayProductLessThanK(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; n = len(nums) left, right, res = 0, 0, 0 cur_val = 1 while right &lt; n: cur_val *= nums[right] while left &lt;= right and cur_val &gt;= k: cur_val /= nums[left] left += 1 res += (right - left + 1) right += 1 return res 714. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºå«æ‰‹ç»­è´¹ [n]ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ pricesï¼Œå…¶ä¸­ç¬¬ i ä¸ªå…ƒç´ ä»£è¡¨äº†ç¬¬ i å¤©çš„è‚¡ç¥¨ä»·æ ¼ ï¼›éè´Ÿæ•´æ•° fee ä»£è¡¨äº†äº¤æ˜“è‚¡ç¥¨çš„æ‰‹ç»­è´¹ç”¨ã€‚ ä½ å¯ä»¥æ— é™æ¬¡åœ°å®Œæˆäº¤æ˜“ï¼Œä½†æ˜¯ä½ æ¯æ¬¡äº¤æ˜“éƒ½éœ€è¦ä»˜æ‰‹ç»­è´¹ã€‚å¦‚æœä½ å·²ç»è´­ä¹°äº†ä¸€ä¸ªè‚¡ç¥¨ï¼Œåœ¨å–å‡ºå®ƒä¹‹å‰ä½ å°±ä¸èƒ½å†ç»§ç»­è´­ä¹°è‚¡ç¥¨äº†ã€‚ è¿”å›è·å¾—åˆ©æ¶¦çš„æœ€å¤§å€¼ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: prices = [1, 3, 2, 8, 4, 9], fee = 2 è¾“å‡º: 8 è§£é‡Š: èƒ½å¤Ÿè¾¾åˆ°çš„æœ€å¤§åˆ©æ¶¦: åœ¨æ­¤å¤„ä¹°å…¥ prices[0] = 1 åœ¨æ­¤å¤„å–å‡º prices[3] = 8 åœ¨æ­¤å¤„ä¹°å…¥ prices[4] = 4 åœ¨æ­¤å¤„å–å‡º prices[5] = 9 æ€»åˆ©æ¶¦: ((8 - 1) - 2) + ((9 - 4) - 2) = 8. æ³¨æ„: 0 &lt; prices.length &lt;= 50000. 0 &lt; prices[i] &lt; 50000. 0 &lt;= fee &lt; 50000. 123456789101112class Solution(object): def maxProfit(self, prices, fee): &quot;&quot;&quot; :type prices: List[int] :type fee: int :rtype: int &quot;&quot;&quot; cash, hold = 0, -prices[0] for i in xrange(1, len(prices)): cash = max(cash, hold + prices[i] - fee) hold = max(hold, cash - prices[i]) return cash 718. æœ€é•¿é‡å¤å­æ•°ç»„ [n]ç»™ä¸¤ä¸ªæ•´æ•°æ•°ç»„ A å’Œ B ï¼Œè¿”å›ä¸¤ä¸ªæ•°ç»„ä¸­å…¬å…±çš„ã€é•¿åº¦æœ€é•¿çš„å­æ•°ç»„çš„é•¿åº¦ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: A: [1,2,3,2,1] B: [3,2,1,4,7] è¾“å‡º: 3 è§£é‡Š: é•¿åº¦æœ€é•¿çš„å…¬å…±å­æ•°ç»„æ˜¯ [3, 2, 1]ã€‚ è¯´æ˜: 1 &lt;= len(A), len(B) &lt;= 1000 0 &lt;= A[i], B[i] &lt; 100 123456789101112131415161718192021class Solution(object): def findLength(self, A, B): &quot;&quot;&quot; :type A: List[int] :type B: List[int] :rtype: int &quot;&quot;&quot; m, n = len(A), len(B) dp = [[0 for _ in xrange(n + 1)] for _ in xrange(m + 1)] res = 0 for i in xrange(m + 1): for j in xrange(n + 1): if i == 0 or j == 0: dp[i][j] = 0 else: if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = 0 res = max(res, dp[i][j]) return res 795. åŒºé—´å­æ•°ç»„ä¸ªæ•°ç»™å®šä¸€ä¸ªå…ƒç´ éƒ½æ˜¯æ­£æ•´æ•°çš„æ•°ç»„A ï¼Œæ­£æ•´æ•° L ä»¥åŠ R (L &lt;= R)ã€‚ æ±‚è¿ç»­ã€éç©ºä¸”å…¶ä¸­æœ€å¤§å…ƒç´ æ»¡è¶³å¤§äºç­‰äºL å°äºç­‰äºRçš„å­æ•°ç»„ä¸ªæ•°ã€‚ ä¾‹å¦‚ : è¾“å…¥: A = [2, 1, 4, 3] L = 2 R = 3 è¾“å‡º: 3 è§£é‡Š: æ»¡è¶³æ¡ä»¶çš„å­æ•°ç»„: [2], [2, 1], [3]. æ³¨æ„: L, R å’Œ A[i] éƒ½æ˜¯æ•´æ•°ï¼ŒèŒƒå›´åœ¨ [0, 10^9]ã€‚ æ•°ç»„ A çš„é•¿åº¦èŒƒå›´åœ¨[1, 50000]ã€‚ 12345678910111213141516171819202122class Solution(object): def numSubarrayBoundedMax(self, A, L, R): &quot;&quot;&quot; :type A: List[int] :type L: int :type R: int :rtype: int &quot;&quot;&quot; i, j, n = 0, 0, len(A) ans = 0 while j &lt; n: if L &lt;= A[j] &lt;= R: ans += j - i + 1 elif A[j] &lt; L: t = j - 1 while t &gt;= i and A[t] &lt; L: t -= 1 ans += t - i + 1 else: i = j + 1 j += 1 return ans 907. å­æ•°ç»„çš„æœ€å°å€¼ä¹‹å’Œ [n]ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ Aï¼Œæ‰¾åˆ° min(B) çš„æ€»å’Œï¼Œå…¶ä¸­ B çš„èŒƒå›´ä¸º A çš„æ¯ä¸ªï¼ˆè¿ç»­ï¼‰å­æ•°ç»„ã€‚ ç”±äºç­”æ¡ˆå¯èƒ½å¾ˆå¤§ï¼Œå› æ­¤è¿”å›ç­”æ¡ˆæ¨¡ 10^9 + 7ã€‚ ç¤ºä¾‹ï¼š è¾“å…¥ï¼š[3,1,2,4] è¾“å‡ºï¼š17 è§£é‡Šï¼š å­æ•°ç»„ä¸º [3]ï¼Œ[1]ï¼Œ[2]ï¼Œ[4]ï¼Œ[3,1]ï¼Œ[1,2]ï¼Œ[2,4]ï¼Œ[3,1,2]ï¼Œ[1,2,4]ï¼Œ[3,1,2,4]ã€‚ æœ€å°å€¼ä¸º 3ï¼Œ1ï¼Œ2ï¼Œ4ï¼Œ1ï¼Œ1ï¼Œ2ï¼Œ1ï¼Œ1ï¼Œ1ï¼Œå’Œä¸º 17ã€‚ æç¤ºï¼š 1 &lt;= A &lt;= 30000 1 &lt;= A[i] &lt;= 30000 12345678910111213141516171819202122232425262728class Solution(object): def sumSubarrayMins(self, A): MOD = 10**9 + 7 N = len(A) # prev has i* - 1 in increasing order of A[i* - 1] # where i* is the answer to query j stack = [] prev = [None] * N for i in xrange(N): while stack and A[i] &lt;= A[stack[-1]]: stack.pop() prev[i] = stack[-1] if stack else -1 stack.append(i) # next has k* + 1 in increasing order of A[k* + 1] # where k* is the answer to query j stack = [] next_ = [None] * N for k in xrange(N-1, -1, -1): while stack and A[k] &lt; A[stack[-1]]: stack.pop() next_[k] = stack[-1] if stack else N stack.append(k) # Use prev/next array to count answer return sum((i - prev[i]) * (next_[i] - i) * A[i] for i in xrange(N)) % MOD 915. åˆ†å‰²æ•°ç»„ [n]ç»™å®šä¸€ä¸ªæ•°ç»„ Aï¼Œå°†å…¶åˆ’åˆ†ä¸ºä¸¤ä¸ªä¸ç›¸äº¤ï¼ˆæ²¡æœ‰å…¬å…±å…ƒç´ ï¼‰çš„è¿ç»­å­æ•°ç»„ left å’Œ rightï¼Œ ä½¿å¾—ï¼š left ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½å°äºæˆ–ç­‰äº right ä¸­çš„æ¯ä¸ªå…ƒç´ ã€‚ left å’Œ right éƒ½æ˜¯éç©ºçš„ã€‚ left è¦å°½å¯èƒ½å°ã€‚ åœ¨å®Œæˆè¿™æ ·çš„åˆ†ç»„åè¿”å› left çš„é•¿åº¦ã€‚å¯ä»¥ä¿è¯å­˜åœ¨è¿™æ ·çš„åˆ’åˆ†æ–¹æ³•ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼š[5,0,3,8,6] è¾“å‡ºï¼š3 è§£é‡Šï¼šleft = [5,0,3]ï¼Œright = [8,6] ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼š[1,1,1,0,6,12] è¾“å‡ºï¼š4 è§£é‡Šï¼šleft = [1,1,1,0]ï¼Œright = [6,12] æç¤ºï¼š 2 &lt;= A.length &lt;= 30000 0 &lt;= A[i] &lt;= 10^6 å¯ä»¥ä¿è¯è‡³å°‘æœ‰ä¸€ç§æ–¹æ³•èƒ½å¤ŸæŒ‰é¢˜ç›®æ‰€æè¿°çš„é‚£æ ·å¯¹ A è¿›è¡Œåˆ’åˆ†ã€‚ 1234567891011121314151617181920212223class Solution(object): def partitionDisjoint(self, A): &quot;&quot;&quot; :type A: List[int] :rtype: int &quot;&quot;&quot; n = len(A) max_left, min_right = [0] * n, [0] * n m = A[0] for i in xrange(n): m = max(m, A[i]) max_left[i] = m m = A[-1] for i in xrange(n - 1, -1, -1): m = min(m, A[i]) min_right[i] = m for i in xrange(1, n): if max_left[i - 1] &lt;= min_right[i]: return i 926. å°†å­—ç¬¦ä¸²ç¿»è½¬åˆ°å•è°ƒé€’å¢ [n]å¦‚æœä¸€ä¸ªç”± â€˜0â€™ å’Œ â€˜1â€™ ç»„æˆçš„å­—ç¬¦ä¸²ï¼Œæ˜¯ä»¥ä¸€äº› â€˜0â€™ï¼ˆå¯èƒ½æ²¡æœ‰ â€˜0â€™ï¼‰åé¢è·Ÿç€ä¸€äº› â€˜1â€™ï¼ˆä¹Ÿå¯èƒ½æ²¡æœ‰ â€˜1â€™ï¼‰çš„å½¢å¼ç»„æˆçš„ï¼Œé‚£ä¹ˆè¯¥å­—ç¬¦ä¸²æ˜¯å•è°ƒé€’å¢çš„ã€‚ æˆ‘ä»¬ç»™å‡ºä¸€ä¸ªç”±å­—ç¬¦ â€˜0â€™ å’Œ â€˜1â€™ ç»„æˆçš„å­—ç¬¦ä¸² Sï¼Œæˆ‘ä»¬å¯ä»¥å°†ä»»ä½• â€˜0â€™ ç¿»è½¬ä¸º â€˜1â€™ æˆ–è€…å°† â€˜1â€™ ç¿»è½¬ä¸º â€˜0â€™ã€‚ è¿”å›ä½¿ S å•è°ƒé€’å¢çš„æœ€å°ç¿»è½¬æ¬¡æ•°ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼š\"00110\" è¾“å‡ºï¼š1 è§£é‡Šï¼šæˆ‘ä»¬ç¿»è½¬æœ€åä¸€ä½å¾—åˆ° 00111. ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼š\"010110\" è¾“å‡ºï¼š2 è§£é‡Šï¼šæˆ‘ä»¬ç¿»è½¬å¾—åˆ° 011111ï¼Œæˆ–è€…æ˜¯ 000111ã€‚ ç¤ºä¾‹ 3ï¼š è¾“å…¥ï¼š\"00011000\" è¾“å‡ºï¼š2 è§£é‡Šï¼šæˆ‘ä»¬ç¿»è½¬å¾—åˆ° 00000000ã€‚ æç¤ºï¼š 1 &lt;= S.length &lt;= 20000 S ä¸­åªåŒ…å«å­—ç¬¦ â€˜0â€™ å’Œ â€˜1â€™ Pythonä¼˜åŒ–å‰Pythonä¼˜åŒ–å1234567891011121314151617class Solution(object): def minFlipsMonoIncr(self, S): &quot;&quot;&quot; :type S: str :rtype: int &quot;&quot;&quot; n = len(S) zeros = [n for _ in xrange(n)] ones = [n for _ in xrange(n)] for i in xrange(n): if i == 0: zeros[i] = int(S[i] != &#x27;0&#x27;) ones[i] = int(S[i] != &#x27;1&#x27;) continue zeros[i] = zeros[i - 1] + int(S[i] != &#x27;0&#x27;) ones[i] = min(ones[i - 1], zeros[i - 1]) + int(S[i] != &#x27;1&#x27;) return min(zeros[n - 1], ones[n - 1])123456789101112class Solution(object): def minFlipsMonoIncr(self, S): &quot;&quot;&quot; :type S: str :rtype: int &quot;&quot;&quot; zero, one = 0, 0 for c in S: last_zero = zero zero = last_zero + int(c != &#x27;0&#x27;) one = min(last_zero, one) + int(c != &#x27;1&#x27;) return min(zero, one) 945. ä½¿æ•°ç»„å”¯ä¸€çš„æœ€å°å¢é‡ç»™å®šæ•´æ•°æ•°ç»„ Aï¼Œæ¯æ¬¡ move æ“ä½œå°†ä¼šé€‰æ‹©ä»»æ„ A[i]ï¼Œå¹¶å°†å…¶é€’å¢ 1ã€‚ è¿”å›ä½¿ A ä¸­çš„æ¯ä¸ªå€¼éƒ½æ˜¯å”¯ä¸€çš„æœ€å°‘æ“ä½œæ¬¡æ•°ã€‚ ç¤ºä¾‹ 1: è¾“å…¥ï¼š[1,2,2] è¾“å‡ºï¼š1 è§£é‡Šï¼šç»è¿‡ä¸€æ¬¡ move æ“ä½œï¼Œæ•°ç»„å°†å˜ä¸º [1, 2, 3]ã€‚ ç¤ºä¾‹ 2: è¾“å…¥ï¼š[3,2,1,2,1,7] è¾“å‡ºï¼š6 è§£é‡Šï¼šç»è¿‡ 6 æ¬¡ move æ“ä½œï¼Œæ•°ç»„å°†å˜ä¸º [3, 4, 1, 2, 5, 7]ã€‚ å¯ä»¥çœ‹å‡º 5 æ¬¡æˆ– 5 æ¬¡ä»¥ä¸‹çš„ move æ“ä½œæ˜¯ä¸èƒ½è®©æ•°ç»„çš„æ¯ä¸ªå€¼å”¯ä¸€çš„ã€‚ æç¤ºï¼š 0 &lt;= A.length &lt;= 40000 0 &lt;= A[i] &lt; 40000 123456789101112class Solution(object): def minIncrementForUnique(self, A): &quot;&quot;&quot; :type A: List[int] :rtype: int &quot;&quot;&quot; A = sorted(A) res, step = 0, 0 for n in A: res += max(n, step) - n step = max(n, step) + 1 return res 962. æœ€å¤§å®½åº¦å¡ [n]ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ Aï¼Œå¡æ˜¯å…ƒç»„ (i, j)ï¼Œå…¶ä¸­ i &lt; j ä¸” A[i] &lt;= A[j]ã€‚è¿™æ ·çš„å¡çš„å®½åº¦ä¸º j - iã€‚ æ‰¾å‡º A ä¸­çš„å¡çš„æœ€å¤§å®½åº¦ï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œè¿”å› 0 ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼š[6,0,8,2,1,5] è¾“å‡ºï¼š4 è§£é‡Šï¼š æœ€å¤§å®½åº¦çš„å¡ä¸º (i, j) = (1, 5): A[1] = 0 ä¸” A[5] = 5. ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼š[9,8,1,0,1,9,4,0,4,1] è¾“å‡ºï¼š7 è§£é‡Šï¼š æœ€å¤§å®½åº¦çš„å¡ä¸º (i, j) = (2, 9): A[2] = 1 ä¸” A[9] = 1. æç¤ºï¼š 2 &lt;= A.length &lt;= 50000 0 &lt;= A[i] &lt;= 50000 12345678910111213141516171819202122class Solution(object): def maxWidthRamp(self, A): &quot;&quot;&quot; :type A: List[int] :rtype: int &quot;&quot;&quot; res = 0 if not A: return res stk = [] n = len(A) for i in xrange(n): if not stk or A[stk[-1]] &gt; A[i]: stk.append(i) i = n - 1 while i &gt; res: while stk and A[stk[-1]] &lt;= A[i]: j = stk[-1] res = max(res, i - j) stk.pop(-1) i -= 1 return res","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCodeä¹‹æ•°ç»„(å›°éš¾)","slug":"LeetCode-æ•°ç»„-å›°éš¾","date":"2020-12-31T13:25:06.000Z","updated":"2020-12-31T13:41:03.522Z","comments":false,"path":"posts/801922082.html","link":"","permalink":"https://leel0330.github.io/posts/801922082.html","excerpt":"æ•°ç»„(å›°éš¾)çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚","text":"æ•°ç»„(å›°éš¾)çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ 4. å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•° [n]ç»™å®šä¸¤ä¸ªå¤§å°ä¸º m å’Œ n çš„æ­£åºï¼ˆä»å°åˆ°å¤§ï¼‰æ•°ç»„ nums1 å’Œ nums2ã€‚è¯·ä½ æ‰¾å‡ºå¹¶è¿”å›è¿™ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°ã€‚ è¿›é˜¶ï¼šä½ èƒ½è®¾è®¡ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦ä¸º O(log (m+n)) çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜å—ï¼Ÿ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šnums1 = [1,3], nums2 = [2] è¾“å‡ºï¼š2.00000 è§£é‡Šï¼šåˆå¹¶æ•°ç»„ = [1,2,3] ï¼Œä¸­ä½æ•° 2 ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šnums1 = [1,2], nums2 = [3,4] è¾“å‡ºï¼š2.50000 è§£é‡Šï¼šåˆå¹¶æ•°ç»„ = [1,2,3,4] ï¼Œä¸­ä½æ•° (2 + 3) / 2 = 2.5 ç¤ºä¾‹ 3ï¼š è¾“å…¥ï¼šnums1 = [0,0], nums2 = [0,0] è¾“å‡ºï¼š0.00000 ç¤ºä¾‹ 4ï¼š è¾“å…¥ï¼šnums1 = [], nums2 = [1] è¾“å‡ºï¼š1.00000 ç¤ºä¾‹ 5ï¼š è¾“å…¥ï¼šnums1 = [2], nums2 = [] è¾“å‡ºï¼š2.00000 æç¤ºï¼š nums1.length == m nums2.length == n 0 &lt;= m &lt;= 1000 0 &lt;= n &lt;= 1000 1 &lt;= m + n &lt;= 2000 -106 &lt;= nums1[i], nums2[i] &lt;= 106 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): def findMedianSortedArrays(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: float &quot;&quot;&quot; len1, len2 = len(nums1), len(nums2) total_len = len1 + len2 if total_len &amp; 1 == 1: mid = total_len / 2 res = self.findK(nums1, nums2, mid + 1) return res else: mid1 = total_len / 2 - 1 mid2 = mid1 + 1 res = (self.findK(nums1, nums2, mid1 + 1) + self.findK(nums1, nums2, mid2 + 1)) / 2.0 return res def findK(self, nums1, nums2, k): len1, len2 = len(nums1), len(nums2) idx1, idx2 = 0, 0 while True: if idx1 == len1: return nums2[idx2 + k - 1] if idx2 == len2: return nums1[idx1 + k - 1] if k == 1: return min(nums1[idx1], nums2[idx2]) half = k / 2 new_idx1 = min(idx1 + half, len1) - 1 new_idx2 = min(idx2 + half, len2) - 1 if nums1[new_idx1] &lt;= nums2[new_idx2]: k -= (new_idx1 - idx1 + 1) idx1 = new_idx1 + 1 else: k -= (new_idx2 - idx2 + 1) idx2 = new_idx2 + 1 41. ç¼ºå¤±çš„ç¬¬ä¸€ä¸ªæ­£æ•°ç»™ä½ ä¸€ä¸ªæœªæ’åºçš„æ•´æ•°æ•°ç»„ï¼Œè¯·ä½ æ‰¾å‡ºå…¶ä¸­æ²¡æœ‰å‡ºç°çš„æœ€å°çš„æ­£æ•´æ•°ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [1,2,0] è¾“å‡º: 3 ç¤ºä¾‹ 2: è¾“å…¥: [3,4,-1,1] è¾“å‡º: 2 ç¤ºä¾‹ 3: è¾“å…¥: [7,8,9,11,12] è¾“å‡º: 1 æç¤ºï¼š ä½ çš„ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦åº”ä¸ºO(n)ï¼Œå¹¶ä¸”åªèƒ½ä½¿ç”¨å¸¸æ•°çº§åˆ«çš„é¢å¤–ç©ºé—´ã€‚ 123456789101112131415161718class Solution(object): def firstMissingPositive(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n = len(nums) for i in xrange(n): if nums[i] &lt;= 0: nums[i] = n + 1 for i in xrange(n): cur_num = abs(nums[i]) if cur_num &lt;= n: nums[cur_num - 1] = -abs(nums[cur_num - 1]) for i in xrange(n): if nums[i] &gt; 0: return i + 1 return n + 1 42. æ¥é›¨æ°´ [n]ç»™å®š n ä¸ªéè´Ÿæ•´æ•°è¡¨ç¤ºæ¯ä¸ªå®½åº¦ä¸º 1 çš„æŸ±å­çš„é«˜åº¦å›¾ï¼Œè®¡ç®—æŒ‰æ­¤æ’åˆ—çš„æŸ±å­ï¼Œä¸‹é›¨ä¹‹åèƒ½æ¥å¤šå°‘é›¨æ°´ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šheight = [0,1,0,2,1,0,1,3,2,1,2,1] è¾“å‡ºï¼š6 è§£é‡Šï¼šä¸Šé¢æ˜¯ç”±æ•°ç»„ [0,1,0,2,1,0,1,3,2,1,2,1] è¡¨ç¤ºçš„é«˜åº¦å›¾ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥æ¥ 6 ä¸ªå•ä½çš„é›¨æ°´ï¼ˆè“è‰²éƒ¨åˆ†è¡¨ç¤ºé›¨æ°´ï¼‰ã€‚ ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šheight = [4,2,0,3,2,5] è¾“å‡ºï¼š9 æç¤ºï¼š n == height.length 0 &lt;= n &lt;= 3 * 104 0 &lt;= height[i] &lt;= 105 123456789101112131415161718192021class Solution(object): def trap(self, height): &quot;&quot;&quot; :type height: List[int] :rtype: int &quot;&quot;&quot; if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in xrange(1, n): left_max[i] = max(height[i], left_max[i - 1]) right_max[n - 1] = height[n - 1] for i in xrange(n - 2, -1, -1): right_max[i] = max(height[i], right_max[i + 1]) res = 0 for i in xrange(1, n - 1): res += min(left_max[i], right_max[i]) - height[i] return res 45. è·³è·ƒæ¸¸æˆ IIç»™å®šä¸€ä¸ªéè´Ÿæ•´æ•°æ•°ç»„ï¼Œä½ æœ€åˆä½äºæ•°ç»„çš„ç¬¬ä¸€ä¸ªä½ç½®ã€‚ æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ä»£è¡¨ä½ åœ¨è¯¥ä½ç½®å¯ä»¥è·³è·ƒçš„æœ€å¤§é•¿åº¦ã€‚ ä½ çš„ç›®æ ‡æ˜¯ä½¿ç”¨æœ€å°‘çš„è·³è·ƒæ¬¡æ•°åˆ°è¾¾æ•°ç»„çš„æœ€åä¸€ä¸ªä½ç½®ã€‚ ç¤ºä¾‹: è¾“å…¥: [2,3,1,1,4] è¾“å‡º: 2 è§£é‡Š: è·³åˆ°æœ€åä¸€ä¸ªä½ç½®çš„æœ€å°è·³è·ƒæ•°æ˜¯ 2ã€‚ ä»ä¸‹æ ‡ä¸º 0 è·³åˆ°ä¸‹æ ‡ä¸º 1 çš„ä½ç½®ï¼Œè·³ 1 æ­¥ï¼Œç„¶åè·³ 3 æ­¥åˆ°è¾¾æ•°ç»„çš„æœ€åä¸€ä¸ªä½ç½®ã€‚ è¯´æ˜: å‡è®¾ä½ æ€»æ˜¯å¯ä»¥åˆ°è¾¾æ•°ç»„çš„æœ€åä¸€ä¸ªä½ç½®ã€‚ 12345678910111213141516class Solution(object): def jump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n = len(nums) max_pos = 0 end = 0 res = 0 for i in xrange(n - 1): max_pos = max(max_pos, i + nums[i]) if i == end: end = max_pos res += 1 return res","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"ç‰›å®¢é¢˜éœ¸-åä¼é«˜é¢‘é¢è¯•é¢˜","slug":"ç‰›å®¢é¢˜éœ¸-åä¼é«˜é¢‘é¢è¯•é¢˜","date":"2020-12-22T13:46:09.000Z","updated":"2021-03-14T13:44:03.524Z","comments":false,"path":"posts/1369037266.html","link":"","permalink":"https://leel0330.github.io/posts/1369037266.html","excerpt":"ç»ˆäºæŠŠç‰›å®¢é¢˜éœ¸-åä¼é«˜é¢‘é¢è¯•é¢˜åˆ·å®Œäº†ï¼Œåœ¨è¿™é‡Œæ±‡æ€»ä¸€ä¸‹ã€‚","text":"ç»ˆäºæŠŠç‰›å®¢é¢˜éœ¸-åä¼é«˜é¢‘é¢è¯•é¢˜åˆ·å®Œäº†ï¼Œåœ¨è¿™é‡Œæ±‡æ€»ä¸€ä¸‹ã€‚ NC21. é“¾è¡¨å†…æŒ‡å®šåŒºé—´åè½¬å°†ä¸€ä¸ªé“¾è¡¨ m ä½ç½®åˆ° n ä½ç½®ä¹‹é—´çš„åŒºé—´åè½¬ï¼Œè¦æ±‚æ—¶é—´å¤æ‚åº¦ï¼Œç©ºé—´å¤æ‚åº¦ã€‚ ç¤ºä¾‹1 è¾“å…¥: {1,2,3,4,5},2,4 è¿”å›å€¼: {1,4,3,2,5} 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; // write code here ListNode *dummy = new ListNode(-1); dummy-&gt;next = head; ListNode *p = dummy, *prev = nullptr; ListNode *q = dummy, *next = nullptr; for(int i = 0;i &lt; m; i++) &#123; prev = p; p = p-&gt;next; &#125; for(int i = 0; i &lt; n; i++) &#123; q = q-&gt;next; &#125; next = q-&gt;next; pair&lt;ListNode*, ListNode*&gt; res = reverse(prev, p, next); prev-&gt;next = res.first; res.second-&gt;next = next; head = dummy-&gt;next; dummy-&gt;next = nullptr; delete dummy; return head; &#125; pair&lt;ListNode*, ListNode*&gt; reverse(ListNode *prev, ListNode *head, ListNode *tail) &#123; ListNode *p = head, *q = prev; while(p != tail) &#123; ListNode *nextNode = p-&gt;next; p-&gt;next = q; q = p; p = nextNode; &#125; pair&lt;ListNode*, ListNode*&gt; res; res.first = q; res.second = prev-&gt;next; return res; &#125;&#125;; NC24. åˆ é™¤æœ‰åºé“¾è¡¨ä¸­é‡å¤å‡ºç°çš„å…ƒç´ ç»™å‡ºä¸€ä¸ªå‡åºæ’åºçš„é“¾è¡¨ï¼Œåˆ é™¤é“¾è¡¨ä¸­çš„æ‰€æœ‰é‡å¤å‡ºç°çš„å…ƒç´ ï¼Œåªä¿ç•™åŸé“¾è¡¨ä¸­åªå‡ºç°ä¸€æ¬¡çš„å…ƒç´ ã€‚ä¾‹å¦‚ï¼šç»™å‡ºçš„é“¾è¡¨ä¸º1â†’2â†’3â†’3â†’4â†’4â†’5, è¿”å›1â†’2â†’5.ç»™å‡ºçš„é“¾è¡¨ä¸º1â†’1â†’1â†’2â†’3, è¿”å›2â†’3. PythonC++1234567891011121314151617181920212223242526class Solution: def deleteDuplicates(self , head): # write code here if not head or head.next is None: return head dummy = ListNode(-1) dummy.next = head p = dummy q = head while q: cur = q cur_v = q.val cnt = 1 while cur.next and cur.next.val == cur_v: cur = cur.next cnt += 1 if cnt == 1: p.next = cur q = cur.next p = cur else: p.next = cur.next q = cur.next p = dummy.next dummy.next = None return p1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: /** * * @param head ListNodeç±» * @return ListNodeç±» */ ListNode* deleteDuplicates(ListNode* head) &#123; // write code here if(head == nullptr || head-&gt;next == nullptr) &#123; return head; &#125; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode *p = dummy, *q = head; while(q) &#123; ListNode *cur = q; int curVal = cur-&gt;val; int cnt = 1; while(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == curVal) &#123; cnt += 1; cur = cur-&gt;next; &#125; if(cnt &gt; 1) &#123; p-&gt;next = cur-&gt;next; q = cur-&gt;next; &#125;else &#123; p-&gt;next = cur; q = cur-&gt;next; p = cur; &#125; &#125; p = dummy-&gt;next; dummy-&gt;next = nullptr; delete dummy; return p; &#125;&#125;; NC35. æœ€å°ç¼–è¾‘ä»£ä»· [n]ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸²str1å’Œstr2ï¼Œå†ç»™å®šä¸‰ä¸ªæ•´æ•°icï¼Œdcå’Œrcï¼Œåˆ†åˆ«ä»£è¡¨æ’å…¥ã€åˆ é™¤å’Œæ›¿æ¢ä¸€ä¸ªå­—ç¬¦çš„ä»£ä»·ï¼Œè¯·è¾“å‡ºå°†str1ç¼–è¾‘æˆstr2çš„æœ€å°ä»£ä»·ã€‚ ç¤ºä¾‹1 è¾“å…¥: \"abc\",\"adc\",5,3,2 è¿”å›å€¼: 2 ç¤ºä¾‹2 è¾“å…¥: \"abc\",\"adc\",5,3,100 è¿”å›å€¼: 8 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: /** * min edit cost * @param str1 stringå­—ç¬¦ä¸² the string * @param str2 stringå­—ç¬¦ä¸² the string * @param ic intæ•´å‹ insert cost * @param dc intæ•´å‹ delete cost * @param rc intæ•´å‹ replace cost * @return intæ•´å‹ */ int minEditCost(string str1, string str2, int ic, int dc, int rc) &#123; // write code here int s1Len = str1.size(); int s2Len = str2.size(); vector&lt; vector&lt;int&gt; &gt; dp(s1Len + 1, vector&lt;int&gt;(s2Len + 1, 0)); for(int i = 0; i &lt;= s1Len; i++) &#123; dp[i][0] = i * dc; &#125; for(int i = 0; i &lt;= s2Len; i++) &#123; dp[0][i] = i * ic; &#125; for(int i = 1; i &lt;= s1Len; i++) &#123; for(int j = 1; j &lt;= s2Len; j++) &#123; if(str1[i - 1] == str2[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1]; &#125;else&#123; int ins = dp[i][j - 1] + ic; int del = dp[i - 1][j] + dc; int replace = dp[i - 1][j - 1] + rc; dp[i][j] = min(ins, min(del, replace)); &#125; &#125; &#125; return dp[s1Len][s2Len]; &#125;&#125;; NC44. é€šé…ç¬¦åŒ¹é… [n]è¯·å®ç°æ”¯æŒâ€™?â€™andâ€™*â€˜.çš„é€šé…ç¬¦æ¨¡å¼åŒ¹é…ã€‚â€˜?â€™ å¯ä»¥åŒ¹é…ä»»ä½•å•ä¸ªå­—ç¬¦ã€‚â€˜*â€˜ å¯ä»¥åŒ¹é…ä»»ä½•å­—ç¬¦åºåˆ—ï¼ˆåŒ…æ‹¬ç©ºåºåˆ—ï¼‰ã€‚ 12345678910111213141516171819202122class Solution: def isMatch(self , s , p ): # write code here i, j = 0, 0 backi, backj = -1, -1 while i &lt; len(s): if j &lt; len(p) and (s[i] == p[j] or p[j] == &#x27;?&#x27;): i += 1 j += 1 elif j &lt; len(p) and p[j] == &#x27;*&#x27;: backi = i backj = j j += 1 elif backj != -1: i = backi + 1 j = backj + 1 backi = i else: return False while j &lt; len(p) and p[j] == &#x27;*&#x27;: j += 1 return j == len(p) NC49. æœ€é•¿çš„æ‹¬å·å­ä¸²ç»™å‡ºä¸€ä¸ªä»…åŒ…å«å­—ç¬¦â€™(â€˜å’Œâ€™)â€™çš„å­—ç¬¦ä¸²ï¼Œè®¡ç®—æœ€é•¿çš„æ ¼å¼æ­£ç¡®çš„æ‹¬å·å­ä¸²çš„é•¿åº¦ã€‚å¯¹äºå­—ç¬¦ä¸²â€(()â€æ¥è¯´ï¼Œæœ€é•¿çš„æ ¼å¼æ­£ç¡®çš„å­ä¸²æ˜¯â€()â€ï¼Œé•¿åº¦ä¸º2.å†ä¸¾ä¸€ä¸ªä¾‹å­ï¼šå¯¹äºå­—ç¬¦ä¸²â€)()())â€,æ¥è¯´ï¼Œæœ€é•¿çš„æ ¼å¼æ­£ç¡®çš„å­ä¸²æ˜¯â€()()â€ï¼Œé•¿åº¦ä¸º4. è¾“å…¥: \"(()\" è¿”å›å€¼: 2 12345678910111213141516171819202122class Solution: def longestValidParentheses(self , s ): # write code here s_len = len(s) if s_len &lt; 1: return 0 stk = [] max_len = 0 last = -1 for i in xrange(s_len): if s[i] == &#x27;(&#x27;: stk.append(i) else: if len(stk) == 0: last = i else: stk.pop(-1) if len(stk) == 0: max_len = max(max_len, i - last) else: max_len = max(max_len, i - stk[-1]) return max_len NC50. é“¾è¡¨ä¸­çš„èŠ‚ç‚¹æ¯kä¸ªä¸€ç»„ç¿»è½¬ [n]å°†ç»™å‡ºçš„é“¾è¡¨ä¸­çš„èŠ‚ç‚¹æ¯ k ä¸ªä¸€ç»„ç¿»è½¬ï¼Œè¿”å›ç¿»è½¬åçš„é“¾è¡¨å¦‚æœé“¾è¡¨ä¸­çš„èŠ‚ç‚¹æ•°ä¸æ˜¯ k çš„å€æ•°ï¼Œå°†æœ€åå‰©ä¸‹çš„èŠ‚ç‚¹ä¿æŒåŸæ ·ä½ ä¸èƒ½æ›´æ”¹èŠ‚ç‚¹ä¸­çš„å€¼ï¼Œåªèƒ½æ›´æ”¹èŠ‚ç‚¹æœ¬èº«ã€‚è¦æ±‚ç©ºé—´å¤æ‚åº¦ O(1)ä¾‹å¦‚ï¼š ç»™å®šçš„é“¾è¡¨æ˜¯1â†’2â†’3â†’4â†’5 å¯¹äº k=2, ä½ åº”è¯¥è¿”å› 2â†’1â†’4â†’3â†’5 å¯¹äº k=3, ä½ åº”è¯¥è¿”å› 3â†’2â†’1â†’4â†’5 PythonCpp1234567891011121314151617181920212223242526272829303132class Solution: def reverse(self, head, tail): prev = tail.next p = head while prev != tail: nex = p.next p.next = prev prev = p p = nex return tail, head def reverseKGroup(self, head, k): dummy = ListNode(-1) dummy.next = head pre = dummy while head: tail = pre # æŸ¥çœ‹å‰©ä½™éƒ¨åˆ†é•¿åº¦æ˜¯å¦å¤§äºç­‰äº k for i in range(k): tail = tail.next if not tail: return dummy.next nex = tail.next head, tail = self.reverse(head, tail) # æŠŠå­é“¾è¡¨é‡æ–°æ¥å›åŸé“¾è¡¨ pre.next = head tail.next = nex pre = tail head = tail.next return dummy.next12345678910111213141516171819202122232425262728293031323334353637383940414243/** * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */class Solution &#123;public: /** * * @param head ListNodeç±» * @param k intæ•´å‹ * @return ListNodeç±» */ ListNode* reverseKGroup(ListNode* head, int k) &#123; // write code here if(head == nullptr) &#123; return head; &#125; ListNode *p = head, *q = head; for(int i = 0; i &lt; k; i++) &#123; if(q == nullptr) &#123; return p; &#125; q = q-&gt;next; &#125; ListNode* newHead = reverse(p, q); p-&gt;next = reverseKGroup(q, k); return newHead; &#125; ListNode* reverse(ListNode *head, ListNode* end) &#123; ListNode* p = head, *q = nullptr; while(p != end) &#123; ListNode *r = p-&gt;next; p-&gt;next = q; q = p; p = r; &#125; return q; &#125;&#125;; NC57. åè½¬æ•°å­—å°†ç»™å‡ºçš„32ä½æ•´æ•°xç¿»è½¬ã€‚ä¾‹1:x=123ï¼Œè¿”å›321ã€‚ä¾‹2:x=-123ï¼Œè¿”å›-321ã€‚ ä½ æœ‰æ³¨æ„åˆ°ç¿»è½¬åçš„æ•´æ•°å¯èƒ½æº¢å‡ºå—ï¼Ÿå› ä¸ºç»™å‡ºçš„æ˜¯32ä½æ•´æ•°ï¼Œåˆ™å…¶æ•°å€¼èŒƒå›´ä¸º[âˆ’2^{31}, 2^{31} âˆ’ 1]ã€‚ç¿»è½¬å¯èƒ½ä¼šå¯¼è‡´æº¢å‡ºï¼Œå¦‚æœåè½¬åçš„ç»“æœä¼šæº¢å‡ºå°±è¿”å› 0ã€‚ è¾“å…¥: -123 è¿”å›å€¼: -321 1234567891011121314151617class Solution: def reverse(self , x ): # write code here INT_MIN = -(1 &lt;&lt; 31) INT_MAX = (1 &lt;&lt; 31) - 1 sign = x &lt; 0 x = abs(x) res = 0 while x: v = x % 10 x = x // 10 if res &gt; INT_MAX / 10 or (res == INT_MAX / 10 and v &gt; 7): return 0 if sign and (-res &lt; INT_MIN / 10 or (-res == INT_MIN / 10 and v &lt; -8)): return 0 res = res * 10 + v return res if not sign else -res NC62. å¹³è¡¡äºŒå‰æ ‘è¾“å…¥ä¸€æ£µäºŒå‰æ ‘ï¼Œåˆ¤æ–­è¯¥äºŒå‰æ ‘æ˜¯å¦æ˜¯å¹³è¡¡äºŒå‰æ ‘ã€‚ åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬åªéœ€è¦è€ƒè™‘å…¶å¹³è¡¡æ€§ï¼Œä¸éœ€è¦è€ƒè™‘å…¶æ˜¯ä¸æ˜¯æ’åºäºŒå‰æ ‘ã€‚ å¹³è¡¡äºŒå‰æ ‘ï¼ˆBalanced Binary Treeï¼‰ï¼Œå…·æœ‰ä»¥ä¸‹æ€§è´¨ï¼šå®ƒæ˜¯ä¸€æ£µç©ºæ ‘æˆ–å®ƒçš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡1ï¼Œå¹¶ä¸”å·¦å³ä¸¤ä¸ªå­æ ‘éƒ½æ˜¯ä¸€æ£µå¹³è¡¡äºŒå‰æ ‘ã€‚ è¾“å…¥: {1,2,3,4,5,6,7} è¿”å›å€¼: true 123456789101112131415161718class Solution: def IsBalanced_Solution(self, pRoot): # write code here return self.helper(pRoot) != -1 def helper(self, root): if not root: return 0 left = self.helper(root.left) if left == -1: return -1 right = self.helper(root.right) if right == -1: return -1 v = abs(left - right) if v &gt; 1: return -1 return max(left, right) + 1 NC64. äºŒå‰æœç´¢æ ‘ä¸åŒå‘é“¾è¡¨è¾“å…¥ä¸€æ£µäºŒå‰æœç´¢æ ‘ï¼Œå°†è¯¥äºŒå‰æœç´¢æ ‘è½¬æ¢æˆä¸€ä¸ªæ’åºçš„åŒå‘é“¾è¡¨ã€‚è¦æ±‚ä¸èƒ½åˆ›å»ºä»»ä½•æ–°çš„ç»“ç‚¹ï¼Œåªèƒ½è°ƒæ•´æ ‘ä¸­ç»“ç‚¹æŒ‡é’ˆçš„æŒ‡å‘ã€‚ 123456789101112131415161718192021222324class Solution: def __init__(self): self.last_node = None def Convert(self, pRootOfTree): # write code here if not pRootOfTree: return pRootOfTree self.last_node = None self.helper(pRootOfTree) while pRootOfTree.left: pRootOfTree = pRootOfTree.left return pRootOfTree def helper(self, root): if not root: return if root.left: self.helper(root.left) root.left = self.last_node if self.last_node: self.last_node.right = root self.last_node = root if root.right: self.helper(root.right) NC75. æ•°ç»„ä¸­åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—ä¸€ä¸ªæ•´å‹æ•°ç»„é‡Œé™¤äº†ä¸¤ä¸ªæ•°å­—ä¹‹å¤–ï¼Œå…¶ä»–çš„æ•°å­—éƒ½å‡ºç°äº†ä¸¤æ¬¡ã€‚è¯·å†™ç¨‹åºæ‰¾å‡ºè¿™ä¸¤ä¸ªåªå‡ºç°ä¸€æ¬¡çš„æ•°å­—ã€‚ 12345678910111213141516171819202122class Solution: # è¿”å›[a,b] å…¶ä¸­abæ˜¯å‡ºç°ä¸€æ¬¡çš„ä¸¤ä¸ªæ•°å­— def FindNumsAppearOnce(self, array): # write code here x = 0 for n in array: x ^= n idx = 0 while x &amp; 1 == 0: x &gt;&gt;= 1 idx += 1 n1, n2 = 0, 0 for n in array: if self.f(n, idx): n1 ^= n else: n2 ^= n return [n1, n2] def f(self, n, idx): n &gt;&gt;= idx return(n &amp; 1) == 1 NC82. æ»‘åŠ¨çª—å£çš„æœ€å¤§å€¼ç»™å®šä¸€ä¸ªæ•°ç»„å’Œæ»‘åŠ¨çª—å£çš„å¤§å°ï¼Œæ‰¾å‡ºæ‰€æœ‰æ»‘åŠ¨çª—å£é‡Œæ•°å€¼çš„æœ€å¤§å€¼ã€‚ä¾‹å¦‚ï¼Œå¦‚æœè¾“å…¥æ•°ç»„{2,3,4,2,6,2,5,1}åŠæ»‘åŠ¨çª—å£çš„å¤§å°3ï¼Œé‚£ä¹ˆä¸€å…±å­˜åœ¨6ä¸ªæ»‘åŠ¨çª—å£ï¼Œä»–ä»¬çš„æœ€å¤§å€¼åˆ†åˆ«ä¸º{4,4,6,6,6,5}ï¼› é’ˆå¯¹æ•°ç»„{2,3,4,2,6,2,5,1}çš„æ»‘åŠ¨çª—å£æœ‰ä»¥ä¸‹6ä¸ªï¼š {[2,3,4],2,6,2,5,1}ï¼Œ {2,[3,4,2],6,2,5,1}ï¼Œ {2,3,[4,2,6],2,5,1}ï¼Œ {2,3,4,[2,6,2],5,1}ï¼Œ {2,3,4,2,[6,2,5],1}ï¼Œ {2,3,4,2,6,[2,5,1]}ã€‚çª—å£å¤§äºæ•°ç»„é•¿åº¦çš„æ—¶å€™ï¼Œè¿”å›ç©º ç¤ºä¾‹1 è¾“å…¥: [2,3,4,2,6,2,5,1],3 è¿”å›å€¼: [4,4,6,6,6,5] 12345678910111213141516class Solution: def maxInWindows(self, nums, size): # write code here queue = [] if not size: return queue res = [] for i, v in enumerate(nums): while queue and queue[0] &lt;= i - size: queue.pop(0) while queue and v &gt; nums[queue[-1]]: queue.pop(-1) queue.append(i) if i &gt;= size - 1: res.append(nums[queue[0]]) return res NC88. å¯»æ‰¾ç¬¬Kå¤§æœ‰ä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œè¯·ä½ æ ¹æ®å¿«é€Ÿæ’åºçš„æ€è·¯ï¼Œæ‰¾å‡ºæ•°ç»„ä¸­ç¬¬Kå¤§çš„æ•°ã€‚ ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„a,åŒæ—¶ç»™å®šå®ƒçš„å¤§å°nå’Œè¦æ‰¾çš„K(Kåœ¨1åˆ°nä¹‹é—´)ï¼Œè¯·è¿”å›ç¬¬Kå¤§çš„æ•°ï¼Œä¿è¯ç­”æ¡ˆå­˜åœ¨ã€‚ ç¤ºä¾‹1 è¾“å…¥: [1,3,5,2,2],5,3 è¿”å›å€¼: 2 PythonCpp12345678910111213141516171819202122232425class Finder: def findKth(self, a, n, K): # write code here return self.helper(a, 0, n - 1, K) def helper(self, a, left, right, K): idx = self.paritition(a, left, right) if idx == K - 1: return a[idx] elif idx &lt; K - 1: return self.helper(a, idx + 1, right, K) else: return self.helper(a, left, idx - 1, K) def paritition(self, a, low, high): pivot = a[low] while low &lt; high: while low &lt; high and a[high] &lt;= pivot: high -= 1 a[low] = a[high] while low &lt; high and a[low] &gt;= pivot: low += 1 a[high] = a[low] a[low] = pivot return low1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int findKth(vector&lt;int&gt; a, int n, int K) &#123; // write code here return Helper(a, 0, n - 1, K); &#125; int Helper(vector&lt;int&gt;&amp; arr, int left, int right, int K) &#123; int idx = Partition(arr, left, right); if(idx + 1 == K) &#123; return arr[idx]; &#125; if(idx + 1 &lt; K) &#123; return Helper(arr, idx + 1, right, K); &#125;else &#123; return Helper(arr, left, idx - 1, K); &#125; &#125; int Partition(vector&lt;int&gt;&amp; arr, int left, int right) &#123; int pivot = arr[left]; while(left &lt; right) &#123; while(left &lt; right &amp;&amp; arr[right] &lt;= pivot) &#123; right -= 1; &#125; arr[left] = arr[right]; while(left &lt; right &amp;&amp; arr[left] &gt;= pivot) &#123; left += 1; &#125; arr[right] = arr[left]; &#125; arr[left] = pivot; return left; &#125;&#125;; NC91. æœ€é•¿é€’å¢å­åºåˆ— [n]ç»™å®šæ•°ç»„arrï¼Œè®¾é•¿åº¦ä¸ºnï¼Œè¾“å‡ºarrçš„æœ€é•¿é€’å¢å­åºåˆ—ã€‚ï¼ˆå¦‚æœæœ‰å¤šä¸ªç­”æ¡ˆï¼Œè¯·è¾“å‡ºå…¶ä¸­å­—å…¸åºæœ€å°çš„ï¼‰ã€‚ ç¤ºä¾‹1 è¾“å…¥: [2,1,5,3,6,4,8,9,7] è¿”å›å€¼: [1,3,4,8,9] ç¤ºä¾‹2 è¾“å…¥: [1,2,8,6,4] è¿”å›å€¼: [1,2,4] 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;int&gt; LIS(vector&lt;int&gt;&amp; arr) &#123; // write code here // ç¬¬ä¸€æ­¥ï¼šåˆ©ç”¨è´ªå¿ƒ+äºŒåˆ†æ±‚æœ€é•¿é€’å¢å­åºåˆ—é•¿åº¦ vector&lt;int&gt; res; vector&lt;int&gt; maxLen; if (arr.size() &lt; 1) return res; res.emplace_back(arr[0]); // æ³¨ï¼šemplace_back(val)ä½œç”¨åŒpush_backï¼Œæ•ˆç‡æ›´é«˜ maxLen.emplace_back(1); for (int i = 1; i &lt; arr.size(); ++i) &#123; if (arr[i] &gt; res.back()) &#123; res.emplace_back(arr[i]); maxLen.emplace_back(res.size()); &#125; else &#123; // lower_bound(begin, end, val)åŒ…å«åœ¨&lt;algorithm&gt;ä¸­ // å®ƒçš„ä½œç”¨æ˜¯è¿”å›æœ‰åºæ•°ç»„begin..endä¸­ç¬¬ä¸€ä¸ªå¤§äºç­‰äºvalçš„å…ƒç´ çš„è¿­ä»£å™¨ int pos = lower_bound(res.begin(), res.end(), arr[i]) - res.begin(); res[pos] = arr[i]; maxLen.emplace_back(pos+1); &#125; &#125; // ç¬¬äºŒæ­¥ï¼šå¡«å……æœ€é•¿é€’å¢å­åºåˆ— for (int i = arr.size()-1, j = res.size(); j &gt; 0; --i) &#123; if (maxLen[i] == j) &#123; res[--j] = arr[i]; &#125; &#125; return res; &#125;&#125;; NC92. æœ€é•¿å…¬å…±å­åºåˆ— [n]ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸²str1å’Œstr2ï¼Œè¾“å‡ºè¿ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å­åºåˆ—ã€‚å¦‚è¿‡æœ€é•¿å…¬å…±å­åºåˆ—ä¸ºç©ºï¼Œåˆ™è¾“å‡º-1ã€‚ ç¤ºä¾‹1 è¾“å…¥: \"1A2C3D4B56\",\"B1D23CA45B6A\" è¿”å›å€¼: \"123456\" 1234567891011121314151617181920212223242526272829class Solution &#123;public: string LCS(string s1, string s2) &#123; // write code here if(s1.size() == 0 || s2.size() == 0) return &quot;-1&quot;; int maxLen = 0, start = -1; vector&lt;int&gt; dp(s2.size() + 1, 0); for(int i = 1; i &lt;= s1.size(); ++i)&#123; int last = dp[0]; for(int j = 1; j &lt;= s2.size(); ++j)&#123; int tmp = dp[j]; if(s1[i - 1] == s2[j - 1])&#123; dp[j] = last + 1; &#125;else&#123; dp[j] = 0; &#125; last = tmp; if(maxLen &lt; dp[j])&#123; maxLen = dp[j]; start = i; &#125; &#125; &#125; if(maxLen == 0) return &quot;-1&quot;; return s1.substr(start-maxLen, maxLen); &#125;&#125;; NC108. æœ€å¤§æ­£æ–¹å½¢ç»™å®šä¸€ä¸ªç”±0å’Œ1ç»„æˆçš„2ç»´çŸ©é˜µï¼Œè¿”å›è¯¥çŸ©é˜µä¸­æœ€å¤§çš„ç”±1ç»„æˆçš„æ­£æ–¹å½¢çš„é¢ç§¯ ç¤ºä¾‹1 è¾“å…¥: [[1,0,1,0,0],[1,0,1,1,1],[1,1,1,1,1],[1,0,0,1,0]] è¿”å›å€¼: 4 12345678910111213141516171819202122232425262728class Solution &#123;public: int solve(vector&lt;vector&lt;char&gt; &gt;&amp; matrix) &#123; // write code here int maxEdge = 0; if(matrix.size() == 0 || matrix[0].size() == 0) &#123; return maxEdge; &#125; int rows = matrix.size(), cols = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(rows, vector&lt;int&gt;(cols, 0)); for(int i = 0; i &lt; rows; i++) &#123; for(int j = 0; j &lt; cols; j++) &#123; if(matrix[i][j] == &#x27;0&#x27;) &#123; dp[i][j] = 0; &#125;else &#123; if(i ==0 || j == 0) &#123; dp[i][j] = 1; &#125;else &#123; int temp = min(dp[i - 1][j - 1], dp[i][j - 1]); dp[i][j] = min(dp[i - 1][j], temp) + 1; &#125; &#125; maxEdge = max(maxEdge, dp[i][j]); &#125; &#125; return maxEdge * maxEdge; &#125;&#125;; NC116. æŠŠæ•°å­—ç¿»è¯‘æˆå­—ç¬¦ä¸²æœ‰ä¸€ç§å°†å­—æ¯ç¼–ç æˆæ•°å­—çš„æ–¹å¼ï¼šâ€™aâ€™-&gt;1, â€˜b-&gt;2â€™, â€¦ , â€˜z-&gt;26â€™ã€‚ ç°åœ¨ç»™ä¸€ä¸²æ•°å­—ï¼Œè¿”å›æœ‰å¤šå°‘ç§å¯èƒ½çš„è¯‘ç ç»“æœ ç¤ºä¾‹1 è¾“å…¥: \"12\" è¿”å›å€¼: 2 ç¤ºä¾‹1 è¾“å…¥: \"31717126241541717\" è¿”å›å€¼: 192 123456789101112131415class Solution: def solve(self , nums ): # write code here n = len(nums) dp = [0 for _ in xrange(n + 1)] dp[0] = 1 dp[1] = 1 if nums[0] != &#x27;0&#x27; else 0 for i in xrange(2, n + 1): two = nums[i - 2: i] one = nums[i - 1:i] if 10 &lt;= int(two) &lt;= 26: dp[i] += dp[i - 2] if 1 &lt;= int(one) &lt;= 9: dp[i] += dp[i - 1] return dp[n] NC118. æ•°ç»„ä¸­çš„é€†åºå¯¹åœ¨æ•°ç»„ä¸­çš„ä¸¤ä¸ªæ•°å­—ï¼Œå¦‚æœå‰é¢ä¸€ä¸ªæ•°å­—å¤§äºåé¢çš„æ•°å­—ï¼Œåˆ™è¿™ä¸¤ä¸ªæ•°å­—ç»„æˆä¸€ä¸ªé€†åºå¯¹ã€‚è¾“å…¥ä¸€ä¸ªæ•°ç»„,æ±‚å‡ºè¿™ä¸ªæ•°ç»„ä¸­çš„é€†åºå¯¹çš„æ€»æ•°Pã€‚å¹¶å°†På¯¹1000000007å–æ¨¡çš„ç»“æœè¾“å‡ºã€‚ å³è¾“å‡ºP%1000000007 ç¤ºä¾‹1 è¾“å…¥: [1,2,3,4,5,6,7,0] è¿”å›å€¼: 7 12345678910111213141516171819202122232425262728293031323334class Solution: def InversePairs(self, data): # write code here n = len(data) tmp = [0 for _ in xrange(n)] res = self.mergeSort(data, tmp, 0, n - 1) return res % 1000000007 def mergeSort(self, data, tmp, left, right): if left &gt;= right: return 0 mid = (left + right) // 2 res = self.mergeSort(data, tmp, left, mid) + \\ self.mergeSort(data, tmp, mid + 1, right) i, j = left, mid + 1 pos = left while i &lt;= mid and j &lt;= right: if data[i] &lt;= data[j]: tmp[pos] = data[i] i += 1 res += j - (mid + 1) else: tmp[pos] = data[j] j += 1 pos += 1 for k in xrange(i, mid + 1): tmp[pos] = data[k] pos += 1 res += j - (mid + 1) for k in xrange(j, right + 1): tmp[pos] = data[k] pos += 1 data[left: right + 1] = tmp[left: right + 1] return res NC119. æœ€å°çš„Kä¸ªæ•°è¾“å…¥nä¸ªæ•´æ•°ï¼Œæ‰¾å‡ºå…¶ä¸­æœ€å°çš„Kä¸ªæ•°ã€‚ä¾‹å¦‚è¾“å…¥4,5,1,6,2,7,3,8è¿™8ä¸ªæ•°å­—ï¼Œåˆ™æœ€å°çš„4ä¸ªæ•°å­—æ˜¯1,2,3,4ã€‚ç¤ºä¾‹1 è¾“å…¥ [4,5,1,6,2,7,3,8],4 è¿”å›å€¼ [1,2,3,4] 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; vector&lt;int&gt; res; if(input.size() &lt; k || k == 0) &#123; return res; &#125; int start = 0, end = input.size() - 1ï¼› while(start &lt;= end) &#123; //éœ€è¦ç»†å¿ƒï¼Œè¦åŠ ç­‰å·ï¼ int idx = Partition(input, start, end); if(idx + 1 == k) &#123; return vector&lt;int&gt;(input.begin(), input.begin() + k); &#125; if(idx + 1 &lt; k) &#123; start = idx + 1; &#125;else &#123; end = idx - 1; &#125; &#125; return res; &#125; int Partition(vector&lt;int&gt;&amp; arr, int start, int end) &#123; int pivot = arr[start]; int left = start, right = end; while(left &lt; right) &#123; while(left &lt; right &amp;&amp; arr[right] &gt;= pivot) &#123; right -= 1; &#125; arr[left] = arr[right]; while(left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123; left += 1; &#125; arr[right] = arr[left]; &#125; arr[left] = pivot; return left; &#125;&#125;; NC122. æ­£åˆ™è¡¨è¾¾å¼åŒ¹é… [n]è¯·å®ç°ä¸€ä¸ªå‡½æ•°ç”¨æ¥åŒ¹é…åŒ…æ‹¬â€™.â€™å’Œâ€™â€˜çš„æ­£åˆ™è¡¨è¾¾å¼ã€‚æ¨¡å¼ä¸­çš„å­—ç¬¦â€™.â€™è¡¨ç¤ºä»»æ„ä¸€ä¸ªå­—ç¬¦ï¼Œè€Œâ€™â€˜è¡¨ç¤ºå®ƒå‰é¢çš„å­—ç¬¦å¯ä»¥å‡ºç°ä»»æ„æ¬¡ï¼ˆåŒ…å«0æ¬¡ï¼‰ã€‚ åœ¨æœ¬é¢˜ä¸­ï¼ŒåŒ¹é…æ˜¯æŒ‡å­—ç¬¦ä¸²çš„æ‰€æœ‰å­—ç¬¦åŒ¹é…æ•´ä¸ªæ¨¡å¼ã€‚ä¾‹å¦‚ï¼Œå­—ç¬¦ä¸²â€aaaâ€ä¸æ¨¡å¼â€a.aâ€å’Œâ€abacaâ€åŒ¹é…ï¼Œä½†æ˜¯ä¸â€aa.aâ€å’Œâ€ab*aâ€å‡ä¸åŒ¹é… ç¤ºä¾‹1 è¾“å…¥: \"aaa\",\"a*a\" è¿”å›å€¼: true 1234567891011121314151617181920212223242526272829class Solution: # s, patternéƒ½æ˜¯å­—ç¬¦ä¸² def match(self, s, pattern): # write code here if not s and not pattern: return True s_len = len(s) p_len = len(pattern) dp = [[False for _ in xrange(p_len + 1)] for _ in xrange(s_len + 1)] dp[0][0] = True for i in xrange(s_len + 1): for j in xrange(1, p_len + 1): if pattern[j - 1] == &#x27;*&#x27;: dp[i][j] = dp[i][j - 2] if self.isOK(s, pattern, i, j - 1): dp[i][j] = dp[i][j] or dp[i - 1][j] else: if self.isOK(s, pattern, i, j): dp[i][j] = dp[i - 1][j - 1] return dp[s_len][p_len] def isOK(self, s, pattern, i, j): if i == 0: return False if pattern[j - 1] == &#x27;.&#x27;: return True return s[i - 1] == pattern[j - 1] NC126. æ¢é’±çš„æœ€å°‘è´§å¸æ•° [n]ç»™å®šæ•°ç»„arrï¼Œarrä¸­æ‰€æœ‰çš„å€¼éƒ½ä¸ºæ­£æ•´æ•°ä¸”ä¸é‡å¤ã€‚æ¯ä¸ªå€¼ä»£è¡¨ä¸€ç§é¢å€¼çš„è´§å¸ï¼Œæ¯ç§é¢å€¼çš„è´§å¸å¯ä»¥ä½¿ç”¨ä»»æ„å¼ ï¼Œå†ç»™å®šä¸€ä¸ªaimï¼Œä»£è¡¨è¦æ‰¾çš„é’±æ•°ï¼Œæ±‚ç»„æˆaimçš„æœ€å°‘è´§å¸æ•°ã€‚å¦‚æœæ— è§£ï¼Œè¯·è¿”å›-1.ã€è¦æ±‚ã€‘æ—¶é—´å¤æ‚åº¦O(nÃ—aim)ï¼Œç©ºé—´å¤æ‚åº¦O(n)ã€‚ ç¤ºä¾‹1 è¾“å…¥: [5,2,3],20 è¿”å›å€¼: 4 1234567891011class Solution: def minMoney(self, arr, aim): # write code here INT_MAX = (1 &lt;&lt; 31) - 1 dp = [INT_MAX for _ in xrange(aim + 1)] dp[0] = 0 for n in xrange(aim + 1): for v in arr: if n &gt;= v: dp[n] = min(dp[n], dp[n - v] + 1) return dp[aim] if dp[aim] != INT_MAX else -1 NC127. æœ€é•¿å…¬å…±å­ä¸² [n]ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸²str1å’Œstr2,è¾“å‡ºä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å­ä¸²ï¼Œå¦‚æœæœ€é•¿å…¬å…±å­ä¸²ä¸ºç©ºï¼Œè¾“å‡º-1ã€‚ ç¤ºä¾‹1 è¾“å…¥: \"1AB2345CD\",\"12345EF\" è¿”å›å€¼: \"2345\" Pythonä¼šè¶…æ—¶ã€‚ 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: /** * longest common substring * @param str1 stringå­—ç¬¦ä¸² the string * @param str2 stringå­—ç¬¦ä¸² the string * @return stringå­—ç¬¦ä¸² */ string LCS(string str1, string str2) &#123; // write code here int s1Len = str1.size(); int s2Len = str2.size(); string res = &quot;&quot;; int maxLen = 0; vector&lt; vector&lt;int&gt; &gt; dp(s1Len + 1, vector&lt;int&gt;(s2Len + 1, 0)); for(int i = 1; i &lt;= s1Len; i++) &#123; for(int j = 1; j &lt;= s2Len; j++) &#123; if(str1[i - 1] == str2[j - 1]) &#123; dp[i][j] = 1 + dp[i - 1][j - 1]; &#125; if(maxLen &lt; dp[i][j]) &#123; maxLen = dp[i][j]; res = str1.substr(i - dp[i][j], dp[i][j]); &#125; &#125; &#125; if(res.empty()) &#123; return &quot;-1&quot;; &#125; return res; &#125;&#125;; NC128. å®¹å™¨ç››æ°´é—®é¢˜ [n]ç»™å®šä¸€ä¸ªæ•´å½¢æ•°ç»„arrï¼Œå·²çŸ¥å…¶ä¸­æ‰€æœ‰çš„å€¼éƒ½æ˜¯éè´Ÿçš„ï¼Œå°†è¿™ä¸ªæ•°ç»„çœ‹ä½œä¸€ä¸ªå®¹å™¨ï¼Œè¯·è¿”å›å®¹å™¨èƒ½è£…å¤šå°‘æ°´ã€‚å…·ä½“è¯·å‚è€ƒæ ·ä¾‹è§£é‡Š ç¤ºä¾‹1 è¾“å…¥: [3,1,2,5,2,4] è¿”å›å€¼: 5 ç¤ºä¾‹2 è¾“å…¥: [4,5,1,3,2] è¿”å›å€¼: 2 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: /** * max water * @param arr intæ•´å‹vector the array * @return longé•¿æ•´å‹ */ long long maxWater(vector&lt;int&gt;&amp; arr) &#123; // write code here if(arr.size() &lt;= 2) &#123; return 0; &#125; int left = 0, right = arr.size() - 1; long long res = 0; int min = getMin(arr[left], arr[right]); while(left &lt; right) &#123; if(arr[left] &lt; arr[right]) &#123; left += 1; if(arr[left] &lt; min) &#123; res += min - arr[left]; &#125;else &#123; min = getMin(arr[left], arr[right]); &#125; &#125;else &#123; right -= 1; if(arr[right] &lt; min) &#123; res += min - arr[right]; &#125;else &#123; min = getMin(arr[left], arr[right]); &#125; &#125; &#125; return res; &#125; int getMin(int a, int b) &#123; return a &gt; b ? b: a; &#125;&#125;; NC138. çŸ©é˜µæœ€é•¿é€’å¢è·¯å¾„ç»™å®šä¸€ä¸ªçŸ©é˜µï¼ŒçŸ©é˜µå†…æ‰€æœ‰æ•°å‡ä¸ºéè´Ÿæ•´æ•°ã€‚æ±‚ä¸€æ¡è·¯å¾„ï¼Œè¯¥è·¯å¾„ä¸Šæ‰€æœ‰æ•°æ˜¯é€’å¢çš„ã€‚è¿™ä¸ªè·¯å¾„å¿…é¡»æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š1ã€å¯¹äºæ¯ä¸ªå•å…ƒæ ¼ï¼Œä½ å¯ä»¥å¾€ä¸Šï¼Œä¸‹ï¼Œå·¦ï¼Œå³å››ä¸ªæ–¹å‘ç§»åŠ¨ã€‚ ä½ ä¸èƒ½åœ¨å¯¹è§’çº¿æ–¹å‘ä¸Šç§»åŠ¨æˆ–ç§»åŠ¨åˆ°è¾¹ç•Œå¤–ã€‚2ã€ä½ ä¸èƒ½èµ°é‡å¤çš„å•å…ƒæ ¼ã€‚å³æ¯ä¸ªæ ¼å­æœ€å¤šåªèƒ½èµ°ä¸€æ¬¡ã€‚ ç¤ºä¾‹1 è¾“å…¥: [[1,2,3],[4,5,6],[7,8,9]] è¿”å›å€¼: 5 ç¤ºä¾‹2 è¾“å…¥: [[1,2],[4,3]] è¿”å›å€¼: 4 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int solve(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123; // write code here if(matrix.size() == 0 || matrix[0].size() == 0) &#123; return 0; &#125; int rows = matrix.size(), cols = matrix[0].size(); int res = 0; int dirs[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; vector&lt;vector&lt;int&gt;&gt; memo(rows, vector&lt;int&gt;(cols, 0)); for(int i = 0; i &lt; rows; i++) &#123; for(int j = 0; j &lt; cols; j++) &#123; int cur = dfs(matrix, i, j, rows, cols, memo, dirs); res = max(res, cur); &#125; &#125; return res; &#125; int dfs(const vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int i, int j, int rows, int cols, vector&lt;vector&lt;int&gt;&gt;&amp; memo, int dirs[4][2]) &#123; if(memo[i][j] != 0) &#123; return memo[i][j]; &#125; memo[i][j] += 1; for(int k = 0; k &lt; 4; k++) &#123; int newI = dirs[k][0] + i, newJ = dirs[k][1] + j; if(newI &gt;= 0 &amp;&amp; newI &lt; rows &amp;&amp; newJ &gt;= 0 &amp;&amp; newJ &lt; cols &amp;&amp; matrix[i][j] &lt; matrix[newI][newJ]) &#123; memo[i][j] = max(memo[i][j], dfs(matrix, newI, newJ, rows, cols, memo, dirs) + 1); &#125; &#125; return memo[i][j]; &#125;&#125;;","categories":[{"name":"Tech","slug":"Tech","permalink":"https://leel0330.github.io/categories/Tech/"}],"tags":[]},{"title":"Dockeræ„å»ºåŒ…å«zshå’Œvimçš„Ubuntu","slug":"Dockeræ„å»ºåŒ…å«zshå’Œvimçš„Ubuntu","date":"2020-12-18T15:24:31.000Z","updated":"2020-12-27T05:05:14.642Z","comments":false,"path":"posts/2954551561.html","link":"","permalink":"https://leel0330.github.io/posts/2954551561.html","excerpt":"æ™šä¸ŠèŠ±äº†ç‚¹æ—¶é—´ç ”ç©¶äº†ä¸‹å¦‚ä½•åœ¨Dockerç¯å¢ƒä¸‹æ„å»ºå±äºè‡ªå·±çš„Ubuntuã€‚è¯¥UbuntuåŒ…å«äº†zshå’ŒOh-my-zshæ’ä»¶ï¼Œä¹ŸåŒ…å«äº†YouCompleteMeæ’ä»¶çš„Vimç¼–è¾‘å™¨ã€‚ å«æ³ªè¯´ä¸‹:ç½‘ä¸Šçš„YouCompleteMeå¾ˆå¤šæ•™ç¨‹éƒ½å·²ç»è¿‡æ—¶äº†ï¼Œè¿˜æ˜¯å¾—ä»¥å®˜æ–¹æ–‡æ¡£ä¸ºä¸»æ¥é…ç½®è¯¥æ’ä»¶ï¼Œå¦åˆ™ä½ ä¼šå®‰è£…çš„å¾ˆç—›è‹¦ã€‚ å¦å¤–ï¼Œè¯¥Ubuntuä¹ŸåŒ…å«äº†C/C++çš„ç¼–è¯‘ç¯å¢ƒï¼Œå¦‚gccã€g++ã€gdbå’Œvalgrindå¸¸ç”¨å·¥å…·ã€‚","text":"æ™šä¸ŠèŠ±äº†ç‚¹æ—¶é—´ç ”ç©¶äº†ä¸‹å¦‚ä½•åœ¨Dockerç¯å¢ƒä¸‹æ„å»ºå±äºè‡ªå·±çš„Ubuntuã€‚è¯¥UbuntuåŒ…å«äº†zshå’ŒOh-my-zshæ’ä»¶ï¼Œä¹ŸåŒ…å«äº†YouCompleteMeæ’ä»¶çš„Vimç¼–è¾‘å™¨ã€‚ å«æ³ªè¯´ä¸‹:ç½‘ä¸Šçš„YouCompleteMeå¾ˆå¤šæ•™ç¨‹éƒ½å·²ç»è¿‡æ—¶äº†ï¼Œè¿˜æ˜¯å¾—ä»¥å®˜æ–¹æ–‡æ¡£ä¸ºä¸»æ¥é…ç½®è¯¥æ’ä»¶ï¼Œå¦åˆ™ä½ ä¼šå®‰è£…çš„å¾ˆç—›è‹¦ã€‚ å¦å¤–ï¼Œè¯¥Ubuntuä¹ŸåŒ…å«äº†C/C++çš„ç¼–è¯‘ç¯å¢ƒï¼Œå¦‚gccã€g++ã€gdbå’Œvalgrindå¸¸ç”¨å·¥å…·ã€‚ é¢„å®‰è£…123456789apt updateapt install systemdapt install curlapt install wgetapt install git å®‰è£…zsh1234567apt install zshsh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlightinggit clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions åœ¨.zshrcé…ç½®æ’ä»¶ 1plugins=(git zsh-syntax-highlighting zsh-autosuggestions) é¿å…å¤åˆ¶å‘½ä»¤åœ¨æ§åˆ¶å°æ˜¯ä¸€ä¸ªä¸ªå­—ç¬¦æ˜¾ç¤ºå‡ºæ¥ 123456789101112# This speeds up pasting w/ autosuggest# https://github.com/zsh-users/zsh-autosuggestions/issues/238pasteinit() &#123; OLD_SELF_INSERT=$&#123;$&#123;(s.:.)widgets[self-insert]&#125;[2,3]&#125; zle -N self-insert url-quote-magic # I wonder if you&#x27;d need `.url-quote-magic`?&#125;pastefinish() &#123; zle -N self-insert $OLD_SELF_INSERT&#125;zstyle :bracketed-paste-magic paste-init pasteinitzstyle :bracketed-paste-magic paste-finish pastefinish (ä¸ä¸€å®šä¼šç¢°åˆ°è¿™ä¸ªé—®é¢˜)æŒ‰tabé”®shellä¸­é‡å¤æ˜¾ç¤ºå‘½ä»¤çš„å‰å‡ ä¸ªå­—ç¬¦é—®é¢˜ä¿®å¤: 12345678apt-get install -y localesrm -rf /var/lib/apt/lists/*localedef -i en_US -c -f UTF-8 -A /usr/share/locale/locale.alias en_US.UTF-8echo &#x27;export LANG=en_US.utf8&#x27; &gt;&gt; ~/.zshrcsource ~/.zshrc ä»¥ä¸Šéƒ½æ”¾ç½®åœ¨.zshrcæ–‡ä»¶å°±å¯ä»¥ï¼Œç„¶åé‡å¯ä¸‹å°±å¯ä»¥äº†ã€‚ å®‰è£…vimå¹¶é…ç½® æŒ‰ç…§æ’ä»¶ç®¡ç†å™¨Vundleã€‚1git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim å»ºç«‹é»˜è®¤.vimrcæ–‡ä»¶åœ¨~ç›®å½•ä¸‹ï¼Œå†…å®¹ä¸º:1234567891011121314151617181920212223242526272829set nocompatible &quot; be iMproved, requiredfiletype off &quot; required&quot; set the runtime path to include Vundle and initializeset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()&quot; alternatively, pass a path where Vundle should install plugins&quot;call vundle#begin(&#x27;~/some/path/here&#x27;)&quot; let Vundle manage Vundle, requiredPlugin &#x27;VundleVim/Vundle.vim&#x27;&quot; plugins here&quot; All of your Plugins must be added before the following linecall vundle#end() &quot; requiredfiletype plugin indent on &quot; required&quot; To ignore plugin indent changes, instead use:&quot;filetype plugin on&quot;&quot; Brief help&quot; :PluginList - lists configured plugins&quot; :PluginInstall - installs plugins; append `!` to update or just :PluginUpdate&quot; :PluginSearch foo - searches for foo; append `!` to refresh local cache&quot; :PluginClean - confirms removal of unused plugins; append `!` to auto-approve removal&quot;&quot; see :h vundle for more details or wiki for FAQ&quot; Put your non-Plugin stuff after this line å®‰è£…YouCompleteMeæ’ä»¶ åœ¨.vimrcæ·»åŠ å¦‚ä¸‹å†…å®¹:1Plugin &#39;Valloric&#x2F;YouCompleteMe&#39; æ‹‰å–YouCompleteMeæ’ä»¶ä»£ç :12345cd ~/.vim/bundlegit clone https://github.com/Valloric/YouCompleteMe.gitcd ~/.vim/bundle/YouCompleteMegit submodule update --init --recursive(æ³¨æ„:è¿™ä¸ªå‘½ä»¤å¯èƒ½èŠ±æ—¶é—´æ¯”è¾ƒä¹…) æ‹‰å–æ„å»ºYouCompleteMeä¾èµ–:1apt install build-essential cmake vim-nox python3-dev å®‰è£…ä»£ç æç¤º:123cd ~/.vim/bundle/YouCompleteMepython3 install.py --clangd-completer è¿™4æ­¥å®ŒæˆåYouCompleteMeæ’ä»¶å°±ç®—å®Œæˆäº†ï¼Œç½‘ä¸Šå¥½å¤šè¯´è¦é…ç½®.ycm_extra_conf.pyã€‚å…¶å®è¿™ä¸ªæ–‡ä»¶å·²ç»åœ¨è¿™ä¸ª~/.vim/bundle/YouCompleteMeç›®å½•ä¸‹äº†ï¼Œä½ å¯ä»¥é€šè¿‡ls -aæ¥çœ‹åˆ°é‚£ä¸ªæ–‡ä»¶ã€‚ å®‰è£…C/C++ç¯å¢ƒ1234567apt install gccapt install g++apt install valgrindapt install gdb","categories":[{"name":"Tech","slug":"Tech","permalink":"https://leel0330.github.io/categories/Tech/"}],"tags":[]},{"title":"è°ˆä¸€è°ˆä½ å¯¹è¿›ç¨‹å’Œçº¿ç¨‹çš„è®¤è¯†(æœªå®Œå¾…ç»­...)","slug":"è°ˆä¸€è°ˆè¿›ç¨‹å’Œçº¿ç¨‹","date":"2020-12-14T12:37:25.000Z","updated":"2021-03-04T14:35:25.241Z","comments":false,"path":"posts/3970838420.html","link":"","permalink":"https://leel0330.github.io/posts/3970838420.html","excerpt":"è¿™æ˜¯è‡ªå·±çœ‹å®Œå‡ æœ¬æ“ä½œç³»ç»Ÿä¹¦å’Œç½‘ä¸Šä¸€äº›åšå®¢åï¼Œä¸ºäº†åŠ æ·±è‡ªå·±å¯¹è¿›ç¨‹å’Œçº¿ç¨‹çš„è®¤è¯†ï¼Œå†™çš„æ€»ç»“æ€§çš„æ–‡ç« ï¼Œä¹Ÿå¸Œæœ›è¿™ç¯‡æ–‡ç« èƒ½è®©ä½ è€³ç›®ä¸€æ–°^_^ã€‚ è¿™ç¯‡æ–‡ç« åªè°ˆæ¦‚å¿µï¼Œä¸è°ˆä»£ç ã€‚å¦‚æœä½ ç†è§£äº†æ¦‚å¿µï¼Œå†™ä»£ç çš„æ—¶å€™æ€è·¯å°±ä¼šå˜å¾—å¾ˆæ¸…æ™°ï¼Œä¸ä¼šé™·å…¥æˆ‘ä¹Ÿä¸çŸ¥é“è‡ªå·±åœ¨å†™ç¥é©¬çš„å›°å¢ƒã€‚","text":"è¿™æ˜¯è‡ªå·±çœ‹å®Œå‡ æœ¬æ“ä½œç³»ç»Ÿä¹¦å’Œç½‘ä¸Šä¸€äº›åšå®¢åï¼Œä¸ºäº†åŠ æ·±è‡ªå·±å¯¹è¿›ç¨‹å’Œçº¿ç¨‹çš„è®¤è¯†ï¼Œå†™çš„æ€»ç»“æ€§çš„æ–‡ç« ï¼Œä¹Ÿå¸Œæœ›è¿™ç¯‡æ–‡ç« èƒ½è®©ä½ è€³ç›®ä¸€æ–°^_^ã€‚ è¿™ç¯‡æ–‡ç« åªè°ˆæ¦‚å¿µï¼Œä¸è°ˆä»£ç ã€‚å¦‚æœä½ ç†è§£äº†æ¦‚å¿µï¼Œå†™ä»£ç çš„æ—¶å€™æ€è·¯å°±ä¼šå˜å¾—å¾ˆæ¸…æ™°ï¼Œä¸ä¼šé™·å…¥æˆ‘ä¹Ÿä¸çŸ¥é“è‡ªå·±åœ¨å†™ç¥é©¬çš„å›°å¢ƒã€‚ ä»€ä¹ˆæ˜¯è¿›ç¨‹ï¼Ÿ è¿›ç¨‹æ˜¯æ‰§è¡Œä¸­çš„ç¨‹åºï¼Œæ˜¯æ“ä½œç³»ç»Ÿåˆ†é…èµ„æºçš„åŸºæœ¬å•ä½ã€‚ å†…å­˜ä¸­çš„è¿›ç¨‹ç»“æ„å¦‚å›¾æ‰€ç¤º: è¿›ç¨‹åœ¨æ‰§è¡Œæ—¶ä¼šæ”¹å˜çŠ¶æ€ï¼Œæ¯ä¸ªè¿›ç¨‹å¯èƒ½å¤„äºä¸‹åˆ—çŠ¶æ€ä¸­çš„æŸä¸€ä¸ªï¼Œå¦‚å›¾æ‰€ç¤º: æ¯ä¸ªè¿›ç¨‹åœ¨æ“ä½œç³»ç»Ÿå†…ç”¨ç¨‹åºæ§åˆ¶å—(PCB)æ¥è¡¨ç¤ºã€‚PCBé€šå¸¸åŒ…å«äº†ä»¥ä¸‹å‡ ç±»ä¿¡æ¯: ç¨‹åºçŠ¶æ€:åŒ…æ‹¬æ–°çš„ã€å°±ç»ªã€è¿è¡Œã€ç­‰å¾…ã€åœæ­¢ç­‰ã€‚ ç¨‹åºè®¡æ•°å™¨:è®¡æ•°å™¨è¡¨ç¤ºè¿›ç¨‹è¦æ‰§è¡Œçš„ä¸‹ä¸ªæŒ‡ä»¤çš„åœ°å€ã€‚ CPUå¯„å­˜å™¨:ä¸ç¨‹åºè®¡æ•°å™¨ä¸€èµ·ï¼Œå¯„å­˜å™¨çš„çŠ¶æ€ä¿¡æ¯åœ¨å‡ºç°ä¸­æ–­æ—¶ä¹Ÿéœ€è¦ä¿å­˜ï¼Œä»¥ä¾¿è¿›ç¨‹ä»¥åèƒ½æ­£ç¡®åœ°ç»§ç»­æ‰§è¡Œã€‚ CPUè°ƒåº¦ä¿¡æ¯:åŒ…æ‹¬è¿›ç¨‹ä¼˜å…ˆçº§ã€è°ƒåº¦é˜Ÿåˆ—çš„æŒ‡é’ˆå’Œå…¶ä»–è°ƒåº¦å‚æ•°ã€‚ å†…å­˜ç®¡ç†ä¿¡æ¯:åŒ…æ‹¬åŸºå€å’Œç•Œé™å¯„å­˜å™¨çš„å€¼ã€é¡µè¡¨æˆ–æ®µè¡¨ã€‚ è®°è´¦ä¿¡æ¯:åŒ…æ‹¬CPUæ—¶é—´ã€å®é™…ä½¿ç”¨æ—¶é—´ã€æ—¶é—´ç•Œé™ã€è®°è´¦æ•°æ®ã€ä½œä¸šæˆ–è¿›ç¨‹æ•°é‡ç­‰ã€‚ I/OçŠ¶æ€ä¿¡æ¯:åŒ…æ‹¬åˆ†é…ç»™è¿›ç¨‹çš„I/Oè®¾å¤‡åˆ—è¡¨ã€æ‰“å¼€çš„æ–‡ä»¶åˆ—è¡¨ç­‰ã€‚ é©»ç•™åœ¨å†…å­˜ä¸­å°±ç»ªçš„ã€ç­‰å¾…è¿è¡Œçš„è¿›ç¨‹ä¿å­˜åœ¨å°±ç»ªé˜Ÿåˆ—ä¸­ï¼Œè¯¥é˜Ÿåˆ—é€šå¸¸ç”¨åŒå‘é“¾è¡¨æ¥å®ç°ã€‚ç­‰å¾…ç‰¹å®šI/Oè®¾å¤‡çš„è¿›ç¨‹åˆ—è¡¨ç§°ä¸ºè®¾å¤‡é˜Ÿåˆ—ï¼Œæ¯ä¸ªè®¾å¤‡éƒ½æœ‰è‡ªå·±çš„è®¾å¤‡é˜Ÿåˆ—ã€‚ ç»å¤§å¤šæ•°è¿›ç¨‹å¯ä»¥åˆ†ä¸ºI/Oå¯†é›†å‹æˆ–CPUå¯†é›†å‹ã€‚I/Oå¯†é›†å‹çš„è¿›ç¨‹åœ¨æ‰§è¡ŒI/Oæ–¹é¢æ¯”æ‰§è¡Œè®¡ç®—è¦èŠ±è´¹æ›´å¤šçš„æ—¶é—´ã€‚CPUå¯†é›†å‹çš„è¿›ç¨‹å°†æ›´å¤šçš„æ—¶é—´ç”¨åœ¨è®¡ç®—ä¸Šã€‚ å°†CPUåˆ‡æ¢åˆ°å¦ä¸€ä¸ªè¿›ç¨‹éœ€è¦ä¿å­˜å½“å‰è¿›ç¨‹çš„çŠ¶æ€å¹¶æ¢å¤å¦ä¸€ä¸ªè¿›ç¨‹çš„çŠ¶æ€ï¼Œè¿™ä¸€ä»»åŠ¡è¢«ç§°ä¸ºä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚ä¸Šä¸‹æ–‡åˆ‡æ¢æ—¶é—´æ˜¯é¢å¤–å¼€é”€ï¼Œå› ä¸ºåˆ‡æ¢æ—¶ç³»ç»Ÿå¹¶ä¸èƒ½åšä»€ä¹ˆæœ‰ç”¨çš„å·¥ä½œã€‚ è¿›ç¨‹åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œèƒ½å¤Ÿé€šè¿‡åˆ›å»ºè¿›ç¨‹ç³»ç»Ÿè°ƒç”¨åˆ›å»ºå¤šä¸ªæ–°è¿›ç¨‹ã€‚å¤§å¤šæ•°æ“ä½œç³»ç»Ÿæ ¹æ®ä¸€ä¸ªå”¯ä¸€çš„è¿›ç¨‹æ ‡è¯†ç¬¦æ¥è¯†åˆ«è¿›ç¨‹ï¼Œpid(process identifier)é€šå¸¸æ˜¯ä¸€ä¸ªæ•´æ•°å€¼ã€‚ è¿›ç¨‹é—´é€šä¿¡æœ‰ä¸¤ç§åŸºæœ¬æ¨¡å¼:å…±äº«å†…å­˜å’Œæ¶ˆæ¯ä¼ é€’ã€‚åœ¨å…±äº«å†…å­˜æ¨¡å¼ä¸­ï¼Œå»ºç«‹èµ·ä¸€å—å…±è¿›ç¨‹å…±äº«çš„å†…å­˜åŒºåŸŸï¼Œè¿›ç¨‹é€šè¿‡å‘æ­¤å…±äº«åŒºåŸŸè¯»æˆ–å†™å…¥æ•°æ®æ¥äº¤æ¢ä¿¡æ¯ã€‚åœ¨æ¶ˆæ¯ä¼ é€’æ¨¡å¼ä¸­ï¼Œé€šè¿‡åœ¨è¿›ç¨‹é—´äº¤æ¢æ¶ˆæ¯æ¥å®ç°é€šä¿¡ã€‚ æ¶ˆæ¯ä¼ é€’å¯¹äºäº¤æ¢è¾ƒå°‘æ•°é‡çš„æ•°æ®å¾ˆæœ‰ç”¨ï¼Œå› ä¸ºä¸éœ€è¦é¿å…å†²çªã€‚å¯¹äºè®¡ç®—æœºé—´çš„é€šä¿¡ï¼Œæ¶ˆæ¯ä¼ é€’ä¹Ÿæ¯”å…±äº«å†…å­˜æ›´æ˜“äºå®ç°ã€‚å…±äº«å†…å­˜å…è®¸ä»¥æœ€å¿«çš„é€Ÿåº¦è¿›è¡Œæ–¹ä¾¿çš„é€šä¿¡ï¼Œåœ¨è®¡ç®—æœºä¸­å®ƒå¯ä»¥è¾¾åˆ°å†…å­˜çš„é€Ÿåº¦ã€‚å…±äº«å†…å­˜æ¯”æ¶ˆæ¯ä¼ é€’å¿«ï¼Œæ¶ˆæ¯ä¼ é€’ç³»ç»Ÿé€šå¸¸ç”¨ç³»ç»Ÿè°ƒç”¨æ¥å®ç°ï¼Œå› æ­¤éœ€è¦æ›´å¤šçš„å†…æ ¸ä»‹å…¥çš„æ—¶é—´æ¶ˆè€—ã€‚å…±äº«å†…å­˜ç³»ç»Ÿä¸­ä»…åœ¨å»ºç«‹å…±äº«å†…å­˜åŒºåŸŸæ—¶éœ€è¦ç³»ç»Ÿè°ƒç”¨ï¼Œä¸€æ—¦å»ºç«‹å…±äº«å†…å­˜ï¼Œæ‰€æœ‰çš„è®¿é—®éƒ½è¢«å¤„ç†ä¸ºå¸¸è§„çš„å†…å­˜è®¿é—®ï¼Œä¸éœ€è¦å†…æ ¸çš„å¸®åŠ©ã€‚(å…±äº«å†…å­˜å’Œæ¶ˆæ¯ä¼ é€’çš„æ¯”è¾ƒ) ä»€ä¹ˆæ˜¯çº¿ç¨‹ï¼Ÿ çº¿ç¨‹æ˜¯æ“ä½œç³»ç»Ÿè°ƒåº¦çš„åŸºæœ¬å•ä½ï¼Œç”±çº¿ç¨‹IDã€ç¨‹åºè®¡æ•°å™¨ã€å¯„å­˜å™¨é›†åˆå’Œæ ˆç»„æˆã€‚å®ƒä¸å±äºåŒä¸€è¿›ç¨‹çš„å…¶ä»–çº¿ç¨‹å…±äº«ä»£ç æ®µã€æ•°æ®æ®µå’Œå…¶ä»–æ“ä½œç³»ç»Ÿèµ„æºï¼Œå¦‚æ‰“å¼€æ–‡ä»¶å’Œä¿¡å·ã€‚ å¤šçº¿ç¨‹ç¼–ç¨‹æœ‰4ä¸ªä¼˜ç‚¹: å“åº”åº¦é«˜:å¦‚æœå¯¹ä¸€ä¸ªäº¤äº’ç¨‹åºé‡‡ç”¨å¤šçº¿ç¨‹ï¼Œé‚£ä¹ˆå³ä½¿å…¶ä»–éƒ¨åˆ†é˜»å¡æˆ–æ‰§è¡Œè¾ƒå†—é•¿çš„æ“ä½œï¼Œè¯¥ç¨‹åºä»èƒ½ç»§ç»­æ‰§è¡Œï¼Œä»è€Œå¢åŠ äº†å¯¹ç”¨æˆ·çš„å“åº”ç¨‹åº¦ã€‚ èµ„æºå…±äº«:çº¿ç¨‹é»˜è®¤å…±äº«å®ƒä»¬æ‰€å±è¿›ç¨‹çš„å†…å­˜å’Œèµ„æºã€‚ ç»æµ:è¿›ç¨‹åˆ›å»ºæ‰€éœ€è¦çš„å†…å­˜å’Œèµ„æºçš„åˆ†é…æ¯”è¾ƒæ˜‚è´µã€‚ç”±äºçº¿ç¨‹å…±äº«å®ƒä»¬æ‰€å±è¿›ç¨‹çš„èµ„æºï¼Œæ‰€ä»¥åˆ›å»ºå’Œåˆ‡æ¢çº¿ç¨‹ä¼šæ›´ä¸ºç»æµã€‚ å¤šå¤„ç†å™¨ä½“ç³»ç»“æ„çš„åˆ©ç”¨:èƒ½å……åˆ†åˆ©ç”¨å¤šå¤„ç†å™¨ä½“ç³»ç»“æ„ï¼Œä»¥ä¾¿æ¯ä¸ªè¿›ç¨‹èƒ½å¹¶è¡Œè¿è¡Œåœ¨ä¸åŒçš„å¤„ç†å™¨ä¸Šã€‚åœ¨å¤šCPUä¸Šä½¿ç”¨å¤šçº¿ç¨‹åŠ å¼ºäº†å¹¶å‘åŠŸèƒ½ã€‚ çº¿ç¨‹æ± çš„ä¸»è¦æ€æƒ³æ˜¯åœ¨è¿›ç¨‹å¼€å§‹æ—¶åˆ›å»ºä¸€å®šæ•°é‡çš„çº¿ç¨‹ï¼Œå¹¶æ”¾å…¥åˆ°æ± ä¸­ä»¥ç­‰å¾…å·¥ä½œã€‚å½“æœåŠ¡å™¨æ”¶åˆ°è¯·æ±‚æ—¶ï¼Œå®ƒä¼šå”¤é†’æ± ä¸­çš„ä¸€ä¸ªçº¿ç¨‹ï¼Œå¹¶å°†è¦å¤„ç†çš„è¯·æ±‚ä¼ é€’ç»™å®ƒã€‚ä¸€æ—¦çº¿ç¨‹å®Œæˆäº†æœåŠ¡ï¼Œå®ƒä¼šè¿”å›æ± ä¸­å†ç­‰å¾…å·¥ä½œã€‚å¦‚æœæ± ä¸­æ²¡æœ‰å¯ç”¨çš„çº¿ç¨‹ï¼Œé‚£ä¹ˆæœåŠ¡å™¨ä¼šä¸€ç›´ç­‰åˆ°æœ‰ç©ºçº¿ç¨‹ä¸ºæ­¢ã€‚çº¿ç¨‹æ± æœ‰å¦‚ä¸‹å‡ ä¸ªä¼˜ç‚¹: é€šå¸¸ç”¨ç°æœ‰çº¿ç¨‹å¤„ç†è¯·æ±‚è¦æ¯”ç­‰å¾…åˆ›å»ºæ–°çš„çº¿ç¨‹è¦å¿«ã€‚ çº¿ç¨‹æ± é™åˆ¶äº†åœ¨ä»»ä½•æ—¶å€™å¯ç”¨çº¿ç¨‹çš„æ•°é‡ã€‚è¿™å¯¹é‚£äº›ä¸èƒ½æ”¯æŒå¤§é‡å¹¶å‘çº¿ç¨‹çš„ç³»ç»Ÿéå¸¸é‡è¦ã€‚ çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°é‡ç”±ç³»ç»ŸCPUçš„æ•°é‡ã€ç‰©ç†å†…å­˜çš„å¤§å°å’Œå¹¶å‘å®¢æˆ·è¯·æ±‚çš„æœŸæœ›å€¼ç­‰å› ç´ å†³å®šã€‚ è¿›ç¨‹å’Œçº¿ç¨‹æœ‰å“ªäº›è”ç³»å’ŒåŒºåˆ«ï¼Ÿå¤šè¿›ç¨‹è¿˜æ˜¯å¤šçº¿ç¨‹ï¼Ÿæˆ‘è¯¥æ€ä¹ˆé€‰æ‹©å‘¢ï¼Ÿå‚è€ƒèµ„æ–™ ã€Šæ“ä½œç³»ç»Ÿæ¦‚å¿µã€‹ è¿›ç¨‹å’Œçº¿ç¨‹çš„æ¦‚å¿µä»€ä¹ˆæ˜¯è¿›ç¨‹ä»€ä¹ˆæ˜¯çº¿ç¨‹è¿›ç¨‹é€šä¿¡å’Œçº¿ç¨‹é€šä¿¡è¿›ç¨‹é—´é€šä¿¡çº¿ç¨‹é—´é€šä¿¡è¿›ç¨‹å’Œçº¿ç¨‹ä¼˜ç¼ºç‚¹è¿›ç¨‹çš„ä¼˜ç¼ºç‚¹è¿›ç¨‹çš„ä¼˜ç‚¹è¿›ç¨‹çš„ç¼ºç‚¹çº¿ç¨‹çš„ä¼˜ç¼ºç‚¹çº¿ç¨‹çš„ä¼˜ç‚¹çº¿ç¨‹çš„ç¼ºç‚¹","categories":[{"name":"Tech","slug":"Tech","permalink":"https://leel0330.github.io/categories/Tech/"}],"tags":[]},{"title":"LeetCodeä¹‹å­—ç¬¦ä¸²(ä¸­ç­‰)","slug":"LeetCode-å­—ç¬¦ä¸²-ä¸­ç­‰","date":"2020-12-12T09:03:40.000Z","updated":"2020-12-27T05:06:34.892Z","comments":false,"path":"posts/723701661.html","link":"","permalink":"https://leel0330.github.io/posts/723701661.html","excerpt":"å­—ç¬¦ä¸²(ä¸­ç­‰)çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚","text":"å­—ç¬¦ä¸²(ä¸­ç­‰)çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ 3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¯·ä½ æ‰¾å‡ºå…¶ä¸­ä¸å«æœ‰é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²çš„é•¿åº¦ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: \"abcabcbb\" è¾“å‡º: 3 è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ \"abc\"ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 3ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: \"bbbbb\" è¾“å‡º: 1 è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ \"b\"ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 1ã€‚ ç¤ºä¾‹ 3: è¾“å…¥: \"pwwkew\" è¾“å‡º: 3 è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ \"wke\"ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 3ã€‚ è¯·æ³¨æ„ï¼Œä½ çš„ç­”æ¡ˆå¿…é¡»æ˜¯ å­ä¸² çš„é•¿åº¦ï¼Œ\"pwke\" æ˜¯ä¸€ä¸ªå­åºåˆ—ï¼Œä¸æ˜¯å­ä¸²ã€‚ PythonJava123456789101112131415161718class Solution(object): def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; n = len(s) cset = set() i, j, res = 0, 0, 0 while i &lt; n and j &lt; n: if s[j] not in cset: cset.add(s[j]) res = max(res, j - i + 1) j += 1 else: cset.remove(s[i]) i += 1 return res12345678910111213141516171819class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int i = 0, j = 0; Set&lt;Character&gt; hashSet = new HashSet&lt;&gt;(); int n = s.length(); int res = 0; while (i &lt; n) &#123; if (hashSet.contains(s.charAt(i))) &#123; hashSet.remove(s.charAt(j)); j += 1; &#125; else &#123; hashSet.add(s.charAt(i)); i += 1; &#125; res = Math.max(res, i - j); &#125; return res; &#125;&#125; 5. æœ€é•¿å›æ–‡å­ä¸²ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œæ‰¾åˆ° s ä¸­æœ€é•¿çš„å›æ–‡å­ä¸²ã€‚ä½ å¯ä»¥å‡è®¾ s çš„æœ€å¤§é•¿åº¦ä¸º 1000ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥: \"babad\" è¾“å‡º: \"bab\" æ³¨æ„: \"aba\" ä¹Ÿæ˜¯ä¸€ä¸ªæœ‰æ•ˆç­”æ¡ˆã€‚ ç¤ºä¾‹ 2ï¼š è¾“å…¥: \"cbbd\" è¾“å‡º: \"bb\" PythonJava123456789101112131415161718192021222324252627class Solution(object): def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; if s is None or len(s) == 0: return &quot;&quot; res_left, res_right, res_len = 0, 0, 0 for i in xrange(0, len(s)): l1, r1, len1 = self.helper(s, i, i) l2, r2, len2 = self.helper(s, i, i + 1) if len1 &gt; len2: if len1 &gt; res_len: res_left, res_right, res_len = l1, r1, len1 else: if len2 &gt; res_len: res_left, res_right, res_len = l2, r2, len2 res_str = s[res_left:res_right + 1] return res_str def helper(self, s, left, right): L, R = left, right while L &gt;= 0 and R &lt; len(s) and s[L] == s[R]: L -= 1 R += 1 return L + 1, R - 1, R - L - 112345678910111213141516171819202122232425262728class Solution &#123; private int len; private String res; public String longestPalindrome(String s) &#123; len = 0; res = &quot;&quot;; int n = s.length(); for (int i = 0; i &lt; n; i++) &#123; helper(s, i, i); helper(s, i, i + 1); &#125; return res; &#125; private void helper(String s, int left, int right) &#123; int i = left, j = right; int n = s.length(); while (i &gt; -1 &amp;&amp; j &lt; n &amp;&amp; s.charAt(i) == s.charAt(j)) &#123; i -= 1; j += 1; &#125; if (j - i - 1 &gt; len) &#123; len = j - i - 1; res = s.substring(i + 1, j); &#125; &#125;&#125; 6. ZZ å­—å½¢å˜æ¢å°†ä¸€ä¸ªç»™å®šå­—ç¬¦ä¸²æ ¹æ®ç»™å®šçš„è¡Œæ•°ï¼Œä»¥ä»ä¸Šå¾€ä¸‹ã€ä»å·¦åˆ°å³è¿›è¡Œ Z å­—å½¢æ’åˆ—ã€‚ æ¯”å¦‚è¾“å…¥å­—ç¬¦ä¸²ä¸º â€œLEETCODEISHIRINGâ€ è¡Œæ•°ä¸º 3 æ—¶ï¼Œæ’åˆ—å¦‚ä¸‹ï¼š L C I R E T O E S I I G E D H N ä¹‹åï¼Œä½ çš„è¾“å‡ºéœ€è¦ä»å·¦å¾€å³é€è¡Œè¯»å–ï¼Œäº§ç”Ÿå‡ºä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²ï¼Œæ¯”å¦‚ï¼šâ€LCIRETOESIIGEDHNâ€ã€‚ è¯·ä½ å®ç°è¿™ä¸ªå°†å­—ç¬¦ä¸²è¿›è¡ŒæŒ‡å®šè¡Œæ•°å˜æ¢çš„å‡½æ•°ï¼š string convert(string s, int numRows); ç¤ºä¾‹ 1: è¾“å…¥: s = \"LEETCODEISHIRING\", numRows = 3 è¾“å‡º: \"LCIRETOESIIGEDHN\" ç¤ºä¾‹ 2: è¾“å…¥: s = \"LEETCODEISHIRING\", numRows = 4 è¾“å‡º: \"LDREOEIIECIHNTSG\" è§£é‡Š: L D R E O E I I E C I H N T S G PythonJava12345678910111213141516171819202122class Solution(object): def convert(self, s, numRows): &quot;&quot;&quot; :type s: str :type numRows: int :rtype: str &quot;&quot;&quot; s_list = [[] for _ in xrange(numRows)] i, n = 0, len(s) while i &lt; n: for j in xrange(0, numRows): if i &lt; n: s_list[j].append(s[i]) i += 1 for j in xrange(numRows - 2, 0, -1): if i &lt; n: s_list[j].append(s[i]) i += 1 res = [] for i in xrange(numRows): res.extend(s_list[i]) return &#x27;&#x27;.join(res)123456789101112131415161718192021222324252627282930class Solution &#123; public String convert(String s, int numRows) &#123; List&lt;StringBuilder&gt; sbs = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; numRows; j++) &#123; sbs.add(new StringBuilder()); &#125; System.out.println(sbs.size()); int i = 0, n = s.length(); while (i &lt; n) &#123; for (int j = 0; j &lt; numRows; j++) &#123; if (i &lt; n) &#123; sbs.get(j).append(s.charAt(i)); i += 1; &#125; &#125; for (int j = numRows - 2; j &gt; 0; j--) &#123; if (i &lt; n) &#123; sbs.get(j).append(s.charAt(i)); i += 1; &#125; &#125; &#125; StringBuilder res = new StringBuilder(); for (StringBuilder sb : sbs) &#123; res.append(sb.toString()); &#125; return res.toString(); &#125;&#125; 22. æ‹¬å·ç”Ÿæˆç»™å‡º n ä»£è¡¨ç”Ÿæˆæ‹¬å·çš„å¯¹æ•°ï¼Œè¯·ä½ å†™å‡ºä¸€ä¸ªå‡½æ•°ï¼Œä½¿å…¶èƒ½å¤Ÿç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„å¹¶ä¸”æœ‰æ•ˆçš„æ‹¬å·ç»„åˆã€‚ ä¾‹å¦‚ï¼Œç»™å‡º n = 3ï¼Œç”Ÿæˆç»“æœä¸ºï¼š [ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] PythonJava12345678910111213141516171819class Solution(object): def generateParenthesis(self, n): &quot;&quot;&quot; :type n: int :rtype: List[str] &quot;&quot;&quot; item, res = &#x27;&#x27;, [] self.helper(res, item, 0, 0, n) return res def helper(self, res, item, left, right, n): if left == n and right == n: res.append(item) return if left &lt; n: self.helper(res, item + &#x27;(&#x27;, left + 1, right, n) if right &lt; left: self.helper(res, item + &#x27;)&#x27;, left, right + 1, n)12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if (n == 0) &#123; return res; &#125; helper(n, n, &quot;&quot;, res); return res; &#125; private void helper(int left, int right, String cur, List&lt;String&gt; res) &#123; if (left &gt; right) &#123; return; &#125; if (left == 0 &amp;&amp; right == 0) &#123; res.add(cur); return; &#125; if (left &gt; 0) &#123; helper(left - 1, right, cur + &quot;(&quot;, res); &#125; if (right &gt; left) &#123; helper(left, right - 1, cur + &quot;)&quot;, res); &#125; &#125;&#125; 91. è§£ç æ–¹æ³•ä¸€æ¡åŒ…å«å­—æ¯ A-Z çš„æ¶ˆæ¯é€šè¿‡ä»¥ä¸‹æ–¹å¼è¿›è¡Œäº†ç¼–ç ï¼š 'A' -> 1 'B' -> 2 ... 'Z' -> 26 ç»™å®šä¸€ä¸ªåªåŒ…å«æ•°å­—çš„éç©ºå­—ç¬¦ä¸²ï¼Œè¯·è®¡ç®—è§£ç æ–¹æ³•çš„æ€»æ•°ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: \"12\" è¾“å‡º: 2 è§£é‡Š: å®ƒå¯ä»¥è§£ç ä¸º \"AB\"ï¼ˆ1 2ï¼‰æˆ–è€… \"L\"ï¼ˆ12ï¼‰ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: \"226\" è¾“å‡º: 3 è§£é‡Š: å®ƒå¯ä»¥è§£ç ä¸º \"BZ\" (2 26), \"VF\" (22 6), æˆ–è€… \"BBF\" (2 2 6) ã€‚ PythonJava1234567891011121314151617181920class Solution(object): def numDecodings(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; if s is None or len(s) == 0: return 0 n = len(s) dp = [0 for _ in xrange(n + 1)] dp[0] = 1 dp[1] = 1 if s[0] != &#x27;0&#x27; else 0 for i in xrange(2, n + 1): one_c = int(s[i - 1:i]) two_c = int(s[i - 2:i]) if 1 &lt;= one_c &lt;= 9: dp[i] += dp[i - 1] if 10 &lt;= two_c &lt;= 26: dp[i] += dp[i - 2] return dp[n]123456789101112131415161718192021class Solution &#123; public int numDecodings(String s) &#123; int n = s.length(); int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = s.charAt(0) == &#x27;0&#x27; ? 0 : 1; for (int i = 2; i &lt; n + 1; i++) &#123; String one_s = s.substring(i - 1, i); String two_s = s.substring(i - 2, i); int one = Integer.parseInt(one_s); if (1 &lt;= one &amp;&amp; one &lt;= 9) &#123; dp[i] += dp[i - 1]; &#125; int two = Integer.parseInt(two_s); if (two &gt;= 10 &amp;&amp; two &lt;= 26) &#123; dp[i] += dp[i - 2]; &#125; &#125; return dp[n]; &#125;&#125; 93. å¤åŸIPåœ°å€ç»™å®šä¸€ä¸ªåªåŒ…å«æ•°å­—çš„å­—ç¬¦ä¸²ï¼Œå¤åŸå®ƒå¹¶è¿”å›æ‰€æœ‰å¯èƒ½çš„ IP åœ°å€æ ¼å¼ã€‚ ç¤ºä¾‹: è¾“å…¥: \"25525511135\" è¾“å‡º: [\"255.255.11.135\", \"255.255.111.35\"] PythonJava123456789101112131415161718192021222324252627282930class Solution(object): def restoreIpAddresses(self, s): &quot;&quot;&quot; :type s: str :rtype: List[str] &quot;&quot;&quot; item, res = [], [] if s is None or len(s) &lt; 4 or len(s) &gt; 12: return res self.helper(s, item, res) return res def helper(self, s, item, res): if s == &#x27;&#x27; and len(item) == 4: res.append(&#x27;.&#x27;.join(item[:])) return for i in xrange(1, 4): sub_s = s[:i] if len(sub_s) == i and self.ok(sub_s): item.append(sub_s) self.helper(s[i:], item, res) item.pop(-1) def ok(self, s): if len(s) == 0: return False if len(s) &gt; 1 and s[0] == &#x27;0&#x27;: return False n = int(s) return 0 &lt;= n &lt;= 2551234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public List&lt;String&gt; restoreIpAddresses(String s) &#123; int n = s.length(); List&lt;String&gt; res = new ArrayList&lt;&gt;(); if (n &lt; 4 || n &gt; 12) &#123; return res; &#125; List&lt;String&gt; item = new ArrayList&lt;&gt;(); helper(s, 0, item, res); return res; &#125; private void helper(String s, int idx, List&lt;String&gt; item, List&lt;String&gt; res) &#123; if (idx == 4) &#123; if (s.length() &gt; 0) &#123; return; &#125; List&lt;String&gt; tmp = new ArrayList&lt;&gt;(); tmp.addAll(item); res.add(String.join(&quot;.&quot;, tmp)); return; &#125; for (int i = 1; i &lt; 4; i++) &#123; if (s.length() &lt; i) &#123; continue; &#125; String substr = s.substring(0, i); if (isOK(substr)) &#123; item.add(substr); helper(s.substring(i), idx + 1, item, res); item.remove(item.size() - 1); &#125; &#125; &#125; private boolean isOK(String s) &#123; if (s.length() == 0 || s.length() &gt; 3) &#123; return false; &#125; if (s.length() &gt; 1 &amp;&amp; s.charAt(0) == &#x27;0&#x27;) &#123; return false; &#125; int n = Integer.parseInt(s); return n &gt;= 0 &amp;&amp; n &lt;= 255; &#125;&#125; 316. å»é™¤é‡å¤å­—æ¯ [n]ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s ï¼Œè¯·ä½ å»é™¤å­—ç¬¦ä¸²ä¸­é‡å¤çš„å­—æ¯ï¼Œä½¿å¾—æ¯ä¸ªå­—æ¯åªå‡ºç°ä¸€æ¬¡ã€‚éœ€ä¿è¯ è¿”å›ç»“æœçš„å­—å…¸åºæœ€å°ï¼ˆè¦æ±‚ä¸èƒ½æ‰“ä¹±å…¶ä»–å­—ç¬¦çš„ç›¸å¯¹ä½ç½®ï¼‰ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šs = \"bcabc\" è¾“å‡ºï¼š\"abc\" ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šs = \"cbacdcbc\" è¾“å‡ºï¼š\"acdb\" æç¤ºï¼š 1 &lt;= s.length &lt;= 10^4 s ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ PythonJava1234567891011121314151617class Solution(object): def removeDuplicateLetters(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; stk = [] seen = set() m = &#123;c: i for i, c in enumerate(s)&#125; for i, c in enumerate(s): if c not in seen: while stk and stk[-1] &gt; c and m[stk[-1]] &gt; i: rm_c = stk.pop(-1) seen.discard(rm_c) seen.add(c) stk.append(c) return &#x27;&#x27;.join(stk)1234567891011121314151617181920212223242526class Solution &#123; public String removeDuplicateLetters(String s) &#123; Stack&lt;Character&gt; stk = new Stack&lt;&gt;(); Set&lt;Character&gt; seen = new HashSet&lt;&gt;(); Map&lt;Character, Integer&gt; m = new HashMap&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; m.put(s.charAt(i), i); &#125; for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if (!seen.contains(c)) &#123; while (stk.size() &gt; 0 &amp;&amp; stk.peek() &gt; c &amp;&amp; m.get(stk.peek()) &gt; i) &#123; char rm_c = stk.pop().charValue(); seen.remove(rm_c); &#125; seen.add(c); stk.add(c); &#125; &#125; StringBuilder res = new StringBuilder(stk.size()); for (int i = 0; i &lt; stk.size(); i++) &#123; res.append(stk.get(i)); &#125; return res.toString(); &#125;&#125; 402. ç§»æ‰Kä½æ•°å­—ç»™å®šä¸€ä¸ªä»¥å­—ç¬¦ä¸²è¡¨ç¤ºçš„éè´Ÿæ•´æ•° numï¼Œç§»é™¤è¿™ä¸ªæ•°ä¸­çš„ k ä½æ•°å­—ï¼Œä½¿å¾—å‰©ä¸‹çš„æ•°å­—æœ€å°ã€‚ æ³¨æ„: num çš„é•¿åº¦å°äº 10002 ä¸” â‰¥ kã€‚ num ä¸ä¼šåŒ…å«ä»»ä½•å‰å¯¼é›¶ã€‚ ç¤ºä¾‹ 1 : è¾“å…¥: num = \"1432219\", k = 3 è¾“å‡º: \"1219\" è§£é‡Š: ç§»é™¤æ‰ä¸‰ä¸ªæ•°å­— 4, 3, å’Œ 2 å½¢æˆä¸€ä¸ªæ–°çš„æœ€å°çš„æ•°å­— 1219ã€‚ ç¤ºä¾‹ 2 : è¾“å…¥: num = \"10200\", k = 1 è¾“å‡º: \"200\" è§£é‡Š: ç§»æ‰é¦–ä½çš„ 1 å‰©ä¸‹çš„æ•°å­—ä¸º 200. æ³¨æ„è¾“å‡ºä¸èƒ½æœ‰ä»»ä½•å‰å¯¼é›¶ã€‚ ç¤ºä¾‹ 3 : è¾“å…¥: num = \"10\", k = 2 è¾“å‡º: \"0\" è§£é‡Š: ä»åŸæ•°å­—ç§»é™¤æ‰€æœ‰çš„æ•°å­—ï¼Œå‰©ä½™ä¸ºç©ºå°±æ˜¯0ã€‚ 12345678910111213141516171819class Solution(object): def removeKdigits(self, num, k): &quot;&quot;&quot; :type num: str :type k: int :rtype: str &quot;&quot;&quot; stk = [] for c in num: while k and stk and stk[-1] &gt; c: stk.pop(-1) k -= 1 stk.append(c) while k: stk.pop(-1) k -= 1 if not stk: return &#x27;0&#x27; return str(int(&#x27;&#x27;.join(stk))) 424. æ›¿æ¢åçš„æœ€é•¿é‡å¤å­—ç¬¦[n]ç»™ä½ ä¸€ä¸ªä»…ç”±å¤§å†™è‹±æ–‡å­—æ¯ç»„æˆçš„å­—ç¬¦ä¸²ï¼Œä½ å¯ä»¥å°†ä»»æ„ä½ç½®ä¸Šçš„å­—ç¬¦æ›¿æ¢æˆå¦å¤–çš„å­—ç¬¦ï¼Œæ€»å…±å¯æœ€å¤šæ›¿æ¢ k æ¬¡ã€‚åœ¨æ‰§è¡Œä¸Šè¿°æ“ä½œåï¼Œæ‰¾åˆ°åŒ…å«é‡å¤å­—æ¯çš„æœ€é•¿å­ä¸²çš„é•¿åº¦ã€‚ æ³¨æ„: å­—ç¬¦ä¸²é•¿åº¦ å’Œ k ä¸ä¼šè¶…è¿‡ 104ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: s = \"ABAB\", k = 2 è¾“å‡º: 4 è§£é‡Š: ç”¨ä¸¤ä¸ª'A'æ›¿æ¢ä¸ºä¸¤ä¸ª'B',åä¹‹äº¦ç„¶ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: s = \"AABABBA\", k = 1 è¾“å‡º: 4 è§£é‡Š: å°†ä¸­é—´çš„ä¸€ä¸ª'A'æ›¿æ¢ä¸º'B',å­—ç¬¦ä¸²å˜ä¸º \"AABBBBA\"ã€‚ å­ä¸² \"BBBB\" æœ‰æœ€é•¿é‡å¤å­—æ¯, ç­”æ¡ˆä¸º 4ã€‚ 123456789101112131415161718class Solution(object): def characterReplacement(self, s, k): &quot;&quot;&quot; :type s: str :type k: int :rtype: int &quot;&quot;&quot; m = &#123;&#125; start, end, max_freq, res = 0, 0, 0, 0 while end &lt; len(s): m[s[end]] = 1 if s[end] not in m else m[s[end]] + 1 max_freq = max(max_freq, m[s[end]]) if end - start + 1 - max_freq &gt; k: m[s[start]] -= 1 start += 1 res = max(res, end - start + 1) end += 1 return res 556. Next Greater Element III [n]ç»™å®šä¸€ä¸ª32ä½æ­£æ•´æ•° nï¼Œä½ éœ€è¦æ‰¾åˆ°æœ€å°çš„32ä½æ•´æ•°ï¼Œå…¶ä¸ n ä¸­å­˜åœ¨çš„ä½æ•°å®Œå…¨ç›¸åŒï¼Œå¹¶ä¸”å…¶å€¼å¤§äºnã€‚å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„32ä½æ•´æ•°ï¼Œåˆ™è¿”å›-1ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: 12 è¾“å‡º: 21 ç¤ºä¾‹ 2: è¾“å…¥: 21 è¾“å‡º: -1 1234567891011121314151617181920212223242526class Solution(object): def nextGreaterElement(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; max_val = (1 &lt;&lt; 32) - 1 nums = [int(i) for i in str(n)] i = len(nums) - 1 while i &gt; 0: if nums[i - 1] &lt; nums[i]: break i -= 1 if i == 0: return -1 x = nums[i - 1] smallest = i for j in xrange(i + 1, len(nums)): if nums[j] &gt; x and nums[j] &lt; nums[smallest]: smallest = j nums[i - 1], nums[smallest] = nums[smallest], nums[i - 1] left = nums[:i] right = sorted(nums[i:]) nums = left + right v = int(&#x27;&#x27;.join([str(i) for i in nums])) return v if v &lt; max_val else -1 583. ä¸¤ä¸ªå­—ç¬¦ä¸²çš„åˆ é™¤æ“ä½œ [n]ç»™å®šä¸¤ä¸ªå•è¯ word1 å’Œ word2ï¼Œæ‰¾åˆ°ä½¿å¾— word1 å’Œ word2 ç›¸åŒæ‰€éœ€çš„æœ€å°æ­¥æ•°ï¼Œæ¯æ­¥å¯ä»¥åˆ é™¤ä»»æ„ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­çš„ä¸€ä¸ªå­—ç¬¦ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: \"sea\", \"eat\" è¾“å‡º: 2 è§£é‡Š: ç¬¬ä¸€æ­¥å°†\"sea\"å˜ä¸º\"ea\"ï¼Œç¬¬äºŒæ­¥å°†\"eat\"å˜ä¸º\"ea\" è¯´æ˜: ç»™å®šå•è¯çš„é•¿åº¦ä¸è¶…è¿‡500ã€‚ ç»™å®šå•è¯ä¸­çš„å­—ç¬¦åªå«æœ‰å°å†™å­—æ¯ã€‚ 12345678910111213141516171819class Solution(object): def minDistance(self, word1, word2): &quot;&quot;&quot; :type word1: str :type word2: str :rtype: int &quot;&quot;&quot; len1, len2 = len(word1), len(word2) dp = [[0 for _ in xrange(len2 + 1)] for _ in xrange(len1 + 1)] for i in xrange(len1 + 1): for j in xrange(len2 + 1): if i == 0 or j == 0: continue elif word1[i - 1] == word2[j - 1]: dp[i][j] = 1 + dp[i - 1][j - 1] else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) lcs = dp[len1][len2] return len1 + len2 - 2 * lcs 647. å›æ–‡å­ä¸²ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä½ çš„ä»»åŠ¡æ˜¯è®¡ç®—è¿™ä¸ªå­—ç¬¦ä¸²ä¸­æœ‰å¤šå°‘ä¸ªå›æ–‡å­ä¸²ã€‚ å…·æœ‰ä¸åŒå¼€å§‹ä½ç½®æˆ–ç»“æŸä½ç½®çš„å­ä¸²ï¼Œå³ä½¿æ˜¯ç”±ç›¸åŒçš„å­—ç¬¦ç»„æˆï¼Œä¹Ÿä¼šè¢«è®¡ä¸ºæ˜¯ä¸åŒçš„å­ä¸²ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: \"abc\" è¾“å‡º: 3 è§£é‡Š: ä¸‰ä¸ªå›æ–‡å­ä¸²: \"a\", \"b\", \"c\". ç¤ºä¾‹ 2: è¾“å…¥: \"aaa\" è¾“å‡º: 6 è¯´æ˜: 6ä¸ªå›æ–‡å­ä¸²: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\". æ³¨æ„: è¾“å…¥çš„å­—ç¬¦ä¸²é•¿åº¦ä¸ä¼šè¶…è¿‡1000ã€‚ 1234567891011121314151617181920class Solution(object): def __init__(self): self.res = 0 def countSubstrings(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; self.res = 0 for i in xrange(0, len(s)): self.helper(s, i, i) self.helper(s, i, i + 1) return self.res def helper(self, s, left, right): while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]: self.res += 1 left -= 1 right += 1 678. æœ‰æ•ˆçš„æ‹¬å·å­—ç¬¦ä¸² [n]ç»™å®šä¸€ä¸ªåªåŒ…å«ä¸‰ç§å­—ç¬¦çš„å­—ç¬¦ä¸²ï¼šï¼ˆ ï¼Œï¼‰ å’Œ *ï¼Œå†™ä¸€ä¸ªå‡½æ•°æ¥æ£€éªŒè¿™ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ä¸ºæœ‰æ•ˆå­—ç¬¦ä¸²ã€‚æœ‰æ•ˆå­—ç¬¦ä¸²å…·æœ‰å¦‚ä¸‹è§„åˆ™ï¼š ä»»ä½•å·¦æ‹¬å· ( å¿…é¡»æœ‰ç›¸åº”çš„å³æ‹¬å· )ã€‚ ä»»ä½•å³æ‹¬å· ) å¿…é¡»æœ‰ç›¸åº”çš„å·¦æ‹¬å· ( ã€‚ å·¦æ‹¬å· ( å¿…é¡»åœ¨å¯¹åº”çš„å³æ‹¬å·ä¹‹å‰ )ã€‚ * å¯ä»¥è¢«è§†ä¸ºå•ä¸ªå³æ‹¬å· ) ï¼Œæˆ–å•ä¸ªå·¦æ‹¬å· ( ï¼Œæˆ–ä¸€ä¸ªç©ºå­—ç¬¦ä¸²ã€‚ ä¸€ä¸ªç©ºå­—ç¬¦ä¸²ä¹Ÿè¢«è§†ä¸ºæœ‰æ•ˆå­—ç¬¦ä¸²ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: \"()\" è¾“å‡º: True ç¤ºä¾‹ 2: è¾“å…¥: \"(*)\" è¾“å‡º: True ç¤ºä¾‹ 3: è¾“å…¥: \"(*))\" è¾“å‡º: True æ³¨æ„: å­—ç¬¦ä¸²å¤§å°å°†åœ¨ [1ï¼Œ100] èŒƒå›´å†…ã€‚ 123456789101112131415161718192021class Solution(object): def checkValidString(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; low, high = 0, 0 for c in s: if c == &#x27;(&#x27;: low, high = low +1, high + 1 elif c == &#x27;)&#x27;: if low &gt; 0: low -= 1 high -= 1 else: if low &gt; 0: low -= 1 high += 1 if high &lt; 0: return False return low == 0 767. é‡æ„å­—ç¬¦ä¸²ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²Sï¼Œæ£€æŸ¥æ˜¯å¦èƒ½é‡æ–°æ’å¸ƒå…¶ä¸­çš„å­—æ¯ï¼Œä½¿å¾—ä¸¤ç›¸é‚»çš„å­—ç¬¦ä¸åŒã€‚ è‹¥å¯è¡Œï¼Œè¾“å‡ºä»»æ„å¯è¡Œçš„ç»“æœã€‚è‹¥ä¸å¯è¡Œï¼Œè¿”å›ç©ºå­—ç¬¦ä¸²ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: S = \"aab\" è¾“å‡º: \"aba\" ç¤ºä¾‹ 2: è¾“å…¥: S = \"aaab\" è¾“å‡º: \"\" æ³¨æ„: S åªåŒ…å«å°å†™å­—æ¯å¹¶ä¸”é•¿åº¦åœ¨[1, 500]åŒºé—´å†…ã€‚ 123456789101112131415161718192021222324252627282930313233343536class Solution(object): def reorganizeString(self, S): &quot;&quot;&quot; :type S: str :rtype: str &quot;&quot;&quot; char_cnt = [0 for _ in xrange(26)] max_char = None i_a = ord(&#x27;a&#x27;) for c in S: i = ord(c) - i_a char_cnt[i] += 1 if max_char is None: max_char = c else: j = ord(max_char) - i_a if char_cnt[i] &gt; char_cnt[j]: max_char = c if 2 * char_cnt[ord(max_char) - i_a] -1 &gt; len(S): return &quot;&quot; res = [&#x27;&#x27; for _ in xrange(len(S))] i_max_char = ord(max_char) - i_a i = 0 for j in xrange (char_cnt[i_max_char]): res[i] = max_char i += 2 char_cnt[i_max_char] = 0 for j in xrange(26): if char_cnt[j] &gt; 0: c = chr(j + i_a) for k in xrange(char_cnt[j]): if i &gt;= len(S): i = 1 res[i] = c i += 2 return &quot;&quot;.join(res) 856. æ‹¬å·çš„åˆ†æ•°ç»™å®šä¸€ä¸ªå¹³è¡¡æ‹¬å·å­—ç¬¦ä¸² Sï¼ŒæŒ‰ä¸‹è¿°è§„åˆ™è®¡ç®—è¯¥å­—ç¬¦ä¸²çš„åˆ†æ•°ï¼š () å¾— 1 åˆ†ã€‚AB å¾— A + B åˆ†ï¼Œå…¶ä¸­ A å’Œ B æ˜¯å¹³è¡¡æ‹¬å·å­—ç¬¦ä¸²ã€‚(A) å¾— 2 * A åˆ†ï¼Œå…¶ä¸­ A æ˜¯å¹³è¡¡æ‹¬å·å­—ç¬¦ä¸²ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼š \"()\" è¾“å‡ºï¼š 1 ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼š \"(())\" è¾“å‡ºï¼š 2 ç¤ºä¾‹ 3ï¼š è¾“å…¥ï¼š \"()()\" è¾“å‡ºï¼š 2 ç¤ºä¾‹ 4ï¼š è¾“å…¥ï¼š \"(()(()))\" è¾“å‡ºï¼š 6 æç¤ºï¼š S æ˜¯å¹³è¡¡æ‹¬å·å­—ç¬¦ä¸²ï¼Œä¸”åªå«æœ‰ ( å’Œ ) ã€‚ 2 &lt;= S.length &lt;= 50 123456789101112131415161718192021class Solution(object): def scoreOfParentheses(self, S): &quot;&quot;&quot; :type S: str :rtype: int &quot;&quot;&quot; stk = [] for c in S: if c == &#x27;(&#x27;: stk.append(-1) else: cnt = 0 while stk[-1] != -1: cnt += stk[-1] stk.pop(-1) stk.pop(-1) if cnt == 0: stk.append(1) else: stk.append(2 * cnt) return sum(stk) 890. æŸ¥æ‰¾å’Œæ›¿æ¢æ¨¡å¼ä½ æœ‰ä¸€ä¸ªå•è¯åˆ—è¡¨ words å’Œä¸€ä¸ªæ¨¡å¼ patternï¼Œä½ æƒ³çŸ¥é“ words ä¸­çš„å“ªäº›å•è¯ä¸æ¨¡å¼åŒ¹é…ã€‚ å¦‚æœå­˜åœ¨å­—æ¯çš„æ’åˆ— p ï¼Œä½¿å¾—å°†æ¨¡å¼ä¸­çš„æ¯ä¸ªå­—æ¯ x æ›¿æ¢ä¸º p(x) ä¹‹åï¼Œæˆ‘ä»¬å°±å¾—åˆ°äº†æ‰€éœ€çš„å•è¯ï¼Œé‚£ä¹ˆå•è¯ä¸æ¨¡å¼æ˜¯åŒ¹é…çš„ã€‚ ï¼ˆå›æƒ³ä¸€ä¸‹ï¼Œå­—æ¯çš„æ’åˆ—æ˜¯ä»å­—æ¯åˆ°å­—æ¯çš„åŒå°„ï¼šæ¯ä¸ªå­—æ¯æ˜ å°„åˆ°å¦ä¸€ä¸ªå­—æ¯ï¼Œæ²¡æœ‰ä¸¤ä¸ªå­—æ¯æ˜ å°„åˆ°åŒä¸€ä¸ªå­—æ¯ã€‚ï¼‰ è¿”å› words ä¸­ä¸ç»™å®šæ¨¡å¼åŒ¹é…çš„å•è¯åˆ—è¡¨ã€‚ ä½ å¯ä»¥æŒ‰ä»»ä½•é¡ºåºè¿”å›ç­”æ¡ˆã€‚ ç¤ºä¾‹ï¼š è¾“å…¥ï¼šwords = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\" è¾“å‡ºï¼š[\"mee\",\"aqq\"] è§£é‡Šï¼š \"mee\" ä¸æ¨¡å¼åŒ¹é…ï¼Œå› ä¸ºå­˜åœ¨æ’åˆ— {a -> m, b -> e, ...}ã€‚ \"ccc\" ä¸æ¨¡å¼ä¸åŒ¹é…ï¼Œå› ä¸º {a -> c, b -> c, ...} ä¸æ˜¯æ’åˆ—ã€‚ å› ä¸º a å’Œ b æ˜ å°„åˆ°åŒä¸€ä¸ªå­—æ¯ã€‚ æç¤ºï¼š 1 &lt;= words.length &lt;= 50 1 &lt;= pattern.length = words[i].length &lt;= 20 12345678910111213141516171819202122232425class Solution(object): def findAndReplacePattern(self, words, pattern): &quot;&quot;&quot; :type words: List[str] :type pattern: str :rtype: List[str] &quot;&quot;&quot; res = [] p = self.helper(pattern) for w in words: pw = self.helper(w) if pw == p: res.append(w) return res def helper(self, pattern): m = &#123;&#125; res = [] for c in pattern: if c in m: res.append(m[c]) else: m[c] = len(m) + 1 res.append(m[c]) return &#x27;&#x27;.join([str(i) for i in res])","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCodeä¹‹å­—ç¬¦ä¸²(ç®€å•)","slug":"LeetCode-å­—ç¬¦ä¸²-ç®€å•","date":"2020-12-11T13:38:13.000Z","updated":"2020-12-27T05:06:53.757Z","comments":false,"path":"posts/c026ad95.html","link":"","permalink":"https://leel0330.github.io/posts/c026ad95.html","excerpt":"å­—ç¬¦ä¸²(ç®€å•)çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚","text":"å­—ç¬¦ä¸²(ç®€å•)çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ 14. æœ€é•¿å…¬å…±å‰ç¼€ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥æŸ¥æ‰¾å­—ç¬¦ä¸²æ•°ç»„ä¸­çš„æœ€é•¿å…¬å…±å‰ç¼€ã€‚ å¦‚æœä¸å­˜åœ¨å…¬å…±å‰ç¼€ï¼Œè¿”å›ç©ºå­—ç¬¦ä¸² â€œâ€ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [\"flower\",\"flow\",\"flight\"] è¾“å‡º: \"fl\" ç¤ºä¾‹ 2: è¾“å…¥: [\"dog\",\"racecar\",\"car\"] è¾“å‡º: \"\" è§£é‡Š: è¾“å…¥ä¸å­˜åœ¨å…¬å…±å‰ç¼€ã€‚ è¯´æ˜: æ‰€æœ‰è¾“å…¥åªåŒ…å«å°å†™å­—æ¯ a-z ã€‚ 123456789101112131415class Solution(object): def longestCommonPrefix(self, strs): &quot;&quot;&quot; :type strs: List[str] :rtype: str &quot;&quot;&quot; res = &quot;&quot; if strs is None or len(strs) == 0: return res for i, c in enumerate(strs[0]): for j in xrange(1, len(strs)): if i &gt;= len(strs[j]) or strs[j][i] != c: return res res += c return res 443. å‹ç¼©å­—ç¬¦ä¸²ç»™å®šä¸€ç»„å­—ç¬¦ï¼Œä½¿ç”¨åŸåœ°ç®—æ³•å°†å…¶å‹ç¼©ã€‚ å‹ç¼©åçš„é•¿åº¦å¿…é¡»å§‹ç»ˆå°äºæˆ–ç­‰äºåŸæ•°ç»„é•¿åº¦ã€‚ æ•°ç»„çš„æ¯ä¸ªå…ƒç´ åº”è¯¥æ˜¯é•¿åº¦ä¸º1 çš„å­—ç¬¦ï¼ˆä¸æ˜¯ int æ•´æ•°ç±»å‹ï¼‰ã€‚ åœ¨å®ŒæˆåŸåœ°ä¿®æ”¹è¾“å…¥æ•°ç»„åï¼Œè¿”å›æ•°ç»„çš„æ–°é•¿åº¦ã€‚ è¿›é˜¶ï¼š ä½ èƒ½å¦ä»…ä½¿ç”¨O(1) ç©ºé—´è§£å†³é—®é¢˜ï¼Ÿ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼š [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"] è¾“å‡ºï¼š è¿”å›6ï¼Œè¾“å…¥æ•°ç»„çš„å‰6ä¸ªå­—ç¬¦åº”è¯¥æ˜¯ï¼š[\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"] è¯´æ˜ï¼š \"aa\"è¢«\"a2\"æ›¿ä»£ã€‚\"bb\"è¢«\"b2\"æ›¿ä»£ã€‚\"ccc\"è¢«\"c3\"æ›¿ä»£ã€‚ ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼š [\"a\"] è¾“å‡ºï¼š è¿”å›1ï¼Œè¾“å…¥æ•°ç»„çš„å‰1ä¸ªå­—ç¬¦åº”è¯¥æ˜¯ï¼š[\"a\"] è¯´æ˜ï¼š æ²¡æœ‰ä»»ä½•å­—ç¬¦ä¸²è¢«æ›¿ä»£ã€‚ ç¤ºä¾‹ 3ï¼š è¾“å…¥ï¼š [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"] è¾“å‡ºï¼š è¿”å›4ï¼Œè¾“å…¥æ•°ç»„çš„å‰4ä¸ªå­—ç¬¦åº”è¯¥æ˜¯ï¼š[\"a\",\"b\",\"1\",\"2\"]ã€‚ è¯´æ˜ï¼š ç”±äºå­—ç¬¦\"a\"ä¸é‡å¤ï¼Œæ‰€ä»¥ä¸ä¼šè¢«å‹ç¼©ã€‚\"bbbbbbbbbbbb\"è¢«â€œb12â€æ›¿ä»£ã€‚ æ³¨æ„æ¯ä¸ªæ•°å­—åœ¨æ•°ç»„ä¸­éƒ½æœ‰å®ƒè‡ªå·±çš„ä½ç½®ã€‚ æ³¨æ„ï¼š æ‰€æœ‰å­—ç¬¦éƒ½æœ‰ä¸€ä¸ªASCIIå€¼åœ¨[35, 126]åŒºé—´å†…ã€‚ 1 &lt;= len(chars) &lt;= 1000ã€‚ 123456789101112131415161718192021class Solution(object): def compress(self, chars): &quot;&quot;&quot; :type chars: List[str] :rtype: int &quot;&quot;&quot; res = [] i = 0 while i &lt; len(chars): c, cnt = chars[i], 0 while i &lt; len(chars) and chars[i] == c: cnt += 1 i += 1 if cnt == 1: res.append(c) else: res.append(c) res.extend([c for c in str(cnt)]) for idx, c in enumerate(res): chars[idx] = c return len(res) 680. éªŒè¯å›æ–‡å­—ç¬¦ä¸² â…¡ç»™å®šä¸€ä¸ªéç©ºå­—ç¬¦ä¸² sï¼Œæœ€å¤šåˆ é™¤ä¸€ä¸ªå­—ç¬¦ã€‚åˆ¤æ–­æ˜¯å¦èƒ½æˆä¸ºå›æ–‡å­—ç¬¦ä¸²ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: \"aba\" è¾“å‡º: True ç¤ºä¾‹ 2: è¾“å…¥: \"abca\" è¾“å‡º: True è§£é‡Š: ä½ å¯ä»¥åˆ é™¤cå­—ç¬¦ã€‚ æ³¨æ„: å­—ç¬¦ä¸²åªåŒ…å«ä» a-z çš„å°å†™å­—æ¯ã€‚å­—ç¬¦ä¸²çš„æœ€å¤§é•¿åº¦æ˜¯50000 12345678910111213141516171819202122232425class Solution(object): def validPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; i, j = 0, len(s) - 1 while i &lt; j and s[i] == s[j]: i += 1 j -= 1 if i &gt;= j: return True if self.isPalindrome(s, i + 1, j) or self.isPalindrome(s, i, j - 1): return True return False def isPalindrome(self, s, i, j): if i &gt; j: return False while i &lt; j: if s[i] != s[j]: return False i += 1 j -= 1 return True 696. è®¡æ•°äºŒè¿›åˆ¶å­ä¸² [n]ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œè®¡ç®—å…·æœ‰ç›¸åŒæ•°é‡0å’Œ1çš„éç©º(è¿ç»­)å­å­—ç¬¦ä¸²çš„æ•°é‡ï¼Œå¹¶ä¸”è¿™äº›å­å­—ç¬¦ä¸²ä¸­çš„æ‰€æœ‰0å’Œæ‰€æœ‰1éƒ½æ˜¯ç»„åˆåœ¨ä¸€èµ·çš„ã€‚ é‡å¤å‡ºç°çš„å­ä¸²è¦è®¡ç®—å®ƒä»¬å‡ºç°çš„æ¬¡æ•°ã€‚ ç¤ºä¾‹ 1 : è¾“å…¥: \"00110011\" è¾“å‡º: 6 è§£é‡Š: æœ‰6ä¸ªå­ä¸²å…·æœ‰ç›¸åŒæ•°é‡çš„è¿ç»­1å’Œ0ï¼šâ€œ0011â€ï¼Œâ€œ01â€ï¼Œâ€œ1100â€ï¼Œâ€œ10â€ï¼Œâ€œ0011â€ å’Œ â€œ01â€ã€‚ è¯·æ³¨æ„ï¼Œä¸€äº›é‡å¤å‡ºç°çš„å­ä¸²è¦è®¡ç®—å®ƒä»¬å‡ºç°çš„æ¬¡æ•°ã€‚ å¦å¤–ï¼Œâ€œ00110011â€ä¸æ˜¯æœ‰æ•ˆçš„å­ä¸²ï¼Œå› ä¸ºæ‰€æœ‰çš„0ï¼ˆå’Œ1ï¼‰æ²¡æœ‰ç»„åˆåœ¨ä¸€èµ·ã€‚ ç¤ºä¾‹ 2 : è¾“å…¥: \"10101\" è¾“å‡º: 4 è§£é‡Š: æœ‰4ä¸ªå­ä¸²ï¼šâ€œ10â€ï¼Œâ€œ01â€ï¼Œâ€œ10â€ï¼Œâ€œ01â€ï¼Œå®ƒä»¬å…·æœ‰ç›¸åŒæ•°é‡çš„è¿ç»­1å’Œ0ã€‚ æ³¨æ„ï¼š s.length åœ¨1åˆ°50,000ä¹‹é—´ã€‚ s åªåŒ…å«â€œ0â€æˆ–â€œ1â€å­—ç¬¦ã€‚ 123456789101112131415161718class Solution(object): def countBinarySubstrings(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; res = pre = 0 cur = 1 n = len(s) for i in xrange(1, n): if s[i] == s[i - 1]: cur += 1 else: pre = cur cur = 1 if pre &gt;= cur: res += 1 return res 788. æ—‹è½¬æ•°å­—æˆ‘ä»¬ç§°ä¸€ä¸ªæ•° X ä¸ºå¥½æ•°, å¦‚æœå®ƒçš„æ¯ä½æ•°å­—é€ä¸ªåœ°è¢«æ—‹è½¬ 180 åº¦åï¼Œæˆ‘ä»¬ä»å¯ä»¥å¾—åˆ°ä¸€ä¸ªæœ‰æ•ˆçš„ï¼Œä¸”å’Œ X ä¸åŒçš„æ•°ã€‚è¦æ±‚æ¯ä½æ•°å­—éƒ½è¦è¢«æ—‹è½¬ã€‚ å¦‚æœä¸€ä¸ªæ•°çš„æ¯ä½æ•°å­—è¢«æ—‹è½¬ä»¥åä»ç„¶è¿˜æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œ åˆ™è¿™ä¸ªæ•°æ˜¯æœ‰æ•ˆçš„ã€‚0, 1, å’Œ 8 è¢«æ—‹è½¬åä»ç„¶æ˜¯å®ƒä»¬è‡ªå·±ï¼›2 å’Œ 5 å¯ä»¥äº’ç›¸æ—‹è½¬æˆå¯¹æ–¹ï¼›6 å’Œ 9 åŒç†ï¼Œé™¤äº†è¿™äº›ä»¥å¤–å…¶ä»–çš„æ•°å­—æ—‹è½¬ä»¥åéƒ½ä¸å†æ˜¯æœ‰æ•ˆçš„æ•°å­—ã€‚ ç°åœ¨æˆ‘ä»¬æœ‰ä¸€ä¸ªæ­£æ•´æ•° N, è®¡ç®—ä» 1 åˆ° N ä¸­æœ‰å¤šå°‘ä¸ªæ•° X æ˜¯å¥½æ•°ï¼Ÿ ç¤ºä¾‹: è¾“å…¥: 10 è¾“å‡º: 4 è§£é‡Š: åœ¨[1, 10]ä¸­æœ‰å››ä¸ªå¥½æ•°ï¼š 2, 5, 6, 9ã€‚ æ³¨æ„ 1 å’Œ 10 ä¸æ˜¯å¥½æ•°, å› ä¸ºä»–ä»¬åœ¨æ—‹è½¬ä¹‹åä¸å˜ã€‚ æ³¨æ„: N çš„å–å€¼èŒƒå›´æ˜¯ [1, 10000]ã€‚ 123456789101112131415161718class Solution(object): def rotatedDigits(self, N): &quot;&quot;&quot; :type N: int :rtype: int &quot;&quot;&quot; cnt = 0 for i in xrange(1, N + 1): if self.isGoodNum(i): cnt += 1 return cnt def isGoodNum(self, n): if any(x in str(n) for x in [&#x27;3&#x27;, &#x27;4&#x27;, &#x27;7&#x27;]): return False if any(x in str(n) for x in [&#x27;2&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;9&#x27;]): return True return False 859. äº²å¯†å­—ç¬¦ä¸²ç»™å®šä¸¤ä¸ªç”±å°å†™å­—æ¯æ„æˆçš„å­—ç¬¦ä¸² A å’Œ B ï¼Œåªè¦æˆ‘ä»¬å¯ä»¥é€šè¿‡äº¤æ¢ A ä¸­çš„ä¸¤ä¸ªå­—æ¯å¾—åˆ°ä¸ B ç›¸ç­‰çš„ç»“æœï¼Œå°±è¿”å› true ï¼›å¦åˆ™è¿”å› false ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼š A = \"ab\", B = \"ba\" è¾“å‡ºï¼š true ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼š A = \"ab\", B = \"ab\" è¾“å‡ºï¼š false ç¤ºä¾‹ 3: è¾“å…¥ï¼š A = \"aa\", B = \"aa\" è¾“å‡ºï¼š true ç¤ºä¾‹ 4ï¼š è¾“å…¥ï¼š A = \"aaaaaaabc\", B = \"aaaaaaacb\" è¾“å‡ºï¼š true ç¤ºä¾‹ 5ï¼š è¾“å…¥ï¼š A = \"\", B = \"aa\" è¾“å‡ºï¼š false æç¤ºï¼š 0 &lt;= A.length &lt;= 20000 0 &lt;= B.length &lt;= 20000 A å’Œ B ä»…ç”±å°å†™å­—æ¯æ„æˆã€‚ 1234567891011121314151617class Solution(object): def buddyStrings(self, A, B): if len(A) != len(B): return False if A == B: seen = set() for a in A: if a in seen: return True seen.add(a) return False else: pairs = [] for a, b in zip(A, B): if a != b: pairs.append((a, b)) if len(pairs) &gt; 2: return False return len(pairs) == 2 and pairs[0] == pairs[1][::-1] 925. é•¿æŒ‰é”®å…¥ä½ çš„æœ‹å‹æ­£åœ¨ä½¿ç”¨é”®ç›˜è¾“å…¥ä»–çš„åå­— nameã€‚å¶å°”ï¼Œåœ¨é”®å…¥å­—ç¬¦ c æ—¶ï¼ŒæŒ‰é”®å¯èƒ½ä¼šè¢«é•¿æŒ‰ï¼Œè€Œå­—ç¬¦å¯èƒ½è¢«è¾“å…¥ 1 æ¬¡æˆ–å¤šæ¬¡ã€‚ ä½ å°†ä¼šæ£€æŸ¥é”®ç›˜è¾“å…¥çš„å­—ç¬¦ typedã€‚å¦‚æœå®ƒå¯¹åº”çš„å¯èƒ½æ˜¯ä½ çš„æœ‹å‹çš„åå­—ï¼ˆå…¶ä¸­ä¸€äº›å­—ç¬¦å¯èƒ½è¢«é•¿æŒ‰ï¼‰ï¼Œé‚£ä¹ˆå°±è¿”å› Trueã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šname = \"alex\", typed = \"aaleex\" è¾“å‡ºï¼štrue è§£é‡Šï¼š'alex' ä¸­çš„ 'a' å’Œ 'e' è¢«é•¿æŒ‰ã€‚ ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šname = \"saeed\", typed = \"ssaaedd\" è¾“å‡ºï¼šfalse è§£é‡Šï¼š'e' ä¸€å®šéœ€è¦è¢«é”®å…¥ä¸¤æ¬¡ï¼Œä½†åœ¨ typed çš„è¾“å‡ºä¸­ä¸æ˜¯è¿™æ ·ã€‚ ç¤ºä¾‹ 3ï¼š è¾“å…¥ï¼šname = \"leelee\", typed = \"lleeelee\" è¾“å‡ºï¼štrue ç¤ºä¾‹ 4ï¼š è¾“å…¥ï¼šname = \"laiden\", typed = \"laiden\" è¾“å‡ºï¼štrue è§£é‡Šï¼šé•¿æŒ‰åå­—ä¸­çš„å­—ç¬¦å¹¶ä¸æ˜¯å¿…è¦çš„ã€‚ æç¤ºï¼š name.length &lt;= 1000 typed.length &lt;= 1000 name å’Œ typed çš„å­—ç¬¦éƒ½æ˜¯å°å†™å­—æ¯ã€‚ 123456789101112131415161718192021222324252627282930class Solution(object): def isLongPressedName(self, name, typed): &quot;&quot;&quot; :type name: str :type typed: str :rtype: bool &quot;&quot;&quot; a = self.getHelper(name) b = self.getHelper(typed) if len(a) != len(b): return False for idx in xrange(0, len(a), 2): if a[idx] != b[idx]: return False if a[idx + 1] &gt; b[idx + 1]: return False return True def getHelper(self, s): res = [] idx = 0 while idx &lt; len(s): cur_c, cnt = s[idx], 0 while idx &lt; len(s) and s[idx] == cur_c: idx += 1 cnt += 1 res.append(cur_c) res.append(cnt) return res","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCodeåˆ·é¢˜æŒ‡å—(æŒç»­æ›´æ–°ä¸­)","slug":"LeetCodeåˆ·é¢˜æŒ‡å—","date":"2020-12-05T07:07:21.000Z","updated":"2021-03-14T14:04:19.203Z","comments":false,"path":"posts/af9ea9dd.html","link":"","permalink":"https://leel0330.github.io/posts/af9ea9dd.html","excerpt":"è¿™ä¸ªLeetCodeåˆ†ç±»æ˜¯æˆ‘åˆ·é¢˜è¿‡ç¨‹ä¸­æ•´ç†å‡ºæ¥çš„å€¼å¾—åˆ·çš„é¢˜ç›®ã€‚ å› ä¸ºæˆ‘å¯¹Pythonæ¯”è¾ƒç†Ÿç»ƒï¼Œæ‰€ä»¥å¤§éƒ¨åˆ†ä»£ç æ˜¯ç”¨Pythonå®ç°çš„ğŸ˜¬ã€‚","text":"è¿™ä¸ªLeetCodeåˆ†ç±»æ˜¯æˆ‘åˆ·é¢˜è¿‡ç¨‹ä¸­æ•´ç†å‡ºæ¥çš„å€¼å¾—åˆ·çš„é¢˜ç›®ã€‚ å› ä¸ºæˆ‘å¯¹Pythonæ¯”è¾ƒç†Ÿç»ƒï¼Œæ‰€ä»¥å¤§éƒ¨åˆ†ä»£ç æ˜¯ç”¨Pythonå®ç°çš„ğŸ˜¬ã€‚ é¦–å…ˆéœ€è¦è¯´æ˜çš„æ˜¯ï¼Œæœ¬äººä¸åšå¤§è€Œå…¨çš„åˆ·é¢˜ç›®å½•ï¼Œé¢˜ç›®ç°åœ¨å®åœ¨å¤ªå¤šäº†ï¼Œè€Œä¸”ç½‘ä¸Šå·²ç»æœ‰ä¸€äº›äººè¿™ä¹ˆåšäº†ï¼Œå¯¹äºåˆšå¼€å§‹åˆ·é¢˜çš„ä½ å…¶å®å¹¶ä¸æ˜¯ååˆ†å‹å¥½ã€‚å¦‚æœéœ€è¦æˆ‘å¯ä»¥åœ¨ç»“å°¾ç»™å‡ºä¸€äº›é“¾æ¥ï¼ŒåŸºæœ¬æ¶µç›–äº†æ‰€æœ‰é¢˜ç›®ï¼Œè€Œä¸”ä¹Ÿæœ‰ä¸€äº›è¯¦ç»†çš„è§£é‡Šã€‚æœ¬äººä¹Ÿä¸åšé¢˜è§£ï¼Œå› ä¸ºä»£ç èƒ½çœ‹æ‡‚çš„è¯åŸºæœ¬ä¸Šä¸éœ€è¦å†é˜é‡Šäº†ï¼Œå¦‚æœä½ éœ€è¦ï¼Œå¯ä»¥å‚è€ƒæˆ‘ç»™å‡ºçš„é“¾æ¥ï¼Œæˆ‘åœ¨åˆ·é¢˜è¿‡ç¨‹ä¸­ä¹Ÿå‚è€ƒäº†åˆ«äººçš„è§£æ³•ã€‚(æ‰“ç®—ç­‰æ ¹æ®tagåˆ·å®Œåï¼Œå°†æ ‡è®°å‡º[n]çš„é¢˜ç›®ç»™å‡ºä¸€ä»½è¯¦ç»†çš„è§£é¢˜æŒ‡å—)æ€»ä¹‹ä¸‰äººè¡Œï¼Œå¿…æœ‰æˆ‘å¸ˆã€‚å¸Œæœ›ä½ çš„åˆ·é¢˜ä¹‹è·¯é¡ºåˆ©ã€‚ æœ¬äººåˆ·é¢˜ä¸€å¼€å§‹æ˜¯æŒ‰ç…§å®˜æ–¹ä¸ŠTagæ¥åˆ·äº†ï¼Œå› ä¸ºè‡ªå·±çš„ç®—æ³•åŸºç¡€æ¯”è¾ƒè–„å¼±ï¼Œå°±é‡‡å–äº†ç›¸å¯¹æ¯”è¾ƒå®¹æ˜“çš„è·¯å­ã€‚åŒæ—¶æŒ‰ç…§Tagåˆ·ï¼Œæš—ç¤ºäº†é¢˜ç›®å¯èƒ½ä¼šç”¨åˆ°çš„ç®—æ³•å’Œæ•°æ®ç»“æ„ï¼Œæœ¬äººåˆåªé€‰å–äº†ç®€å•å’Œä¸­ç­‰çš„é¢˜ç›®ï¼Œæ‰€ä»¥åˆ·èµ·æ¥ç›¸å¯¹è½»æ¾ä¸€ç‚¹ã€‚ä¸ºäº†æ–¹ä¾¿ï¼Œè¿™é‡Œåˆ—å‡ºäº†ä¸€äº›æœ¬äººè®¤ä¸ºéå¸¸é‡è¦çš„Tag(âœ…è¡¨ç¤ºå·²å®Œæˆ)ï¼š Tagç±»åˆ«å®ŒæˆçŠ¶æ€é˜²è¿·è·¯é“¾æ¥ å¹¿åº¦ä¼˜å…ˆéå†âœ…LeetCodeä¹‹å¹¿åº¦ä¼˜å…ˆéå† åŠ¨æ€è§„åˆ’(ä¸­ç­‰)âœ…LeetCodeä¹‹åŠ¨æ€è§„åˆ’(ä¸­ç­‰) æ•°ç»„(ç®€å•)âœ…LeetCodeä¹‹æ•°ç»„(ç®€å•) æ•°ç»„(ä¸­ç­‰)âœ…LeetCodeä¹‹æ•°ç»„(ä¸­ç­‰) æ•°ç»„(å›°éš¾)âœ…LeetCodeä¹‹æ•°ç»„(å›°éš¾) å­—ç¬¦ä¸²(ç®€å•)âœ…LeetCodeä¹‹å­—ç¬¦ä¸²(ç®€å•) å­—ç¬¦ä¸²(ä¸­ç­‰)âœ…LeetCodeä¹‹å­—ç¬¦ä¸²(ä¸­ç­‰) äºŒå‰æ ‘(ç®€å•)âœ…LeetCodeä¹‹äºŒå‰æ ‘(ç®€å•) äºŒå‰æ ‘(ä¸­ç­‰)âœ…LeetCodeä¹‹äºŒå‰æ ‘(ä¸­ç­‰) é“¾è¡¨âœ…LeetCodeä¹‹é“¾è¡¨ å“ˆå¸Œè¡¨âœ…LeetCodeä¹‹å“ˆå¸Œè¡¨ æ ˆå’Œé˜Ÿåˆ—âœ…LeetCodeä¹‹æ ˆå’Œé˜Ÿåˆ— å † å›¾ äºŒåˆ†æŸ¥æ‰¾ æ·±åº¦ä¼˜å…ˆéå† åŒæŒ‡é’ˆ å›æº¯ å¦‚æœæŒ‰ç…§è¿™äº›Tagæ¥åˆ·ï¼Œå¹¶é€‰æ‹©ç®€å•å’Œä¸­ç­‰çš„é¢˜ç›®ï¼Œå¤§æ¦‚å¯ä»¥åˆ·400-500çš„é¢˜ç›®ï¼ŒåŸºç¡€å’Œç»å…¸çš„é¢˜ç›®åŸºæœ¬éƒ½èƒ½è¦†ç›–åˆ°ï¼Œå¯¹äºé¦–æ¬¡åˆ·é¢˜çš„ä½ è¿˜æ˜¯å¾ˆå‹å¥½çš„ã€‚ å¦ä¸€ç§åˆ·çš„æ–¹å¼å°±æ˜¯æŒ‰ç…§å…¬å¸æ¥åˆ·ï¼Œæ¯”å¦‚ä½ å¿ƒæ„çš„FLAG(Facebook,Linkedin,Amazon,Google)å’ŒMicrosoftã€‚å¯ä»¥å°è¯•ç‰›åˆ€ï¼Œçœ‹ä¸‹å„å®¶é¢è¯•é¢˜çš„é£æ ¼ã€‚è¿™é‡Œç½—åˆ—å‡ ä¸ªæ¯”è¾ƒå‡ºåçš„å…¬å¸ï¼š Google [âœ…] Microsoft [âœ…] Linkedin [âœ…] Facebook [âœ…] Amazon [âœ…] æœ€åçš„æœ€åï¼Œç»™å‡ºæœ¬äººè®¤ä¸ºæ¯”è¾ƒå¥½çš„å‡ ä¸ªäººçš„åˆ·é¢˜é“¾æ¥ï¼Œåœ¨åˆ·é¢˜çš„è¿‡ç¨‹ä¸­å¯ä»¥çœ‹ä¸‹åˆ«äººçš„è§£æ³•ï¼Œå¯¹è‡ªå·±å†™ä»£ç çš„èƒ½åŠ›æå‡ä¼šå¾ˆæœ‰å¸®åŠ©ï¼ŒåºŸè¯ä¸å¤šè®²ï¼Œä¼ é€é—¨å¦‚ä¸‹ï¼š é¦–æ¨èŠ±èŠ±é…±ï¼šhttps://zxi.mytechroad.com/blog/ grandyangçš„åšå®¢ï¼š https://www.cnblogs.com/grandyang/p/4606334.html https://github.com/luliyucoordinate/Leetcode https://github.com/WuLC/LeetCode/tree/master/Algorithm/Python http://bookshadow.com/leetcode/ https://blog.csdn.net/fuxuemingzhu å¦‚æœä½ éœ€è¦çš„è¯ï¼Œå¯ä»¥è”ç³»æˆ‘ï¼ŒæŠŠä½ çš„åˆ·é¢˜é“¾æ¥é™„ä¸Šæ¥ï¼Œæ–¹ä¾¿å¤§å®¶ä½ æˆ‘ä»–ğŸ˜ã€‚","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCodeä¹‹äºŒå‰æ ‘(ä¸­ç­‰)","slug":"LeetCode-äºŒå‰æ ‘-ä¸­ç­‰","date":"2020-12-05T02:29:51.000Z","updated":"2020-12-27T05:05:41.000Z","comments":false,"path":"posts/3ddb3bb0.html","link":"","permalink":"https://leel0330.github.io/posts/3ddb3bb0.html","excerpt":"äºŒå‰æ ‘(ä¸­ç­‰)çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚","text":"äºŒå‰æ ‘(ä¸­ç­‰)çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ 95. ä¸åŒçš„äºŒå‰æœç´¢æ ‘ II [n]ç»™å®šä¸€ä¸ªæ•´æ•° nï¼Œç”Ÿæˆæ‰€æœ‰ç”± 1 â€¦ n ä¸ºèŠ‚ç‚¹æ‰€ç»„æˆçš„äºŒå‰æœç´¢æ ‘ã€‚ ç¤ºä¾‹: è¾“å…¥: 3 è¾“å‡º: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] è§£é‡Š: ä»¥ä¸Šçš„è¾“å‡ºå¯¹åº”ä»¥ä¸‹ 5 ç§ä¸åŒç»“æ„çš„äºŒå‰æœç´¢æ ‘ï¼š 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 12345678910111213141516171819202122232425class Solution(object): def generateTrees(self, n): &quot;&quot;&quot; :type n: int :rtype: List[TreeNode] &quot;&quot;&quot; if n == 0: return [] return self.helper(1, n) def helper(self, start, end): if start &gt; end: return [None] res = [] for i in xrange(start, end + 1): lefts = self.helper(start, i - 1) rights = self.helper(i + 1, end) for left in lefts: for right in rights: node = TreeNode(i) node.left = left node.right = right res.append(node) return res 96. ä¸åŒçš„äºŒå‰æœç´¢æ ‘ [n]ç»™å®šä¸€ä¸ªæ•´æ•° nï¼Œæ±‚ä»¥ 1 â€¦ n ä¸ºèŠ‚ç‚¹ç»„æˆçš„äºŒå‰æœç´¢æ ‘æœ‰å¤šå°‘ç§ï¼Ÿ ç¤ºä¾‹: è¾“å…¥: 3 è¾“å‡º: 5 è§£é‡Š: ç»™å®š n = 3, ä¸€å…±æœ‰ 5 ç§ä¸åŒç»“æ„çš„äºŒå‰æœç´¢æ ‘: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 123456789101112class Solution(object): def numTrees(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; dp = [0 for _ in xrange(n + 1)] dp[0] = dp[1] = 1 for i in xrange(2, n + 1): for j in xrange(0, i): dp[i] += dp[j] * dp[i - 1 - j]#å‡ä¸€æ˜¯å› ä¸ºæ ¹èŠ‚ç‚¹ return dp[n] 105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘æ ¹æ®ä¸€æ£µæ ‘çš„å‰åºéå†ä¸ä¸­åºéå†æ„é€ äºŒå‰æ ‘ã€‚ æ³¨æ„: ä½ å¯ä»¥å‡è®¾æ ‘ä¸­æ²¡æœ‰é‡å¤çš„å…ƒç´ ã€‚ ä¾‹å¦‚ï¼Œç»™å‡º å‰åºéå† preorder = [3,9,20,15,7] ä¸­åºéå† inorder = [9,3,15,20,7] è¿”å›å¦‚ä¸‹çš„äºŒå‰æ ‘ï¼š 3 / \\ 9 20 / \\ 15 7 12345678910111213141516171819202122232425class Solution(object): def buildTree(self, preorder, inorder): &quot;&quot;&quot; :type preorder: List[int] :type inorder: List[int] :rtype: TreeNode &quot;&quot;&quot; m = &#123;&#125; for idx, v in enumerate(inorder): m[v] = idx return self.helper(preorder, 0, len(preorder) - 1, \\ inorder, 0, len(inorder) - 1, m) def helper(self, preorder, pre_s, pre_e, inorder, in_s, in_e, m): if pre_s &gt; pre_e or in_s &gt; in_e: return None root_v = preorder[pre_s] root_idx = m[root_v] left_len = root_idx - in_s root = TreeNode(root_v) root.left = self.helper(preorder, pre_s + 1, pre_s + left_len, \\ inorder, in_s, root_idx - 1, m) root.right = self.helper(preorder, pre_s + left_len + 1, pre_e, \\ inorder, root_idx + 1, in_e, m) return root 106. ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘æ ¹æ®ä¸€æ£µæ ‘çš„ä¸­åºéå†ä¸ååºéå†æ„é€ äºŒå‰æ ‘ã€‚ æ³¨æ„: ä½ å¯ä»¥å‡è®¾æ ‘ä¸­æ²¡æœ‰é‡å¤çš„å…ƒç´ ã€‚ ä¾‹å¦‚ï¼Œç»™å‡º ä¸­åºéå† inorder = [9,3,15,20,7] ååºéå† postorder = [9,15,7,20,3] è¿”å›å¦‚ä¸‹çš„äºŒå‰æ ‘ï¼š 3 / \\ 9 20 / \\ 15 7 12345678910111213141516171819202122232425class Solution(object): def buildTree(self, inorder, postorder): &quot;&quot;&quot; :type inorder: List[int] :type postorder: List[int] :rtype: TreeNode &quot;&quot;&quot; m = &#123;&#125; for idx, v in enumerate(inorder): m[v] = idx return self.helper(inorder, 0, len(inorder) - 1, \\ postorder, 0, len(postorder) - 1, m) def helper(self, inorder, in_left, in_right, postorder, post_left, post_right, m): if in_left &gt; in_right: return None root_val = postorder[post_right] root_idx = m[root_val] left_len = root_idx - in_left root = TreeNode(root_val) root.left = self.helper(inorder, in_left, root_idx - 1, \\ postorder, post_left, post_left + left_len - 1, m) root.right = self.helper(inorder, root_idx + 1, in_right, \\ postorder, post_left + left_len, post_right - 1, m) return root 114. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼ŒåŸåœ°å°†å®ƒå±•å¼€ä¸ºé“¾è¡¨ã€‚ ä¾‹å¦‚ï¼Œç»™å®šäºŒå‰æ ‘ 1 / \\ 2 5 / \\ \\ 3 4 6 å°†å…¶å±•å¼€ä¸ºï¼š 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 12345678910111213141516171819202122232425class Solution(object): def flatten(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: None Do not return anything, modify root in-place instead. &quot;&quot;&quot; items = self.pre_order(root) for i in xrange(len(items) - 1): items[i].left = None items[i].right = items[i + 1] return root def pre_order(self, root): # å‰åºéå† items = [] p = root stk = [] while p or stk: while p: items.append(p) stk.append(p) p = p.left node = stk.pop(-1) p = node.right return items 117. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ IIç»™å®šä¸€ä¸ªäºŒå‰æ ‘ struct Node { int val; Node *left; Node *right; Node *next; } å¡«å……å®ƒçš„æ¯ä¸ª next æŒ‡é’ˆï¼Œè®©è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘å…¶ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ã€‚å¦‚æœæ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ï¼Œåˆ™å°† next æŒ‡é’ˆè®¾ç½®ä¸º NULLã€‚ åˆå§‹çŠ¶æ€ä¸‹ï¼Œæ‰€æœ‰ next æŒ‡é’ˆéƒ½è¢«è®¾ç½®ä¸º NULLã€‚ 12345678910111213141516171819202122class Solution(object): def connect(self, root): &quot;&quot;&quot; :type root: Node :rtype: Node &quot;&quot;&quot; if root is None: return root queue = [root] while queue: sz = len(queue) prev = None for i in xrange(sz): node = queue.pop(0) if prev: prev.next = node prev = node if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root 236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ [n]ç»™å®šä¸€ä¸ªäºŒå‰æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚ ç™¾åº¦ç™¾ç§‘ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªç»“ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªç»“ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€ ç¤ºä¾‹ 1: è¾“å…¥: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 è¾“å‡º: 3 è§£é‡Š: èŠ‚ç‚¹ 5 å’ŒèŠ‚ç‚¹ 1 çš„æœ€è¿‘å…¬å…±ç¥–å…ˆæ˜¯èŠ‚ç‚¹ 3ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 è¾“å‡º: 5 è§£é‡Š: èŠ‚ç‚¹ 5 å’ŒèŠ‚ç‚¹ 4 çš„æœ€è¿‘å…¬å…±ç¥–å…ˆæ˜¯èŠ‚ç‚¹ 5ã€‚å› ä¸ºæ ¹æ®å®šä¹‰æœ€è¿‘å…¬å…±ç¥–å…ˆèŠ‚ç‚¹å¯ä»¥ä¸ºèŠ‚ç‚¹æœ¬èº«ã€‚ è¯´æ˜: æ‰€æœ‰èŠ‚ç‚¹çš„å€¼éƒ½æ˜¯å”¯ä¸€çš„ã€‚ pã€q ä¸ºä¸åŒèŠ‚ç‚¹ä¸”å‡å­˜åœ¨äºç»™å®šçš„äºŒå‰æ ‘ä¸­ã€‚ 123456789101112131415class Solution(object): def lowestCommonAncestor(self, root, p, q): &quot;&quot;&quot; :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode &quot;&quot;&quot; if root is None or root == p or root == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if left and right: return root return left if left else right 331. éªŒè¯äºŒå‰æ ‘çš„å‰åºåºåˆ—åŒ– [n]åºåˆ—åŒ–äºŒå‰æ ‘çš„ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨å‰åºéå†ã€‚å½“æˆ‘ä»¬é‡åˆ°ä¸€ä¸ªéç©ºèŠ‚ç‚¹æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥è®°å½•ä¸‹è¿™ä¸ªèŠ‚ç‚¹çš„å€¼ã€‚å¦‚æœå®ƒæ˜¯ä¸€ä¸ªç©ºèŠ‚ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ ‡è®°å€¼è®°å½•ï¼Œä¾‹å¦‚ #ã€‚ _9_ / \\ 3 2 / \\ / \\ 4 1 # 6 / \\ / \\ / \\ # # # # # # ä¾‹å¦‚ï¼Œä¸Šé¢çš„äºŒå‰æ ‘å¯ä»¥è¢«åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸² â€œ9,3,4,#,#,1,#,#,2,#,6,#,#â€ï¼Œå…¶ä¸­ # ä»£è¡¨ä¸€ä¸ªç©ºèŠ‚ç‚¹ã€‚ ç»™å®šä¸€ä¸²ä»¥é€—å·åˆ†éš”çš„åºåˆ—ï¼ŒéªŒè¯å®ƒæ˜¯å¦æ˜¯æ­£ç¡®çš„äºŒå‰æ ‘çš„å‰åºåºåˆ—åŒ–ã€‚ç¼–å†™ä¸€ä¸ªåœ¨ä¸é‡æ„æ ‘çš„æ¡ä»¶ä¸‹çš„å¯è¡Œç®—æ³•ã€‚ æ¯ä¸ªä»¥é€—å·åˆ†éš”çš„å­—ç¬¦æˆ–ä¸ºä¸€ä¸ªæ•´æ•°æˆ–ä¸ºä¸€ä¸ªè¡¨ç¤º null æŒ‡é’ˆçš„ â€˜#â€™ ã€‚ ä½ å¯ä»¥è®¤ä¸ºè¾“å…¥æ ¼å¼æ€»æ˜¯æœ‰æ•ˆçš„ï¼Œä¾‹å¦‚å®ƒæ°¸è¿œä¸ä¼šåŒ…å«ä¸¤ä¸ªè¿ç»­çš„é€—å·ï¼Œæ¯”å¦‚ â€œ1,,3â€ ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: \"9,3,4,#,#,1,#,#,2,#,6,#,#\" è¾“å‡º: true ç¤ºä¾‹ 2: è¾“å…¥: \"1,#\" è¾“å‡º: false ç¤ºä¾‹ 3: è¾“å…¥: \"9,#,#,1\" è¾“å‡º: false 12345678910111213class Solution(object): def isValidSerialization(self, preorder): &quot;&quot;&quot; :type preorder: str :rtype: bool &quot;&quot;&quot; stk = [] for c in preorder.split(&#x27;,&#x27;): stk.append(c) while len(stk) &gt;= 3 and stk[-2:] == [&#x27;#&#x27;, &#x27;#&#x27;] and stk[-3] != &#x27;#&#x27;: stk = stk[:-3] stk.append(&#x27;#&#x27;) return stk == [&#x27;#&#x27;] 337. æ‰“å®¶åŠ«èˆ III [n]åœ¨ä¸Šæ¬¡æ‰“åŠ«å®Œä¸€æ¡è¡—é“ä¹‹åå’Œä¸€åœˆæˆ¿å±‹åï¼Œå°å·åˆå‘ç°äº†ä¸€ä¸ªæ–°çš„å¯è¡Œçªƒçš„åœ°åŒºã€‚è¿™ä¸ªåœ°åŒºåªæœ‰ä¸€ä¸ªå…¥å£ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºâ€œæ ¹â€ã€‚ é™¤äº†â€œæ ¹â€ä¹‹å¤–ï¼Œæ¯æ ‹æˆ¿å­æœ‰ä¸”åªæœ‰ä¸€ä¸ªâ€œçˆ¶â€œæˆ¿å­ä¸ä¹‹ç›¸è¿ã€‚ä¸€ç•ªä¾¦å¯Ÿä¹‹åï¼Œèªæ˜çš„å°å·æ„è¯†åˆ°â€œè¿™ä¸ªåœ°æ–¹çš„æ‰€æœ‰æˆ¿å±‹çš„æ’åˆ—ç±»ä¼¼äºä¸€æ£µäºŒå‰æ ‘â€ã€‚ å¦‚æœä¸¤ä¸ªç›´æ¥ç›¸è¿çš„æˆ¿å­åœ¨åŒä¸€å¤©æ™šä¸Šè¢«æ‰“åŠ«ï¼Œæˆ¿å±‹å°†è‡ªåŠ¨æŠ¥è­¦ã€‚ è®¡ç®—åœ¨ä¸è§¦åŠ¨è­¦æŠ¥çš„æƒ…å†µä¸‹ï¼Œå°å·ä¸€æ™šèƒ½å¤Ÿç›—å–çš„æœ€é«˜é‡‘é¢ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [3,2,3,null,3,null,1] 3 / \\ 2 3 \\ \\ 3 1 è¾“å‡º: 7 è§£é‡Š: å°å·ä¸€æ™šèƒ½å¤Ÿç›—å–çš„æœ€é«˜é‡‘é¢ = 3 + 3 + 1 = 7. ç¤ºä¾‹ 2: è¾“å…¥: [3,4,5,1,3,null,1] 3 / \\ 4 5 / \\ \\ 1 3 1 è¾“å‡º: 9 è§£é‡Š: å°å·ä¸€æ™šèƒ½å¤Ÿç›—å–çš„æœ€é«˜é‡‘é¢ = 4 + 5 = 9. 123456789101112131415161718192021222324class Solution(object): def rob(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; if root is None: return 0 m = &#123;&#125; return self.helper(root, m) def helper(self, root, m): if root is None: return 0 if root in m: return m[root] val = root.val if root.left: val += self.helper(root.left.left, m) + self.helper(root.left.right, m) if root.right: val += self.helper(root.right.left, m) + self.helper(root.right.right, m) res = max(val, self.helper(root.left, m) + self.helper(root.right, m)) m[root] = res return res 437. è·¯å¾„æ€»å’Œ IIIç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œå®ƒçš„æ¯ä¸ªç»“ç‚¹éƒ½å­˜æ”¾ç€ä¸€ä¸ªæ•´æ•°å€¼ã€‚ æ‰¾å‡ºè·¯å¾„å’Œç­‰äºç»™å®šæ•°å€¼çš„è·¯å¾„æ€»æ•°ã€‚ è·¯å¾„ä¸éœ€è¦ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œä¹Ÿä¸éœ€è¦åœ¨å¶å­èŠ‚ç‚¹ç»“æŸï¼Œä½†æ˜¯è·¯å¾„æ–¹å‘å¿…é¡»æ˜¯å‘ä¸‹çš„ï¼ˆåªèƒ½ä»çˆ¶èŠ‚ç‚¹åˆ°å­èŠ‚ç‚¹ï¼‰ã€‚ äºŒå‰æ ‘ä¸è¶…è¿‡1000ä¸ªèŠ‚ç‚¹ï¼Œä¸”èŠ‚ç‚¹æ•°å€¼èŒƒå›´æ˜¯ [-1000000,1000000] çš„æ•´æ•°ã€‚ ç¤ºä¾‹ï¼š root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\ 3 -2 1 è¿”å› 3ã€‚å’Œç­‰äº 8 çš„è·¯å¾„æœ‰: 1. 5 -> 3 2. 5 -> 2 -> 1 3. -3 -> 11 123456789101112131415161718192021222324252627class Solution(object): def pathSum(self, root, target): &quot;&quot;&quot; :type root: TreeNode :type target: int :rtype: int &quot;&quot;&quot; if root is None: return 0 self.res = 0 queue = [root] while queue: node = queue.pop(0) self.dfs(node, target) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return self.res def dfs(self, root, target): if root is None: return if root.val == target: self.res += 1 self.dfs(root.left, target - root.val) self.dfs(root.right, target - root.val) 449. åºåˆ—åŒ–å’Œååºåˆ—åŒ–äºŒå‰æœç´¢æ ‘12345678910111213141516171819202122232425262728293031323334353637383940class Codec: def serialize(self, root): &quot;&quot;&quot;Encodes a tree to a single string. :type root: TreeNode :rtype: str &quot;&quot;&quot; stk, p = [], root res = [] while stk or p: while p: res.append(p.val) stk.append(p) p = p.left node = stk.pop(-1) p = node.right return &#x27; &#x27;.join(map(str, res)) def deserialize(self, data): &quot;&quot;&quot;Decodes your encoded data to tree. :type data: str :rtype: TreeNode &quot;&quot;&quot; preorder = map(int, data.split()) inorder = sorted(preorder) return self.build_tree(preorder, inorder) def build_tree(self, preorder, inorder): if not preorder: return None root_v = preorder[0] idx = inorder.index(root_v) root = TreeNode(root_v) root.left = self.build_tree(preorder[1:1+idx], inorder[:idx]) root.right =self.build_tree(preorder[1+idx:], inorder[idx+1:]) return root 450. åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹ [n]ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ root å’Œä¸€ä¸ªå€¼ keyï¼Œåˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„ key å¯¹åº”çš„èŠ‚ç‚¹ï¼Œå¹¶ä¿è¯äºŒå‰æœç´¢æ ‘çš„æ€§è´¨ä¸å˜ã€‚è¿”å›äºŒå‰æœç´¢æ ‘ï¼ˆæœ‰å¯èƒ½è¢«æ›´æ–°ï¼‰çš„æ ¹èŠ‚ç‚¹çš„å¼•ç”¨ã€‚ ä¸€èˆ¬æ¥è¯´ï¼Œåˆ é™¤èŠ‚ç‚¹å¯åˆ†ä¸ºä¸¤ä¸ªæ­¥éª¤ï¼š é¦–å…ˆæ‰¾åˆ°éœ€è¦åˆ é™¤çš„èŠ‚ç‚¹ï¼›å¦‚æœæ‰¾åˆ°äº†ï¼Œåˆ é™¤å®ƒã€‚è¯´æ˜ï¼š è¦æ±‚ç®—æ³•æ—¶é—´å¤æ‚åº¦ä¸º O(h)ï¼Œh ä¸ºæ ‘çš„é«˜åº¦ã€‚ ç¤ºä¾‹: root = [5,3,6,2,4,null,7] key = 3 5 / \\ 3 6 / \\ \\ 2 4 7 ç»™å®šéœ€è¦åˆ é™¤çš„èŠ‚ç‚¹å€¼æ˜¯ 3ï¼Œæ‰€ä»¥æˆ‘ä»¬é¦–å…ˆæ‰¾åˆ° 3 è¿™ä¸ªèŠ‚ç‚¹ï¼Œç„¶ååˆ é™¤å®ƒã€‚ ä¸€ä¸ªæ­£ç¡®çš„ç­”æ¡ˆæ˜¯ [5,4,6,2,null,null,7], å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ 5 / \\ 4 6 / \\ 2 7 å¦ä¸€ä¸ªæ­£ç¡®ç­”æ¡ˆæ˜¯ [5,2,6,null,4,null,7]ã€‚ 5 / \\ 2 6 \\ \\ 4 7 12345678910111213141516171819202122232425262728class Solution(object): def deleteNode(self, root, key): &quot;&quot;&quot; :type root: TreeNode :type key: int :rtype: TreeNode &quot;&quot;&quot; if root is None: return root if key &lt; root.val: root.left = self.deleteNode(root.left, key) elif key &gt; root.val: root.right = self.deleteNode(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left else: node = self.findMin(root.right) root.val = node.val root.right = self.deleteNode(root.right, node.val) return root def findMin(self, node): while node.left: node = node.left return node 508. å‡ºç°æ¬¡æ•°æœ€å¤šçš„å­æ ‘å…ƒç´ å’Œç»™å‡ºäºŒå‰æ ‘çš„æ ¹ï¼Œæ‰¾å‡ºå‡ºç°æ¬¡æ•°æœ€å¤šçš„å­æ ‘å…ƒç´ å’Œã€‚ä¸€ä¸ªç»“ç‚¹çš„å­æ ‘å…ƒç´ å’Œå®šä¹‰ä¸ºä»¥è¯¥ç»“ç‚¹ä¸ºæ ¹çš„äºŒå‰æ ‘ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å…ƒç´ ä¹‹å’Œï¼ˆåŒ…æ‹¬ç»“ç‚¹æœ¬èº«ï¼‰ã€‚ç„¶åæ±‚å‡ºå‡ºç°æ¬¡æ•°æœ€å¤šçš„å­æ ‘å…ƒç´ å’Œã€‚å¦‚æœæœ‰å¤šä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°ç›¸åŒï¼Œè¿”å›æ‰€æœ‰å‡ºç°æ¬¡æ•°æœ€å¤šçš„å…ƒç´ ï¼ˆä¸é™é¡ºåºï¼‰ã€‚ ç¤ºä¾‹ 1 è¾“å…¥: 5 / \\ 2 -3 è¿”å› [2, -3, 4]ï¼Œæ‰€æœ‰çš„å€¼å‡åªå‡ºç°ä¸€æ¬¡ï¼Œä»¥ä»»æ„é¡ºåºè¿”å›æ‰€æœ‰å€¼ã€‚ ç¤ºä¾‹ 2 è¾“å…¥: 5 / \\ 2 -5 è¿”å› [2]ï¼Œåªæœ‰ 2 å‡ºç°ä¸¤æ¬¡ï¼Œ-5 åªå‡ºç° 1 æ¬¡ã€‚ 123456789101112131415161718192021222324252627class Solution(object): def findFrequentTreeSum(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[int] &quot;&quot;&quot; self.m = &#123;&#125; self.res = [] self.cnt = 0 self.helper(root) for k, v in self.m.iteritems(): if v == self.cnt: self.res.append(k) return self.res def helper(self, root): if root is None: return 0 left = self.helper(root.left) right = self.helper(root.right) cur_sum = left + right + root.val if cur_sum in self.m: self.m[cur_sum] += 1 else: self.m[cur_sum] = 1 self.cnt = max(self.cnt, self.m[cur_sum]) return cur_sum 538. æŠŠäºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºç´¯åŠ æ ‘ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘ï¼ˆBinary Search Treeï¼‰ï¼ŒæŠŠå®ƒè½¬æ¢æˆä¸ºç´¯åŠ æ ‘ï¼ˆGreater Tree)ï¼Œä½¿å¾—æ¯ä¸ªèŠ‚ç‚¹çš„å€¼æ˜¯åŸæ¥çš„èŠ‚ç‚¹å€¼åŠ ä¸Šæ‰€æœ‰å¤§äºå®ƒçš„èŠ‚ç‚¹å€¼ä¹‹å’Œã€‚ ä¾‹å¦‚ï¼š è¾“å…¥: äºŒå‰æœç´¢æ ‘: 5 / \\ 2 13 è¾“å‡º: è½¬æ¢ä¸ºç´¯åŠ æ ‘: 18 / \\ 20 13 12345678910111213141516171819class Solution(object): def convertBST(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; p = root stk = [] prev = 0 while p or stk: while p: stk.append(p) p = p.right node = stk.pop(-1) old_v = node.val node.val += prev prev += old_v p = node.left return root 623. åœ¨äºŒå‰æ ‘ä¸­å¢åŠ ä¸€è¡Œç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ ¹èŠ‚ç‚¹ä¸ºç¬¬1å±‚ï¼Œæ·±åº¦ä¸º 1ã€‚åœ¨å…¶ç¬¬ d å±‚è¿½åŠ ä¸€è¡Œå€¼ä¸º v çš„èŠ‚ç‚¹ã€‚ æ·»åŠ è§„åˆ™ï¼šç»™å®šä¸€ä¸ªæ·±åº¦å€¼ d ï¼ˆæ­£æ•´æ•°ï¼‰ï¼Œé’ˆå¯¹æ·±åº¦ä¸º d-1 å±‚çš„æ¯ä¸€éç©ºèŠ‚ç‚¹ Nï¼Œä¸º N åˆ›å»ºä¸¤ä¸ªå€¼ä¸º v çš„å·¦å­æ ‘å’Œå³å­æ ‘ã€‚ å°† N åŸå…ˆçš„å·¦å­æ ‘ï¼Œè¿æ¥ä¸ºæ–°èŠ‚ç‚¹ v çš„å·¦å­æ ‘ï¼›å°† N åŸå…ˆçš„å³å­æ ‘ï¼Œè¿æ¥ä¸ºæ–°èŠ‚ç‚¹ v çš„å³å­æ ‘ã€‚ å¦‚æœ d çš„å€¼ä¸º 1ï¼Œæ·±åº¦ d - 1 ä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„æ ¹èŠ‚ç‚¹ vï¼ŒåŸå…ˆçš„æ•´æ£µæ ‘å°†ä½œä¸º v çš„å·¦å­æ ‘ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: äºŒå‰æ ‘å¦‚ä¸‹æ‰€ç¤º: 4 / \\ 2 6 / \\ / 3 1 5 v = 1 d = 2 è¾“å‡º: 4 / \\ 1 1 / \\ 2 6 / \\ / 3 1 5 ç¤ºä¾‹ 2: è¾“å…¥: äºŒå‰æ ‘å¦‚ä¸‹æ‰€ç¤º: 4 / 2 / \\ 3 1 v = 1 d = 3 è¾“å‡º: 4 / 2 / \\ 1 1 / \\ 3 1 æ³¨æ„: è¾“å…¥çš„æ·±åº¦å€¼ d çš„èŒƒå›´æ˜¯ï¼š[1ï¼ŒäºŒå‰æ ‘æœ€å¤§æ·±åº¦ + 1]ã€‚ è¾“å…¥çš„äºŒå‰æ ‘è‡³å°‘æœ‰ä¸€ä¸ªèŠ‚ç‚¹ã€‚ 1234567891011121314151617181920212223242526272829303132class Solution(object): def addOneRow(self, root, v, d): &quot;&quot;&quot; :type root: TreeNode :type v: int :type d: int :rtype: TreeNode &quot;&quot;&quot; if d == 1: new_root = TreeNode(v) new_root.left = root return new_root queue = [root] for _ in xrange(d - 2): sz = len(queue) for _ in xrange(sz): node = queue.pop(0) if node.left: queue.append(node.left) if node.right: queue.append(node.right) while queue: node = queue.pop(0) tmp = node.left new_node = TreeNode(v) new_node.left = tmp node.left = new_node tmp = node.right new_node = TreeNode(v) new_node.right = tmp node.right = new_node return root 652. å¯»æ‰¾é‡å¤çš„å­æ ‘ [n]ç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œè¿”å›æ‰€æœ‰é‡å¤çš„å­æ ‘ã€‚å¯¹äºåŒä¸€ç±»çš„é‡å¤å­æ ‘ï¼Œä½ åªéœ€è¦è¿”å›å…¶ä¸­ä»»æ„ä¸€æ£µçš„æ ¹ç»“ç‚¹å³å¯ã€‚ ä¸¤æ£µæ ‘é‡å¤æ˜¯æŒ‡å®ƒä»¬å…·æœ‰ç›¸åŒçš„ç»“æ„ä»¥åŠç›¸åŒçš„ç»“ç‚¹å€¼ã€‚ ç¤ºä¾‹ 1ï¼š 1 / \\ 2 3 / / \\ 4 2 4 / 4 ä¸‹é¢æ˜¯ä¸¤ä¸ªé‡å¤çš„å­æ ‘ï¼š 2 / 4 å’Œ 4 å› æ­¤ï¼Œä½ éœ€è¦ä»¥åˆ—è¡¨çš„å½¢å¼è¿”å›ä¸Šè¿°é‡å¤å­æ ‘çš„æ ¹ç»“ç‚¹ã€‚ 1234567891011121314151617181920212223class Solution(object): def findDuplicateSubtrees(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[TreeNode] &quot;&quot;&quot; m, res = &#123;&#125;, [] self.helper(root, m) for k, v in m.iteritems(): if len(v) &gt; 1: res.append(v[0]) return res def helper(self, root, m): if root is None: return &quot;&quot; s = &quot;(&quot; + self.helper(root.left, m) + str(root.val) + \\ self.helper(root.right, m) + &quot;)&quot; if s in m: m[s].append(root) else: m[s] = [root] return s 654. æœ€å¤§äºŒå‰æ ‘ç»™å®šä¸€ä¸ªä¸å«é‡å¤å…ƒç´ çš„æ•´æ•°æ•°ç»„ã€‚ä¸€ä¸ªä»¥æ­¤æ•°ç»„æ„å»ºçš„æœ€å¤§äºŒå‰æ ‘å®šä¹‰å¦‚ä¸‹ï¼š äºŒå‰æ ‘çš„æ ¹æ˜¯æ•°ç»„ä¸­çš„æœ€å¤§å…ƒç´ ã€‚ å·¦å­æ ‘æ˜¯é€šè¿‡æ•°ç»„ä¸­æœ€å¤§å€¼å·¦è¾¹éƒ¨åˆ†æ„é€ å‡ºçš„æœ€å¤§äºŒå‰æ ‘ã€‚ å³å­æ ‘æ˜¯é€šè¿‡æ•°ç»„ä¸­æœ€å¤§å€¼å³è¾¹éƒ¨åˆ†æ„é€ å‡ºçš„æœ€å¤§äºŒå‰æ ‘ã€‚ é€šè¿‡ç»™å®šçš„æ•°ç»„æ„å»ºæœ€å¤§äºŒå‰æ ‘ï¼Œå¹¶ä¸”è¾“å‡ºè¿™ä¸ªæ ‘çš„æ ¹èŠ‚ç‚¹ã€‚ ç¤ºä¾‹ ï¼š è¾“å…¥ï¼š[3,2,1,6,0,5] è¾“å‡ºï¼šè¿”å›ä¸‹é¢è¿™æ£µæ ‘çš„æ ¹èŠ‚ç‚¹ï¼š 6 / \\ 3 5 \\ / 2 0 \\ 1 æç¤ºï¼š ç»™å®šçš„æ•°ç»„çš„å¤§å°åœ¨ [1, 1000] ä¹‹é—´ã€‚ 1234567891011121314151617181920class Solution(object): def constructMaximumBinaryTree(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: TreeNode &quot;&quot;&quot; m = &#123;&#125; for idx, v in enumerate(nums): m[v] = idx return self.helper(nums, 0, len(nums) - 1, m) def helper(self, nums, left, right, m): if left &gt; right: return None max_v = max(nums[left: right + 1]) max_idx = m[max_v] root = TreeNode(max_v) root.left = self.helper(nums, left, max_idx - 1, m) root.right = self.helper(nums, max_idx + 1, right, m) return root 655. è¾“å‡ºäºŒå‰æ ‘ [n]åœ¨ä¸€ä¸ª m*n çš„äºŒç»´å­—ç¬¦ä¸²æ•°ç»„ä¸­è¾“å‡ºäºŒå‰æ ‘ï¼Œå¹¶éµå®ˆä»¥ä¸‹è§„åˆ™ï¼š è¡Œæ•° m åº”å½“ç­‰äºç»™å®šäºŒå‰æ ‘çš„é«˜åº¦ã€‚ åˆ—æ•° n åº”å½“æ€»æ˜¯å¥‡æ•°ã€‚ æ ¹èŠ‚ç‚¹çš„å€¼ï¼ˆä»¥å­—ç¬¦ä¸²æ ¼å¼ç»™å‡ºï¼‰åº”å½“æ”¾åœ¨å¯æ”¾ç½®çš„ç¬¬ä¸€è¡Œæ­£ä¸­é—´ã€‚æ ¹èŠ‚ç‚¹æ‰€åœ¨çš„è¡Œä¸åˆ—ä¼šå°†å‰©ä½™ç©ºé—´åˆ’åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼ˆå·¦ä¸‹éƒ¨åˆ†å’Œå³ä¸‹éƒ¨åˆ†ï¼‰ã€‚ä½ åº”è¯¥å°†å·¦å­æ ‘è¾“å‡ºåœ¨å·¦ä¸‹éƒ¨åˆ†ï¼Œå³å­æ ‘è¾“å‡ºåœ¨å³ä¸‹éƒ¨åˆ†ã€‚å·¦ä¸‹å’Œå³ä¸‹éƒ¨åˆ†åº”å½“æœ‰ç›¸åŒçš„å¤§å°ã€‚å³ä½¿ä¸€ä¸ªå­æ ‘ä¸ºç©ºè€Œå¦ä¸€ä¸ªéç©ºï¼Œä½ ä¸éœ€è¦ä¸ºç©ºçš„å­æ ‘è¾“å‡ºä»»ä½•ä¸œè¥¿ï¼Œä½†ä»éœ€è¦ä¸ºå¦ä¸€ä¸ªå­æ ‘ç•™å‡ºè¶³å¤Ÿçš„ç©ºé—´ã€‚ç„¶è€Œï¼Œå¦‚æœä¸¤ä¸ªå­æ ‘éƒ½ä¸ºç©ºåˆ™ä¸éœ€è¦ä¸ºå®ƒä»¬ç•™å‡ºä»»ä½•ç©ºé—´ã€‚ æ¯ä¸ªæœªä½¿ç”¨çš„ç©ºé—´åº”åŒ…å«ä¸€ä¸ªç©ºçš„å­—ç¬¦ä¸²â€â€ã€‚ ä½¿ç”¨ç›¸åŒçš„è§„åˆ™è¾“å‡ºå­æ ‘ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: 1 / 2 è¾“å‡º: [[\"\", \"1\", \"\"], [\"2\", \"\", \"\"]] ç¤ºä¾‹ 2: è¾“å…¥: 1 / \\ 2 3 \\ 4 è¾“å‡º: [[\"\", \"\", \"\", \"1\", \"\", \"\", \"\"], [\"\", \"2\", \"\", \"\", \"\", \"3\", \"\"], [\"\", \"\", \"4\", \"\", \"\", \"\", \"\"]] ç¤ºä¾‹ 3: è¾“å…¥: 1 / \\ 2 5 / 3 / 4 è¾“å‡º: [[\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"1\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"] [\"\", \"\", \"\", \"2\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"5\", \"\", \"\", \"\"] [\"\", \"3\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"] [\"4\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]] æ³¨æ„: äºŒå‰æ ‘çš„é«˜åº¦åœ¨èŒƒå›´ [1, 10] ä¸­ã€‚ 1234567891011121314151617181920212223242526class Solution(object): def printTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[List[str]] &quot;&quot;&quot; if root is None: return [] height = self.getHeight(root) width = (1 &lt;&lt; height) - 1 res = [[&quot;&quot;] * width for _ in xrange(height)] self.helper(root, 0, width - 1, 0, height, res) return res def helper(self, root, left, right, h, height, res): if root is None or h == height: return mid = (left + right) / 2 res[h][mid] = str(root.val) self.helper(root.left, left, mid - 1, h + 1, height, res) self.helper(root.right, mid + 1, right, h + 1, height, res) def getHeight(self, root): if root is None: return 0 return max(self.getHeight(root.left), self.getHeight(root.right)) + 1 687. æœ€é•¿åŒå€¼è·¯å¾„ [n]ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾åˆ°æœ€é•¿çš„è·¯å¾„ï¼Œè¿™ä¸ªè·¯å¾„ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹å…·æœ‰ç›¸åŒå€¼ã€‚ è¿™æ¡è·¯å¾„å¯ä»¥ç»è¿‡ä¹Ÿå¯ä»¥ä¸ç»è¿‡æ ¹èŠ‚ç‚¹ã€‚ æ³¨æ„ï¼šä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„è·¯å¾„é•¿åº¦ç”±å®ƒä»¬ä¹‹é—´çš„è¾¹æ•°è¡¨ç¤ºã€‚ ç¤ºä¾‹ 1: è¾“å…¥: 5 / \\ 4 5 / \\ \\ 1 1 5 è¾“å‡º: 2 ç¤ºä¾‹ 2: è¾“å…¥: 1 / \\ 4 5 / \\ \\ 4 4 5 è¾“å‡º: 2 æ³¨æ„: ç»™å®šçš„äºŒå‰æ ‘ä¸è¶…è¿‡10000ä¸ªç»“ç‚¹ã€‚ æ ‘çš„é«˜åº¦ä¸è¶…è¿‡1000ã€‚ 12345678910111213141516171819202122class Solution(object): def longestUnivaluePath(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; self.res = 0 self.helper(root) return self.res def helper(self, root): if root is None: return 0 left = self.helper(root.left) right = self.helper(root.right) pl, pr = 0, 0 if root.left and root.left.val == root.val: pl = left + 1 if root.right and root.right.val == root.val: pr = right + 1 self.res = max(self.res, pl + pr) return max(pl, pr) 701. äºŒå‰æœç´¢æ ‘ä¸­çš„æ’å…¥æ“ä½œç»™å®šäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„æ ¹èŠ‚ç‚¹å’Œè¦æ’å…¥æ ‘ä¸­çš„å€¼ï¼Œå°†å€¼æ’å…¥äºŒå‰æœç´¢æ ‘ã€‚ è¿”å›æ’å…¥åäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚ ä¿è¯åŸå§‹äºŒå‰æœç´¢æ ‘ä¸­ä¸å­˜åœ¨æ–°å€¼ã€‚ æ³¨æ„ï¼Œå¯èƒ½å­˜åœ¨å¤šç§æœ‰æ•ˆçš„æ’å…¥æ–¹å¼ï¼Œåªè¦æ ‘åœ¨æ’å…¥åä»ä¿æŒä¸ºäºŒå‰æœç´¢æ ‘å³å¯ã€‚ ä½ å¯ä»¥è¿”å›ä»»æ„æœ‰æ•ˆçš„ç»“æœã€‚ ä¾‹å¦‚, ç»™å®šäºŒå‰æœç´¢æ ‘: 4 / \\ 2 7 / \\ 1 3 å’Œ æ’å…¥çš„å€¼: 5 ä½ å¯ä»¥è¿”å›è¿™ä¸ªäºŒå‰æœç´¢æ ‘: 4 / \\ 2 7 / \\ / 1 3 5 æˆ–è€…è¿™ä¸ªæ ‘ä¹Ÿæ˜¯æœ‰æ•ˆçš„: 5 / \\ 2 7 / \\ 1 3 \\ 4 1234567891011121314class Solution(object): def insertIntoBST(self, root, val): &quot;&quot;&quot; :type root: TreeNode :type val: int :rtype: TreeNode &quot;&quot;&quot; if root is None: return TreeNode(val) if root.val &gt; val: root.left = self.insertIntoBST(root.left, val) else: root.right = self.insertIntoBST(root.right, val) return root 814. äºŒå‰æ ‘å‰ªæ [n]ç»™å®šäºŒå‰æ ‘æ ¹ç»“ç‚¹ root ï¼Œæ­¤å¤–æ ‘çš„æ¯ä¸ªç»“ç‚¹çš„å€¼è¦ä¹ˆæ˜¯ 0ï¼Œè¦ä¹ˆæ˜¯ 1ã€‚ è¿”å›ç§»é™¤äº†æ‰€æœ‰ä¸åŒ…å« 1 çš„å­æ ‘çš„åŸäºŒå‰æ ‘ã€‚ ( èŠ‚ç‚¹ X çš„å­æ ‘ä¸º X æœ¬èº«ï¼Œä»¥åŠæ‰€æœ‰ X çš„åä»£ã€‚) ç¤ºä¾‹1: è¾“å…¥: [1,null,0,0,1] è¾“å‡º: [1,null,0,null,1] è§£é‡Š: åªæœ‰çº¢è‰²èŠ‚ç‚¹æ»¡è¶³æ¡ä»¶â€œæ‰€æœ‰ä¸åŒ…å« 1 çš„å­æ ‘â€ã€‚ å³å›¾ä¸ºè¿”å›çš„ç­”æ¡ˆã€‚ ç¤ºä¾‹2: è¾“å…¥: [1,0,1,0,0,0,1] è¾“å‡º: [1,null,1,null,1] ç¤ºä¾‹3: è¾“å…¥: [1,1,0,1,1,0,1,0] è¾“å‡º: [1,1,0,1,1,null,1] è¯´æ˜: ç»™å®šçš„äºŒå‰æ ‘æœ€å¤šæœ‰ 100 ä¸ªèŠ‚ç‚¹ã€‚ æ¯ä¸ªèŠ‚ç‚¹çš„å€¼åªä¼šä¸º 0 æˆ– 1 ã€‚ 12345678910111213class Solution(object): def pruneTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; if root is None: return None root.left = self.pruneTree(root.left) root.right = self.pruneTree(root.right) if root.left is None and root.right is None and root.val == 0: return None return root 863. äºŒå‰æ ‘ä¸­æ‰€æœ‰è·ç¦»ä¸º K çš„ç»“ç‚¹ [n]ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼ˆå…·æœ‰æ ¹ç»“ç‚¹ rootï¼‰ï¼Œ ä¸€ä¸ªç›®æ ‡ç»“ç‚¹ target ï¼Œå’Œä¸€ä¸ªæ•´æ•°å€¼ K ã€‚ è¿”å›åˆ°ç›®æ ‡ç»“ç‚¹ target è·ç¦»ä¸º K çš„æ‰€æœ‰ç»“ç‚¹çš„å€¼çš„åˆ—è¡¨ã€‚ ç­”æ¡ˆå¯ä»¥ä»¥ä»»ä½•é¡ºåºè¿”å›ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šroot = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2 è¾“å‡ºï¼š[7,4,1] è§£é‡Šï¼š æ‰€æ±‚ç»“ç‚¹ä¸ºä¸ç›®æ ‡ç»“ç‚¹ï¼ˆå€¼ä¸º 5ï¼‰è·ç¦»ä¸º 2 çš„ç»“ç‚¹ï¼Œ å€¼åˆ†åˆ«ä¸º 7ï¼Œ4ï¼Œä»¥åŠ 1 æç¤ºï¼š ç»™å®šçš„æ ‘æ˜¯éç©ºçš„ï¼Œä¸”æœ€å¤šæœ‰ K ä¸ªç»“ç‚¹ã€‚ æ ‘ä¸Šçš„æ¯ä¸ªç»“ç‚¹éƒ½å…·æœ‰å”¯ä¸€çš„å€¼ 0 &lt;= node.val &lt;= 500 ã€‚ ç›®æ ‡ç»“ç‚¹ target æ˜¯æ ‘ä¸Šçš„ç»“ç‚¹ã€‚ 0 &lt;= K &lt;= 1000. 123456789101112131415161718192021222324252627282930313233class Solution(object): def distanceK(self, root, target, K): &quot;&quot;&quot; :type root: TreeNode :type target: TreeNode :type K: int :rtype: List[int] &quot;&quot;&quot; m = collections.defaultdict(list) self.helper(None, root, m) queue = [target.val] visited = set([target.val]) for _ in xrange(K): sz = len(queue) for _ in xrange(sz): v = queue.pop(0) for i in m[v]: if i not in visited: visited.add(i) queue.append(i) return queue def helper(self, parent, child, m): if parent and child: m[child.val].append(parent.val) m[parent.val].append(child.val) if child.left: self.helper(child, child.left, m) if child.right: self.helper(child, child.right, m) 865. å…·æœ‰æ‰€æœ‰æœ€æ·±ç»“ç‚¹çš„æœ€å°å­æ ‘ [n]ç»™å®šä¸€ä¸ªæ ¹ä¸º root çš„äºŒå‰æ ‘ï¼Œæ¯ä¸ªç»“ç‚¹çš„æ·±åº¦æ˜¯å®ƒåˆ°æ ¹çš„æœ€çŸ­è·ç¦»ã€‚ å¦‚æœä¸€ä¸ªç»“ç‚¹åœ¨æ•´ä¸ªæ ‘çš„ä»»æ„ç»“ç‚¹ä¹‹é—´å…·æœ‰æœ€å¤§çš„æ·±åº¦ï¼Œåˆ™è¯¥ç»“ç‚¹æ˜¯æœ€æ·±çš„ã€‚ ä¸€ä¸ªç»“ç‚¹çš„å­æ ‘æ˜¯è¯¥ç»“ç‚¹åŠ ä¸Šå®ƒçš„æ‰€æœ‰åä»£çš„é›†åˆã€‚ è¿”å›èƒ½æ»¡è¶³â€œä»¥è¯¥ç»“ç‚¹ä¸ºæ ¹çš„å­æ ‘ä¸­åŒ…å«æ‰€æœ‰æœ€æ·±çš„ç»“ç‚¹â€è¿™ä¸€æ¡ä»¶çš„å…·æœ‰æœ€å¤§æ·±åº¦çš„ç»“ç‚¹ã€‚ ç¤ºä¾‹ï¼š è¾“å…¥ï¼š[3,5,1,6,2,0,8,null,null,7,4] è¾“å‡ºï¼š[2,7,4] è§£é‡Šï¼š æˆ‘ä»¬è¿”å›å€¼ä¸º 2 çš„ç»“ç‚¹ï¼Œåœ¨å›¾ä¸­ç”¨é»„è‰²æ ‡è®°ã€‚ åœ¨å›¾ä¸­ç”¨è“è‰²æ ‡è®°çš„æ˜¯æ ‘çš„æœ€æ·±çš„ç»“ç‚¹ã€‚ è¾“å…¥ \"[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]\" æ˜¯å¯¹ç»™å®šçš„æ ‘çš„åºåˆ—åŒ–è¡¨è¿°ã€‚ è¾“å‡º \"[2, 7, 4]\" æ˜¯å¯¹æ ¹ç»“ç‚¹çš„å€¼ä¸º 2 çš„å­æ ‘çš„åºåˆ—åŒ–è¡¨è¿°ã€‚ è¾“å…¥å’Œè¾“å‡ºéƒ½å…·æœ‰ TreeNode ç±»å‹ã€‚ æç¤ºï¼š æ ‘ä¸­ç»“ç‚¹çš„æ•°é‡ä»‹äº 1 å’Œ 500 ä¹‹é—´ã€‚ æ¯ä¸ªç»“ç‚¹çš„å€¼éƒ½æ˜¯ç‹¬ä¸€æ— äºŒçš„ã€‚ 12345678910111213141516171819class Solution(object): def subtreeWithAllDeepest(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; depth, res = self.helper(root) return res def helper(self, root): if root is None: return (0, None) left_pair = self.helper(root.left) right_pair = self.helper(root.right) dl, dr = left_pair[0], right_pair[0] root_depth = max(dl, dr) + 1 if dl == dr: return (root_depth, root) return (root_depth, left_pair[1]) if dl &gt; dr else (root_depth, right_pair[1]) 894. æ‰€æœ‰å¯èƒ½çš„æ»¡äºŒå‰æ ‘ [n]æ»¡äºŒå‰æ ‘æ˜¯ä¸€ç±»äºŒå‰æ ‘ï¼Œå…¶ä¸­æ¯ä¸ªç»“ç‚¹æ°å¥½æœ‰ 0 æˆ– 2 ä¸ªå­ç»“ç‚¹ã€‚ è¿”å›åŒ…å« N ä¸ªç»“ç‚¹çš„æ‰€æœ‰å¯èƒ½æ»¡äºŒå‰æ ‘çš„åˆ—è¡¨ã€‚ ç­”æ¡ˆçš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå¯èƒ½æ ‘çš„æ ¹ç»“ç‚¹ã€‚ ç­”æ¡ˆä¸­æ¯ä¸ªæ ‘çš„æ¯ä¸ªç»“ç‚¹éƒ½å¿…é¡»æœ‰ node.val=0ã€‚ ä½ å¯ä»¥æŒ‰ä»»ä½•é¡ºåºè¿”å›æ ‘çš„æœ€ç»ˆåˆ—è¡¨ã€‚ ç¤ºä¾‹ï¼š è¾“å…¥ï¼š7 è¾“å‡ºï¼š [[0,0,0,null,null,0,0,null,null,0,0], [0,0,0,null,null,0,0,0,0], [0,0,0,0,0,0,0], [0,0,0,0,0,null,null,null,null,0,0], [0,0,0,0,0,null,null,0,0]] 123456789101112131415161718192021class Solution(object): def allPossibleFBT(self, N): &quot;&quot;&quot; :type N: int :rtype: List[TreeNode] &quot;&quot;&quot; if N % 2 == 0: return [] if N == 1: return [TreeNode(0)] res = [] for i in xrange(1, N, 2): lefts = self.allPossibleFBT(i) rights = self.allPossibleFBT(N - 1 - i) for left in lefts: for right in rights: root = TreeNode(0) root.left = left root.right = right res.append(root) return res 951. ç¿»è½¬ç­‰ä»·äºŒå‰æ ‘ [n]æˆ‘ä»¬å¯ä»¥ä¸ºäºŒå‰æ ‘ T å®šä¹‰ä¸€ä¸ªç¿»è½¬æ“ä½œï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼šé€‰æ‹©ä»»æ„èŠ‚ç‚¹ï¼Œç„¶åäº¤æ¢å®ƒçš„å·¦å­æ ‘å’Œå³å­æ ‘ã€‚ åªè¦ç»è¿‡ä¸€å®šæ¬¡æ•°çš„ç¿»è½¬æ“ä½œåï¼Œèƒ½ä½¿ X ç­‰äº Yï¼Œæˆ‘ä»¬å°±ç§°äºŒå‰æ ‘ X ç¿»è½¬ç­‰ä»·äºäºŒå‰æ ‘ Yã€‚ ç¼–å†™ä¸€ä¸ªåˆ¤æ–­ä¸¤ä¸ªäºŒå‰æ ‘æ˜¯å¦æ˜¯ç¿»è½¬ç­‰ä»·çš„å‡½æ•°ã€‚è¿™äº›æ ‘ç”±æ ¹èŠ‚ç‚¹ root1 å’Œ root2 ç»™å‡ºã€‚ ç¤ºä¾‹ï¼š è¾“å…¥ï¼šroot1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7] è¾“å‡ºï¼štrue è§£é‡Šï¼šWe flipped at nodes with values 1, 3, and 5. æç¤ºï¼š æ¯æ£µæ ‘æœ€å¤šæœ‰ 100 ä¸ªèŠ‚ç‚¹ã€‚ æ¯æ£µæ ‘ä¸­çš„æ¯ä¸ªå€¼éƒ½æ˜¯å”¯ä¸€çš„ã€åœ¨ [0, 99] èŒƒå›´å†…çš„æ•´æ•°ã€‚ 12345678910111213141516class Solution(object): def flipEquiv(self, root1, root2): &quot;&quot;&quot; :type root1: TreeNode :type root2: TreeNode :rtype: bool &quot;&quot;&quot; if root1 == root2: return True if root1 is None or root2 is None or root1.val != root2.val: return False a = self.flipEquiv(root1.left, root2.left) and \\ self.flipEquiv(root1.right, root2.right) b = self.flipEquiv(root1.left, root2.right) and \\ self.flipEquiv(root1.right, root2.left) return a or b 958. äºŒå‰æ ‘çš„å®Œå…¨æ€§æ£€éªŒç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œç¡®å®šå®ƒæ˜¯å¦æ˜¯ä¸€ä¸ªå®Œå…¨äºŒå‰æ ‘ã€‚ ç™¾åº¦ç™¾ç§‘ä¸­å¯¹å®Œå…¨äºŒå‰æ ‘çš„å®šä¹‰å¦‚ä¸‹ï¼š è‹¥è®¾äºŒå‰æ ‘çš„æ·±åº¦ä¸º hï¼Œé™¤ç¬¬ h å±‚å¤–ï¼Œå…¶å®ƒå„å±‚ (1ï½h-1) çš„ç»“ç‚¹æ•°éƒ½è¾¾åˆ°æœ€å¤§ä¸ªæ•°ï¼Œç¬¬ h å±‚æ‰€æœ‰çš„ç»“ç‚¹éƒ½è¿ç»­é›†ä¸­åœ¨æœ€å·¦è¾¹ï¼Œè¿™å°±æ˜¯å®Œå…¨äºŒå‰æ ‘ã€‚ï¼ˆæ³¨ï¼šç¬¬ h å±‚å¯èƒ½åŒ…å« 1~ 2h ä¸ªèŠ‚ç‚¹ã€‚ï¼‰ 1234567891011121314151617181920class Solution(object): def isCompleteTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; if root is None: return True queue = [root] flag = False while queue: node = queue.pop(0) if node: if flag: return False queue.append(node.left) queue.append(node.right) else: flag = True return True 971. ç¿»è½¬äºŒå‰æ ‘ä»¥åŒ¹é…å…ˆåºéå† [n]ç»™å®šä¸€ä¸ªæœ‰ N ä¸ªèŠ‚ç‚¹çš„äºŒå‰æ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªä¸åŒäºå…¶ä»–èŠ‚ç‚¹ä¸”å¤„äº {1, â€¦, N} ä¸­çš„å€¼ã€‚ é€šè¿‡äº¤æ¢èŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹å’Œå³å­èŠ‚ç‚¹ï¼Œå¯ä»¥ç¿»è½¬è¯¥äºŒå‰æ ‘ä¸­çš„èŠ‚ç‚¹ã€‚ è€ƒè™‘ä»æ ¹èŠ‚ç‚¹å¼€å§‹çš„å…ˆåºéå†æŠ¥å‘Šçš„ N å€¼åºåˆ—ã€‚å°†è¿™ä¸€ N å€¼åºåˆ—ç§°ä¸ºæ ‘çš„è¡Œç¨‹ã€‚ ï¼ˆå›æƒ³ä¸€ä¸‹ï¼ŒèŠ‚ç‚¹çš„å…ˆåºéå†æ„å‘³ç€æˆ‘ä»¬æŠ¥å‘Šå½“å‰èŠ‚ç‚¹çš„å€¼ï¼Œç„¶åå…ˆåºéå†å·¦å­èŠ‚ç‚¹ï¼Œå†å…ˆåºéå†å³å­èŠ‚ç‚¹ã€‚ï¼‰ æˆ‘ä»¬çš„ç›®æ ‡æ˜¯ç¿»è½¬æœ€å°‘çš„æ ‘ä¸­èŠ‚ç‚¹ï¼Œä»¥ä¾¿æ ‘çš„è¡Œç¨‹ä¸ç»™å®šçš„è¡Œç¨‹ voyage ç›¸åŒ¹é…ã€‚ å¦‚æœå¯ä»¥ï¼Œåˆ™è¿”å›ç¿»è½¬çš„æ‰€æœ‰èŠ‚ç‚¹çš„å€¼çš„åˆ—è¡¨ã€‚ä½ å¯ä»¥æŒ‰ä»»ä½•é¡ºåºè¿”å›ç­”æ¡ˆã€‚ å¦‚æœä¸èƒ½ï¼Œåˆ™è¿”å›åˆ—è¡¨ [-1]ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šroot = [1,2], voyage = [2,1] è¾“å‡ºï¼š[-1] ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šroot = [1,2,3], voyage = [1,3,2] è¾“å‡ºï¼š[1] ç¤ºä¾‹ 3ï¼š è¾“å…¥ï¼šroot = [1,2,3], voyage = [1,2,3] è¾“å‡ºï¼š[] æç¤ºï¼š 1 &lt;= N &lt;= 100 12345678910111213141516171819202122232425class Solution(object): def flipMatchVoyage(self, root, voyage): &quot;&quot;&quot; :type root: TreeNode :type voyage: List[int] :rtype: List[int] &quot;&quot;&quot; self.pos, self.res = 0, [] self.dfs(root, voyage) print(self.res) return self.res def dfs(self, root, voyage): if root is None: return if root.val != voyage[self.pos]: self.res = [-1] return self.res if root.left and root.left.val != voyage[self.pos + 1]: root.left, root.right = root.right, root.left self.res.append(root.val) self.pos += 1 self.dfs(root.left, voyage) self.dfs(root.right, voyage) 979. åœ¨äºŒå‰æ ‘ä¸­åˆ†é…ç¡¬å¸ [n]ç»™å®šä¸€ä¸ªæœ‰ N ä¸ªç»“ç‚¹çš„äºŒå‰æ ‘çš„æ ¹ç»“ç‚¹ rootï¼Œæ ‘ä¸­çš„æ¯ä¸ªç»“ç‚¹ä¸Šéƒ½å¯¹åº”æœ‰ node.val æšç¡¬å¸ï¼Œå¹¶ä¸”æ€»å…±æœ‰ N æšç¡¬å¸ã€‚ åœ¨ä¸€æ¬¡ç§»åŠ¨ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©ä¸¤ä¸ªç›¸é‚»çš„ç»“ç‚¹ï¼Œç„¶åå°†ä¸€æšç¡¬å¸ä»å…¶ä¸­ä¸€ä¸ªç»“ç‚¹ç§»åŠ¨åˆ°å¦ä¸€ä¸ªç»“ç‚¹ã€‚(ç§»åŠ¨å¯ä»¥æ˜¯ä»çˆ¶ç»“ç‚¹åˆ°å­ç»“ç‚¹ï¼Œæˆ–è€…ä»å­ç»“ç‚¹ç§»åŠ¨åˆ°çˆ¶ç»“ç‚¹ã€‚)ã€‚ è¿”å›ä½¿æ¯ä¸ªç»“ç‚¹ä¸Šåªæœ‰ä¸€æšç¡¬å¸æ‰€éœ€çš„ç§»åŠ¨æ¬¡æ•°ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼š[3,0,0] è¾“å‡ºï¼š2 è§£é‡Šï¼šä»æ ‘çš„æ ¹ç»“ç‚¹å¼€å§‹ï¼Œæˆ‘ä»¬å°†ä¸€æšç¡¬å¸ç§»åˆ°å®ƒçš„å·¦å­ç»“ç‚¹ä¸Šï¼Œä¸€æšç¡¬å¸ç§»åˆ°å®ƒçš„å³å­ç»“ç‚¹ä¸Šã€‚ ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼š[0,3,0] è¾“å‡ºï¼š3 è§£é‡Šï¼šä»æ ¹ç»“ç‚¹çš„å·¦å­ç»“ç‚¹å¼€å§‹ï¼Œæˆ‘ä»¬å°†ä¸¤æšç¡¬å¸ç§»åˆ°æ ¹ç»“ç‚¹ä¸Š [ç§»åŠ¨ä¸¤æ¬¡]ã€‚ç„¶åï¼Œæˆ‘ä»¬æŠŠä¸€æšç¡¬å¸ä»æ ¹ç»“ç‚¹ç§»åˆ°å³å­ç»“ç‚¹ä¸Šã€‚ ç¤ºä¾‹ 3ï¼š è¾“å…¥ï¼š[1,0,2] è¾“å‡ºï¼š2 ç¤ºä¾‹ 4ï¼š è¾“å…¥ï¼š[1,0,0,null,3] è¾“å‡ºï¼š4 æç¤ºï¼š 1&lt;= N &lt;= 100 0 &lt;= node.val &lt;= N 1234567891011121314151617class Solution(object): def distributeCoins(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; self.res = 0 self.helper(root) return self.res def helper(self, root): if root is None: return 0 left = self.helper(root.left) right = self.helper(root.right) self.res += abs(left) + abs(right) return root.val - 1 + left + right","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"é‚£äº›æˆ‘è®¤ä¸ºä¸é”™çš„è®¡ç®—æœºä¸“ä¸šä¹¦(ä»…é¢å‘åå°å¼€å‘)","slug":"è®¡ç®—æœºä¸“ä¸šå›¾ä¹¦æ¨è","date":"2020-12-04T13:40:04.000Z","updated":"2021-03-14T14:05:30.063Z","comments":false,"path":"posts/4f424561.html","link":"","permalink":"https://leel0330.github.io/posts/4f424561.html","excerpt":"å¦‚æœä½ æ˜¯ç¨‹åºå‘˜æ–°äººï¼Œé‚£ä¹ˆè¿™ç¯‡æ–‡ç« å¯¹ä½ å¾ˆæœ‰ç”¨ï¼Œèƒ½è®©ä½ å°‘èµ°ä¸€äº›å¼¯è·¯ï¼Œå¤šçœ‹ä¸€äº›ç»å…¸ä¹¦ç±ï¼Œæ‰“ä¸‹æ‰å®çš„è®¡ç®—æœºåŸºç¡€ã€‚ å¦‚æœä½ æ˜¯èŒåœºè€é¸Ÿï¼Œé‚£ä¹ˆè¿™ç¯‡æ–‡ç« å¯èƒ½é€‚åˆé€‰è¯»ã€‚æœ‰äº›ä¹¦è¿˜æ˜¯ä¸é”™çš„ï¼Œå€¼å¾—å¤šè¯»å‡ éã€‚ å‹æƒ…æç¤ºï¼šç‚¹å‡»å›¾ä¹¦å¯ä»¥è·³è½¬åˆ°è±†ç“£ï¼ŒæŸ¥çœ‹ç›¸åº”å›¾ä¹¦çš„ç›®å½•å†…å®¹å’Œç”¨æˆ·è¯„ä»·ã€‚","text":"å¦‚æœä½ æ˜¯ç¨‹åºå‘˜æ–°äººï¼Œé‚£ä¹ˆè¿™ç¯‡æ–‡ç« å¯¹ä½ å¾ˆæœ‰ç”¨ï¼Œèƒ½è®©ä½ å°‘èµ°ä¸€äº›å¼¯è·¯ï¼Œå¤šçœ‹ä¸€äº›ç»å…¸ä¹¦ç±ï¼Œæ‰“ä¸‹æ‰å®çš„è®¡ç®—æœºåŸºç¡€ã€‚ å¦‚æœä½ æ˜¯èŒåœºè€é¸Ÿï¼Œé‚£ä¹ˆè¿™ç¯‡æ–‡ç« å¯èƒ½é€‚åˆé€‰è¯»ã€‚æœ‰äº›ä¹¦è¿˜æ˜¯ä¸é”™çš„ï¼Œå€¼å¾—å¤šè¯»å‡ éã€‚ å‹æƒ…æç¤ºï¼šç‚¹å‡»å›¾ä¹¦å¯ä»¥è·³è½¬åˆ°è±†ç“£ï¼ŒæŸ¥çœ‹ç›¸åº”å›¾ä¹¦çš„ç›®å½•å†…å®¹å’Œç”¨æˆ·è¯„ä»·ã€‚ å‰è¨€ï¼Œé‚£äº›æˆ‘æƒ³å¯¹ä½ è¯´çš„è¯ä½œä¸ºä¸€åç¨‹åºå‘˜ï¼ŒçŒ¿é¾„æœ‰å››äº”å¹´äº†ã€‚æ–­æ–­ç»­ç»­çœ‹äº†ä¸å°‘ä¸“ä¸šä¹¦ï¼Œæœ‰äº›ä¹¦è¿˜æ˜¯è®©æˆ‘æˆé•¿äº†ä¸å°‘çš„ï¼Œæ‰€ä»¥å®‰è€ä¸ä½å†…å¿ƒçš„å†²åŠ¨ï¼Œéå¸¸æƒ³åˆ†äº«ä¸€æ³¢ï¼Œæ­£å¥½å€Ÿæœ¬äººçš„åšå®¢ä¸å¤§å®¶äº¤æµä¸€ä¸‹â˜ºï¸ã€‚ å¯ä»¥è¿™ä¹ˆè¯´ï¼Œæ¯ä¸ªåˆ†ç±»éƒ½æ˜¯æœ¬äººç²¾å¿ƒæŒ‘é€‰è¿‡çš„ï¼Œæœ¬äººä¹Ÿæœ‰çœ‹è¿‡æ‰ä¼šæ¨èã€‚ä¸è¿‡ä¸€åƒä¸ªè¯»è€…çœ¼é‡Œæœ‰ä¸€åƒä¸ªå“ˆå§†é›·ç‰¹ï¼Œæ¯ä¸ªäººçš„ç»å†å’Œè®¤çŸ¥å·®å¼‚æ¯”è¾ƒå¤§ï¼Œå¾ˆéš¾æ»¡è¶³æ¯ä¸ªäººçš„å£å‘³ã€‚æ‰€ä»¥è¿™é‡Œåªæ˜¯æŒ‘é€‰å‡ºæ¯ä¸ªåˆ†ç±»ä¸‹ä¸ªäººè®¤ä¸ºä¸é”™çš„top3ã€‚ å†æ¬¡æç¤ºï¼šç‚¹å‡»å›¾ä¹¦å¯ä»¥è·³è½¬åˆ°è±†ç“£ï¼ŒæŸ¥çœ‹ç›¸åº”å›¾ä¹¦çš„ç›®å½•å†…å®¹å’Œç”¨æˆ·è¯„ä»·å“¦~ æ…¢ç€ï¼Œçœ‹XXè¯­è¨€ä¹‹å‰ä½ å¯èƒ½éœ€è¦å…ˆçœ‹è¿™é‡Œï¼Œå˜¿å˜¿æˆ‘æƒ³ä½ çš„è„‘å­é‡Œè‚¯å®šè¹¦å‡ºæ¥ä¸€å¥è¯:â€ä½ ç»™æˆ‘æ¨èè¿™ä¹ˆå¤šè¯­è¨€çš„ä¹¦çœ‹è™¾ç±³ï¼Œæˆ‘çœ‹ä¸è¿‡æ¥å•Š!â€œã€‚æ˜¯çš„ï¼Œä½ çœ‹ä¸è¿‡æ¥çš„ï¼Œæˆ‘ä¹Ÿçœ‹ä¸è¿‡æ¥ï¼Œä½†æ˜¯æˆ‘ä¸ºäº†æ¨èçš„å®Œæ•´æ€§ï¼Œå°±éƒ½ç½—åˆ—å‡ºæ¥äº†ã€‚ ä¸ç’ä½ è¯´ï¼Œä½ éœ€è¦ä»ä¸Šè¿°åŸºæœ¬è¯­è¨€æŒ‘å‡ºä½ è‡ªå·±å–œæ¬¢çš„ä¸»åŠ›è¯­è¨€å’Œè¾…åŠ©è¯­è¨€äº†ï¼Œå› ä¸ºä¸åŒè¯­è¨€å¯ä»¥æ»¡è¶³ä¸åŒçš„éœ€æ±‚ï¼Œæœ‰å®ƒè‡ªèº«çš„ä¸€äº›ç‰¹ç‚¹ã€‚é€‰æ‹©çš„è¯ä½ å¯ä»¥è€ƒè™‘ä»¥ä¸‹å‡ ç‚¹: ä¸ä¼šå°±é€‰Cã€‚æ‰€ä»¥è¯´å®ƒæ˜¯å¿…ä¿®è¯¾!(æ˜¯çš„ï¼Œä½ æ²¡çœ‹é”™å°±æ˜¯Cè¯­è¨€ï¼ä½ æ²¡å¾—é€‰ï¼Œå› ä¸ºè®¡ç®—æœºè½¯ä»¶ä¸“ä¸šè¯¾ï¼Œç¬¬ä¸€é—¨è¦å­¦çš„è¯­è¨€å°±æ˜¯å®ƒï¼è¿™é‡Œå¼ºè°ƒä¸€ç‚¹ï¼ŒLinuxæ“ä½œç³»ç»Ÿå°±æ˜¯Cè¯­è¨€å®ç°çš„å“¦ï¼) è¿™é—¨è¯­è¨€å¥½å­¦å—ï¼Ÿæˆ‘ç°åœ¨å¾ˆæƒ³å¿«ç‚¹ä¸Šæ‰‹å†™ä¸€äº›ä»£ç å‘¢ï¼Ÿï¼(è¿™æ¡æˆ‘æ¨Pythonï¼Œåªæ­¤ä¸€å®¶ï¼Œåˆ«æ— åˆ†åº—) ç®€å•çš„æˆ‘ä¸æƒ³å­¦ï¼Œæˆ‘æƒ³å…ˆå­¦æœ‰éš¾åº¦çš„ï¼Œå› ä¸ºéš¾å¾—ä¸œè¥¿å¥½å“ˆå“ˆï¼(è¿™æ¡ä¸è¯´äº†ï¼Œå¤§å®¶éƒ½æ˜ç™½ï¼Œé€‰C++å§ï¼Œä½ ä¼šçˆ±ä¸Šå®ƒçš„o(ï¿£ï¸¶ï¿£)o) æˆ‘åªæƒ³å­¦ä¸€é—¨è¯­è¨€ï¼Œè€Œä¸”æˆ‘æƒ³åœ¨è¿™é—¨è¯­è¨€æ·±è€•ã€‚(å—¯ä¸é”™ï¼Œä¸“ä¸€æŒºå¥½çš„ï¼Œé‚£æˆ‘æ¨èC++æˆ–è€…Java) æˆ‘å·²ç»ä¼šäº†Cï¼Œä¹Ÿå­¦äº†ä¸€é—¨é¢å‘å¯¹è±¡çš„è¯­è¨€(C++æˆ–è€…Java)ï¼Œæˆ‘æƒ³æ‰©å±•ä¸€ä¸‹ï¼Œé‚£å¯ä»¥å­¦ä¸‹Goçœ‹çœ‹ã€‚ æ—¶é—´æ˜¯æœ‰é™çš„ï¼Œä½ ä¸å¯èƒ½ä¸Šæ¥å°±ä»€ä¹ˆéƒ½å­¦ï¼Œé‚£æ ·çš„è¯ä½ ä»€ä¹ˆéƒ½æ²¡æœ‰å­¦ä¼šï¼Œè¿˜æœ‰å¯èƒ½å› ä¸ºå­¦å¤ªå¤šè€Œèµ°ç«å…¥é­”ã€‚æ—©ç‚¹åšé€‰æ‹©ä¹Ÿæ²¡æœ‰åå¤„ï¼Œéœ€è¦åšé€‰æ‹©çš„æ—¶å€™å°±è¦æœæ–­ç‚¹ã€‚å½“ç„¶ä½ å¯ä»¥å…ˆå¤§æ¦‚äº†è§£ä¸€ä¸‹æ¯ä¸€é—¨è¯­è¨€ç„¶åå†æ·±å…¥å­¦ä½ å–œæ¬¢çš„ï¼Œè¿™æ ·ä¹Ÿæ²¡é—®é¢˜çš„ã€‚ åºŸè¯å°‘è¯´ï¼Œå¿«å¼€å§‹ä½ çš„è¡¨æ¼”å§~ï¼Œé‚£æˆ‘å°±å¼€å§‹å’¯ï¼Œshow time! Cè¯­è¨€ C++è¯­è¨€å› ä¸ºC++å¾ˆéš¾ï¼Œæ‰€ä»¥è¿™é‡Œå¤šæ¨èä¸€äº›ä¹¦ï¼Œå“ˆå“ˆï¼Œå¯èƒ½è¿™é‡Œå°±åŠé€€äº†ä¸€æ³¢äººå•¦ï¼ŒåšæŒä¸‹æ¥çš„äººåŠ æ²¹å“¦ï¼é«˜ç²¾å°–æŠ€æœ¯ç­‰ç€ä½ å¼€å‘å‘¢ğŸ˜€~ Javaè¯­è¨€è€å®è¯´ï¼ŒJavaè¦æ¨èçš„ä¹¦ä¹Ÿä¸å°‘ã€‚ Pythonè¯­è¨€Pythonç‰ˆæœ¬æœ‰2å’Œ3ä¹‹åˆ†ï¼Œ2çš„è¯å®˜æ–¹å¥½åƒå·²ç»åœæ­¢ç»´æŠ¤äº†ï¼Œæ‰€ä»¥æ¨èç›´æ¥å­¦Python3å§ã€‚ Goè¯­è¨€ æ•°æ®ç»“æ„å’Œç®—æ³• æ“ä½œç³»ç»Ÿè¿™å‡ æœ¬æ“ä½œç³»ç»Ÿä¹¦å†…å®¹æ¯”è¾ƒå…¨é¢ï¼Œå¯¹æœ¬ç§‘ç”Ÿæ¥è¯´æ·±åº¦ä¹Ÿå¯ä»¥ã€‚éœ€è¦é‡ç‚¹å…³æ³¨çš„ç« èŠ‚æ˜¯è¿›ç¨‹ã€å†…å­˜å’ŒIOã€‚ è®¡ç®—æœºç½‘ç»œç°åœ¨çš„åº”ç”¨ç¨‹åºå¯ä»¥è¯´éƒ½ç¦»ä¸å¼€ç½‘ç»œï¼Œæ— è®ºä»€ä¹ˆå®¢æˆ·ç«¯ï¼Œéƒ½éœ€è¦å’Œserverè¿›è¡Œäº¤äº’å»æ‹¿ç›¸åº”çš„æ•°æ®ã€‚å› æ­¤æŒæ¡è®¡ç®—æœºç½‘ç»œç›¸å…³çŸ¥è¯†å°±æ˜¾å¾—å°¤ä¸ºé‡è¦ã€‚ å¯¹ä¸ã€ŠTCP/IPè¯¦è§£ å·1ï¼šåè®®ã€‹å’Œã€Šè®¡ç®—æœºç½‘ç»œã€‹è¿™ä¸¤æœ¬ä¹¦ï¼Œéœ€è¦é‡ç‚¹å…³æ³¨çš„æ˜¯è¿è¾“å±‚å’Œåº”ç”¨å±‚ã€‚ä¹Ÿå°±æ˜¯TCP/UDPå’ŒHTTPè¿™å‡ ä¸ªåè®®ã€‚æ¯•ç«Ÿå’Œç¨‹åºå‘˜æ‰“äº¤é“æœ€å¤šçš„å°±æ˜¯è¿™ä¸¤å±‚äº†ã€‚å¸Œæœ›åŒå­¦èƒ½è®¤çœŸè¯»å®Œå¹¶æŒæ¡å“¦~ å¯¹äºã€ŠUNIXç½‘ç»œç¼–ç¨‹ å·1ã€‹ã€‚æœ€éœ€è¦æŒæ¡çš„æ˜¯C/Sç¼–ç¨‹èŒƒå¼(ä¸»è¦æ˜¯tcpçš„socketç¼–ç¨‹ï¼ŒåŒ…æ‹¬å¤šè¿›ç¨‹ã€å¤šçº¿ç¨‹å’ŒI/Oå¤ç”¨)ã€‚ Linuxç¼–ç¨‹ åè®°ï¼Œæ—¢ç„¶çœ‹åˆ°è¿™é‡Œäº†ï¼Œå†å¬æˆ‘å” å¨å‡ å¥åˆä½•å¦¨(æ‰‹åŠ¨ç‹—å¤´)å¦‚æœä½ è®¤çœŸçœ‹å®Œäº†ä¸Šé¢æ‰€åˆ—çš„ä¹¦ç±ï¼Œé™¤äº†è¿æ°”æˆåˆ†å¤–ï¼Œé¢å¤§å‚ä½ çš„åŸºç¡€åº”è¯¥æ˜¯å¾ˆæ‰å®äº†ï¼Œä½†æ˜¯æœ‰å¥è¯è¿˜æ˜¯è¦è®²ä¸€ä¸‹å°±æ˜¯â€çº¸ä¸Šå¾—æ¥ç»ˆè§‰æµ…ï¼Œç»çŸ¥æ­¤äº‹è¦èº¬è¡Œâ€ï¼Œè¿™å¥è¯å¯¹çœ‹è¿™ç¯‡æ–‡ç« çš„äººè®²ï¼Œä¹Ÿæ˜¯å¯¹æˆ‘è‡ªå·±è®²ã€‚å®è·µæ˜¯1ï¼Œçœ‹ä¹¦æ˜¯0ï¼Œæœ‰äº†å®è·µå†çœ‹ä¹¦ç›¸å½“äºå¾€1åé¢æ·»åŠ 0ï¼Œå¦‚æœä¸å®è·µçœ‹å†å¤šçš„ä¹¦ä¹Ÿæ˜¯0ã€‚å¸Œæœ›å’Œå¤§å®¶ä¸€èµ·å…±å‹‰æŠŠï¼","categories":[{"name":"Book","slug":"Book","permalink":"https://leel0330.github.io/categories/Book/"}],"tags":[]},{"title":"LeetCodeä¹‹äºŒå‰æ ‘(ç®€å•)","slug":"LeetCode-äºŒå‰æ ‘-ç®€å•","date":"2020-12-03T13:26:41.000Z","updated":"2020-12-27T05:05:55.775Z","comments":false,"path":"posts/94def828.html","link":"","permalink":"https://leel0330.github.io/posts/94def828.html","excerpt":"äºŒå‰æ ‘(ç®€å•)çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚","text":"äºŒå‰æ ‘(ç®€å•)çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ 101. å¯¹ç§°äºŒå‰æ ‘ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦æ˜¯é•œåƒå¯¹ç§°çš„ã€‚ ä¾‹å¦‚ï¼ŒäºŒå‰æ ‘ [1,2,2,3,4,4,3] æ˜¯å¯¹ç§°çš„ã€‚ 1 / \\ 2 2 / \\ / \\ 3 4 4 3 ä½†æ˜¯ä¸‹é¢è¿™ä¸ª [1,2,2,null,3,null,3] åˆ™ä¸æ˜¯é•œåƒå¯¹ç§°çš„: 1 / \\ 2 2 \\ \\ 3 3 Python(BFS)Python(é€’å½’)1234567891011121314151617181920212223class Solution(object): def isSymmetric(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; if root is None: return True queue = [root, root] while queue: t1 = queue.pop(0) t2 = queue.pop(0) if t1 is None and t2 is None: continue if t1 is None or t2 is None: return False if t1.val != t2.val: return False queue.append(t1.left) queue.append(t2.right) queue.append(t1.right) queue.append(t2.left) return True123456789101112131415class Solution(object): def isSymmetric(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; return self.isMirror(root, root) def isMirror(self, p, q): if p is None and q is None: return True if p is None or q is None: return False return p.val == q.val and self.isMirror(p.left, q.right) \\ and self.isMirror(p.right, q.left) 110. å¹³è¡¡äºŒå‰æ ‘ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåˆ¤æ–­å®ƒæ˜¯å¦æ˜¯é«˜åº¦å¹³è¡¡çš„äºŒå‰æ ‘ã€‚ æœ¬é¢˜ä¸­ï¼Œä¸€æ£µé«˜åº¦å¹³è¡¡äºŒå‰æ ‘å®šä¹‰ä¸ºï¼š ä¸€ä¸ªäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹ çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡1ã€‚ ç¤ºä¾‹ 1: ç»™å®šäºŒå‰æ ‘ [3,9,20,null,null,15,7] 3 / \\ 9 20 / \\ 15 7 è¿”å› true ã€‚ ç¤ºä¾‹ 2: ç»™å®šäºŒå‰æ ‘ [1,2,2,3,3,null,null,4,4] 1 / \\ 2 2 / \\ 3 3 / \\ 4 4 è¿”å› false ã€‚ 1234567891011121314151617181920class Solution(object): def isBalanced(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; return self.helper(root) != -1 def helper(self, root): if root is None: return 0 left_height = self.helper(root.left) if left_height == -1: return -1 right_height = self.helper(root.right) if right_height == -1: return -1 if abs(left_height - right_height) &gt; 1: return -1 return 1 + max(left_height, right_height) 111. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å°æ·±åº¦ã€‚ æœ€å°æ·±åº¦æ˜¯ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿‘å¶å­èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°é‡ã€‚ è¯´æ˜: å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚ ç¤ºä¾‹: ç»™å®šäºŒå‰æ ‘ [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 è¿”å›å®ƒçš„æœ€å°æ·±åº¦ 2. 123456789101112131415161718192021class Solution(object): def minDepth(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; if not root: return 0 queue = [root] level = 0 while queue: n = len(queue) level += 1 for i in xrange(n): node = queue.pop(0) if node.left is None and node.right is None: return level if node.left: queue.append(node.left) if node.right: queue.append(node.right) 226. ç¿»è½¬äºŒå‰æ ‘ç¿»è½¬ä¸€æ£µäºŒå‰æ ‘ã€‚ ç¤ºä¾‹ï¼š è¾“å…¥ï¼š 4 / \\ 2 7 / \\ / \\ 1 3 6 9 è¾“å‡ºï¼š 4 / \\ 7 2 / \\ / \\ 9 6 3 1 1234567891011121314151617class Solution(object): def invertTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; if not root: return root queue = [root] while queue: node = queue.pop(0) node.left, node.right = node.right, node.left if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root 257. äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›æ‰€æœ‰ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ã€‚ è¯´æ˜: å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚ ç¤ºä¾‹: è¾“å…¥: 1 / \\ 2 3 \\ 5 è¾“å‡º: [\"1->2->5\", \"1->3\"] è§£é‡Š: æ‰€æœ‰æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ä¸º: 1->2->5, 1->3 123456789101112131415161718192021class Solution(object): def binaryTreePaths(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[str] &quot;&quot;&quot; if not root: return [] item, res = [], [] self.dfs(root, item, res) return res def dfs(self, root, item, res): if root is None: return if root.left is None and root.right is None: tmp = item[:] + [str(root.val)] res.append(&#x27;-&gt;&#x27;.join(tmp)) return self.dfs(root.left, item + [str(root.val)], res) self.dfs(root.right, item + [str(root.val)], res) 501. äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•° [n]ç»™å®šä¸€ä¸ªæœ‰ç›¸åŒå€¼çš„äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰ï¼Œæ‰¾å‡º BST ä¸­çš„æ‰€æœ‰ä¼—æ•°ï¼ˆå‡ºç°é¢‘ç‡æœ€é«˜çš„å…ƒç´ ï¼‰ã€‚ å‡å®š BST æœ‰å¦‚ä¸‹å®šä¹‰ï¼š ç»“ç‚¹å·¦å­æ ‘ä¸­æ‰€å«ç»“ç‚¹çš„å€¼å°äºç­‰äºå½“å‰ç»“ç‚¹çš„å€¼ ç»“ç‚¹å³å­æ ‘ä¸­æ‰€å«ç»“ç‚¹çš„å€¼å¤§äºç­‰äºå½“å‰ç»“ç‚¹çš„å€¼ å·¦å­æ ‘å’Œå³å­æ ‘éƒ½æ˜¯äºŒå‰æœç´¢æ ‘ ä¾‹å¦‚ï¼š ç»™å®š BST [1,null,2,2], 1 \\ 2 / 2 è¿”å›[2]. æç¤ºï¼šå¦‚æœä¼—æ•°è¶…è¿‡1ä¸ªï¼Œä¸éœ€è€ƒè™‘è¾“å‡ºé¡ºåº è¿›é˜¶ï¼šä½ å¯ä»¥ä¸ä½¿ç”¨é¢å¤–çš„ç©ºé—´å—ï¼Ÿï¼ˆå‡è®¾ç”±é€’å½’äº§ç”Ÿçš„éšå¼è°ƒç”¨æ ˆçš„å¼€é”€ä¸è¢«è®¡ç®—åœ¨å†…ï¼‰ 123456789101112131415161718192021222324252627282930class Solution(object): def findMode(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[int] &quot;&quot;&quot; self.count = 0 self.max_count = 0 self.res = [] self.prev = None self.helper(root) return self.res def helper(self, root): if root is None: return self.helper(root.left) if self.prev is None: self.count = 1 elif self.prev.val == root.val: self.count += 1 else: self.count = 1 self.prev = root if self.count == self.max_count: self.res.append(self.prev.val) if self.count &gt; self.max_count: self.max_count = self.count self.res = [self.prev.val] self.helper(root.right) 543. äºŒå‰æ ‘çš„ç›´å¾„ç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œä½ éœ€è¦è®¡ç®—å®ƒçš„ç›´å¾„é•¿åº¦ã€‚ä¸€æ£µäºŒå‰æ ‘çš„ç›´å¾„é•¿åº¦æ˜¯ä»»æ„ä¸¤ä¸ªç»“ç‚¹è·¯å¾„é•¿åº¦ä¸­çš„æœ€å¤§å€¼ã€‚è¿™æ¡è·¯å¾„å¯èƒ½ç©¿è¿‡æ ¹ç»“ç‚¹ã€‚ ç¤ºä¾‹ : ç»™å®šäºŒå‰æ ‘ 1 / \\ 2 3 / \\ 4 5 è¿”å› 3, å®ƒçš„é•¿åº¦æ˜¯è·¯å¾„ [4,2,1,3] æˆ–è€… [5,2,1,3]ã€‚ æ³¨æ„ï¼šä¸¤ç»“ç‚¹ä¹‹é—´çš„è·¯å¾„é•¿åº¦æ˜¯ä»¥å®ƒä»¬ä¹‹é—´è¾¹çš„æ•°ç›®è¡¨ç¤ºã€‚ 1234567891011121314151617class Solution(object): def diameterOfBinaryTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; self.ans = 1 self.helper(root) return self.ans - 1 def helper(self, root): if not root: return 0 left = self.helper(root.left) right = self.helper(root.right) self.ans = max(self.ans, left + right + 1) return max(left, right) + 1 563. äºŒå‰æ ‘çš„å¡åº¦ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè®¡ç®—æ•´ä¸ªæ ‘çš„å¡åº¦ã€‚ ä¸€ä¸ªæ ‘çš„èŠ‚ç‚¹çš„å¡åº¦å®šä¹‰å³ä¸ºï¼Œè¯¥èŠ‚ç‚¹å·¦å­æ ‘çš„ç»“ç‚¹ä¹‹å’Œå’Œå³å­æ ‘ç»“ç‚¹ä¹‹å’Œçš„å·®çš„ç»å¯¹å€¼ã€‚ç©ºç»“ç‚¹çš„çš„å¡åº¦æ˜¯0ã€‚ æ•´ä¸ªæ ‘çš„å¡åº¦å°±æ˜¯å…¶æ‰€æœ‰èŠ‚ç‚¹çš„å¡åº¦ä¹‹å’Œã€‚ ç¤ºä¾‹: è¾“å…¥: 1 / \\ 2 3 è¾“å‡º: 1 è§£é‡Š: ç»“ç‚¹çš„å¡åº¦ 2 : 0 ç»“ç‚¹çš„å¡åº¦ 3 : 0 ç»“ç‚¹çš„å¡åº¦ 1 : |2-3| = 1 æ ‘çš„å¡åº¦ : 0 + 0 + 1 = 1 1234567891011121314151617class Solution(object): def findTilt(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; self.res = 0 self.helper(root) return self.res def helper(self, root): if root is None: return 0 L = self.helper(root.left) R = self.helper(root.right) self.res += abs(L - R) return L + R + root.val 572. å¦ä¸€ä¸ªæ ‘çš„å­æ ‘ç»™å®šä¸¤ä¸ªéç©ºäºŒå‰æ ‘ s å’Œ tï¼Œæ£€éªŒ s ä¸­æ˜¯å¦åŒ…å«å’Œ t å…·æœ‰ç›¸åŒç»“æ„å’ŒèŠ‚ç‚¹å€¼çš„å­æ ‘ã€‚s çš„ä¸€ä¸ªå­æ ‘åŒ…æ‹¬ s çš„ä¸€ä¸ªèŠ‚ç‚¹å’Œè¿™ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰å­å­™ã€‚s ä¹Ÿå¯ä»¥çœ‹åšå®ƒè‡ªèº«çš„ä¸€æ£µå­æ ‘ã€‚ ç¤ºä¾‹ 1: ç»™å®šçš„æ ‘ s: 3 / \\ 4 5 / \\ 1 2 ç»™å®šçš„æ ‘ tï¼š 4 / \\ 1 2 è¿”å› trueï¼Œå› ä¸º t ä¸ s çš„ä¸€ä¸ªå­æ ‘æ‹¥æœ‰ç›¸åŒçš„ç»“æ„å’ŒèŠ‚ç‚¹å€¼ã€‚ ç¤ºä¾‹ 2: ç»™å®šçš„æ ‘ sï¼š 3 / \\ 4 5 / \\ 1 2 / 0 ç»™å®šçš„æ ‘ tï¼š 4 / \\ 1 2 è¿”å› falseã€‚ 123456789101112131415161718192021222324252627class Solution(object): def isSubtree(self, s, t): &quot;&quot;&quot; :type s: TreeNode :type t: TreeNode :rtype: bool &quot;&quot;&quot; queue = [s] while queue: node = queue.pop(0) if self.isSameTree(node, t): return True if node.left: queue.append(node.left) if node.right: queue.append(node.right) return False def isSameTree(self, s, t): if s is None and t is None: return True if s is None or t is None: return False if s.val != t.val: return False return self.isSameTree(s.left, t.left) \\ and self.isSameTree(s.right, t.right) 606. æ ¹æ®äºŒå‰æ ‘åˆ›å»ºå­—ç¬¦ä¸² [n]ä½ éœ€è¦é‡‡ç”¨å‰åºéå†çš„æ–¹å¼ï¼Œå°†ä¸€ä¸ªäºŒå‰æ ‘è½¬æ¢æˆä¸€ä¸ªç”±æ‹¬å·å’Œæ•´æ•°ç»„æˆçš„å­—ç¬¦ä¸²ã€‚ ç©ºèŠ‚ç‚¹åˆ™ç”¨ä¸€å¯¹ç©ºæ‹¬å· â€œ()â€ è¡¨ç¤ºã€‚è€Œä¸”ä½ éœ€è¦çœç•¥æ‰€æœ‰ä¸å½±å“å­—ç¬¦ä¸²ä¸åŸå§‹äºŒå‰æ ‘ä¹‹é—´çš„ä¸€å¯¹ä¸€æ˜ å°„å…³ç³»çš„ç©ºæ‹¬å·å¯¹ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: äºŒå‰æ ‘: [1,2,3,4] 1 / \\ 2 3 / 4 è¾“å‡º: \"1(2(4))(3)\" è§£é‡Š: åŸæœ¬å°†æ˜¯â€œ1(2(4)())(3())â€ï¼Œ åœ¨ä½ çœç•¥æ‰€æœ‰ä¸å¿…è¦çš„ç©ºæ‹¬å·å¯¹ä¹‹åï¼Œ å®ƒå°†æ˜¯â€œ1(2(4))(3)â€ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: äºŒå‰æ ‘: [1,2,3,null,4] 1 / \\ 2 3 \\ 4 è¾“å‡º: \"1(2()(4))(3)\" è§£é‡Š: å’Œç¬¬ä¸€ä¸ªç¤ºä¾‹ç›¸ä¼¼ï¼Œ é™¤äº†æˆ‘ä»¬ä¸èƒ½çœç•¥ç¬¬ä¸€ä¸ªå¯¹æ‹¬å·æ¥ä¸­æ–­è¾“å…¥å’Œè¾“å‡ºä¹‹é—´çš„ä¸€å¯¹ä¸€æ˜ å°„å…³ç³»ã€‚ 12345678910111213class Solution(object): def tree2str(self, t): &quot;&quot;&quot; :type t: TreeNode :rtype: str &quot;&quot;&quot; if t is None: return &quot;&quot; if t.left is None and t.right is None: return str(t.val) left = &#x27;()&#x27; if t.left is None else &#x27;(&#x27; + self.tree2str(t.left) + &#x27;)&#x27; right = &#x27;&#x27; if t.right is None else &#x27;(&#x27; + self.tree2str(t.right) + &#x27;)&#x27; return str(t.val) + left + right 897. é€’å¢é¡ºåºæŸ¥æ‰¾æ ‘ç»™å®šä¸€ä¸ªæ ‘ï¼ŒæŒ‰ä¸­åºéå†é‡æ–°æ’åˆ—æ ‘ï¼Œä½¿æ ‘ä¸­æœ€å·¦è¾¹çš„ç»“ç‚¹ç°åœ¨æ˜¯æ ‘çš„æ ¹ï¼Œå¹¶ä¸”æ¯ä¸ªç»“ç‚¹æ²¡æœ‰å·¦å­ç»“ç‚¹ï¼Œåªæœ‰ä¸€ä¸ªå³å­ç»“ç‚¹ã€‚ ç¤ºä¾‹ ï¼š è¾“å…¥ï¼š[5,3,6,2,4,null,8,1,null,null,null,7,9] 5 / \\ 3 6 / \\ \\ 2 4 8 / / \\ 1 7 9 è¾“å‡ºï¼š[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 \\ 7 \\ 8 \\ 9 æç¤ºï¼š ç»™å®šæ ‘ä¸­çš„ç»“ç‚¹æ•°ä»‹äº 1 å’Œ 100 ä¹‹é—´ã€‚ æ¯ä¸ªç»“ç‚¹éƒ½æœ‰ä¸€ä¸ªä» 0 åˆ° 1000 èŒƒå›´å†…çš„å”¯ä¸€æ•´æ•°å€¼ã€‚ 1234567891011121314151617181920212223242526class Solution(object): def increasingBST(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; res = self.inorder(root) if not res: return None for i in xrange(len(res) - 1): res[i].right = res[i + 1] return res[0] def inorder(self, root): res = [] p = root stk = [] while p or stk: while p: stk.append(p) p = p.left node = stk.pop(-1) node.left = None res.append(node) p = node.right return res 993. äºŒå‰æ ‘çš„å ‚å…„å¼ŸèŠ‚ç‚¹åœ¨äºŒå‰æ ‘ä¸­ï¼Œæ ¹èŠ‚ç‚¹ä½äºæ·±åº¦ 0 å¤„ï¼Œæ¯ä¸ªæ·±åº¦ä¸º k çš„èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ä½äºæ·±åº¦ k+1 å¤„ã€‚ å¦‚æœäºŒå‰æ ‘çš„ä¸¤ä¸ªèŠ‚ç‚¹æ·±åº¦ç›¸åŒï¼Œä½†çˆ¶èŠ‚ç‚¹ä¸åŒï¼Œåˆ™å®ƒä»¬æ˜¯ä¸€å¯¹å ‚å…„å¼ŸèŠ‚ç‚¹ã€‚ æˆ‘ä»¬ç»™å‡ºäº†å…·æœ‰å”¯ä¸€å€¼çš„äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ rootï¼Œä»¥åŠæ ‘ä¸­ä¸¤ä¸ªä¸åŒèŠ‚ç‚¹çš„å€¼ x å’Œ yã€‚ åªæœ‰ä¸å€¼ x å’Œ y å¯¹åº”çš„èŠ‚ç‚¹æ˜¯å ‚å…„å¼ŸèŠ‚ç‚¹æ—¶ï¼Œæ‰è¿”å› trueã€‚å¦åˆ™ï¼Œè¿”å› falseã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šroot = [1,2,3,4], x = 4, y = 3 è¾“å‡ºï¼šfalse ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šroot = [1,2,3,null,4,null,5], x = 5, y = 4 è¾“å‡ºï¼štrue ç¤ºä¾‹ 3ï¼š è¾“å…¥ï¼šroot = [1,2,3,null,4], x = 2, y = 3 è¾“å‡ºï¼šfalse æç¤ºï¼š äºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°ä»‹äº 2 åˆ° 100 ä¹‹é—´ã€‚ æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½æ˜¯å”¯ä¸€çš„ã€èŒƒå›´ä¸º 1 åˆ° 100 çš„æ•´æ•°ã€‚ 12345678910111213141516171819202122232425262728class Solution(object): def isCousins(self, root, x, y): &quot;&quot;&quot; :type root: TreeNode :type x: int :type y: int :rtype: bool &quot;&quot;&quot; if root is None: return False queue = [(root, None)] m = &#123;&#125; depth = 0 while queue: sz = len(queue) for i in xrange(sz): node, parent = queue.pop(0) m[node.val] = (parent, depth) if node.left: queue.append((node.left, node)) if node.right: queue.append((node.right, node)) depth += 1 px, dx = m[x] py, dy = m[y] return px != py and dx == dy","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCodeä¹‹é“¾è¡¨","slug":"LeetCode-é“¾è¡¨","date":"2020-11-29T04:27:42.000Z","updated":"2020-12-27T05:07:28.771Z","comments":false,"path":"posts/fb43e507.html","link":"","permalink":"https://leel0330.github.io/posts/fb43e507.html","excerpt":"é“¾è¡¨çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚","text":"é“¾è¡¨çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ 24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ç»™å®šä¸€ä¸ªé“¾è¡¨ï¼Œä¸¤ä¸¤äº¤æ¢å…¶ä¸­ç›¸é‚»çš„èŠ‚ç‚¹ï¼Œå¹¶è¿”å›äº¤æ¢åçš„é“¾è¡¨ã€‚ ä½ ä¸èƒ½åªæ˜¯å•çº¯çš„æ”¹å˜èŠ‚ç‚¹å†…éƒ¨çš„å€¼ï¼Œè€Œæ˜¯éœ€è¦å®é™…çš„è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ã€‚ ç¤ºä¾‹: ç»™å®š 1->2->3->4, ä½ åº”è¯¥è¿”å› 2->1->4->3. 12345678910111213141516171819202122class Solution(object): def swapPairs(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if head is None or head.next is None: return head dummy = ListNode(-1) dummy.next = head r = dummy p, q = head, head.next while p and q: r.next = q p.next = q.next q.next = p r = p p = r.next q = p.next if p else None r = dummy.next dummy.next = None return r 82. åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´  IIç»™å®šä¸€ä¸ªæ’åºé“¾è¡¨ï¼Œåˆ é™¤æ‰€æœ‰å«æœ‰é‡å¤æ•°å­—çš„èŠ‚ç‚¹ï¼Œåªä¿ç•™åŸå§‹é“¾è¡¨ä¸­ æ²¡æœ‰é‡å¤å‡ºç° çš„æ•°å­—ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: 1->2->3->3->4->4->5 è¾“å‡º: 1->2->5 ç¤ºä¾‹ 2: è¾“å…¥: 1->1->1->2->3 è¾“å‡º: 2->3 123456789101112131415161718192021222324252627class Solution(object): def deleteDuplicates(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if head is None or head.next is None: return head dummy = ListNode(-1) dummy.next = head p, cur = dummy, head while cur: cnt = 1 v = cur.val while cur.next and cur.next.val == v: cur = cur.next cnt += 1 if cnt == 1: p.next = cur cur = cur.next p = p.next else: p.next = cur.next cur = cur.next p = dummy.next dummy.next = None return p 92. åè½¬é“¾è¡¨ IIåè½¬ä»ä½ç½® m åˆ° n çš„é“¾è¡¨ã€‚è¯·ä½¿ç”¨ä¸€è¶Ÿæ‰«æå®Œæˆåè½¬ã€‚ è¯´æ˜: 1 â‰¤ m â‰¤ n â‰¤ é“¾è¡¨é•¿åº¦ã€‚ ç¤ºä¾‹: è¾“å…¥: 1->2->3->4->5->NULL, m = 2, n = 4 è¾“å‡º: 1->4->3->2->5->NULL 1234567891011121314151617181920212223242526class Solution &#123; public ListNode reverseBetween(ListNode head, int m, int n) &#123; ListNode dummy = new ListNode(-1); dummy.next = head; ListNode prev = dummy, cur = head; int step = 0; while (step &lt; m - 1) &#123; prev = prev.next; cur = cur.next; step += 1; &#125; for (int i = 0; i &lt; n - m; i++) &#123; ListNode removed = cur.next; cur.next = cur.next.next; removed.next = prev.next; prev.next = removed; &#125; ListNode newHead = dummy.next; dummy.next = null; return newHead; &#125;&#125; 109. æœ‰åºé“¾è¡¨è½¬æ¢äºŒå‰æœç´¢æ ‘ç»™å®šä¸€ä¸ªå•é“¾è¡¨ï¼Œå…¶ä¸­çš„å…ƒç´ æŒ‰å‡åºæ’åºï¼Œå°†å…¶è½¬æ¢ä¸ºé«˜åº¦å¹³è¡¡çš„äºŒå‰æœç´¢æ ‘ã€‚ æœ¬é¢˜ä¸­ï¼Œä¸€ä¸ªé«˜åº¦å¹³è¡¡äºŒå‰æ ‘æ˜¯æŒ‡ä¸€ä¸ªäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹ çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1ã€‚ ç¤ºä¾‹: ç»™å®šçš„æœ‰åºé“¾è¡¨ï¼š [-10, -3, 0, 5, 9], ä¸€ä¸ªå¯èƒ½çš„ç­”æ¡ˆæ˜¯ï¼š[0, -3, 9, -10, null, 5], å®ƒå¯ä»¥è¡¨ç¤ºä¸‹é¢è¿™ä¸ªé«˜åº¦å¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼š 0 / \\ -3 9 / / -10 5 PythonJava12345678910111213141516171819class Solution(object): def sortedListToBST(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: TreeNode &quot;&quot;&quot; return self.buildTree(head, None) def buildTree(self, head, tail): if head == tail: return None fast = slow = head while fast != tail and fast.next != tail: fast = fast.next.next slow = slow.next root = TreeNode(slow.val) root.left = self.buildTree(head, slow) root.right = self.buildTree(slow.next, tail) return root1234567891011121314151617181920class Solution &#123; public TreeNode sortedListToBST(ListNode head) &#123; return buildTree(head, null); &#125; public TreeNode buildTree(ListNode head, ListNode tail) &#123; if (head == tail) &#123; return null; &#125; ListNode fast = head, slow = head; while (fast != tail &amp;&amp; fast.next != tail) &#123; fast = fast.next.next; slow = slow.next; &#125; TreeNode root = new TreeNode(slow.val); root.left = buildTree(head, slow); root.right = buildTree(slow.next, tail); return root; &#125;&#125; 142. ç¯å½¢é“¾è¡¨ IIç»™å®šä¸€ä¸ªé“¾è¡¨ï¼Œè¿”å›é“¾è¡¨å¼€å§‹å…¥ç¯çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ å¦‚æœé“¾è¡¨æ— ç¯ï¼Œåˆ™è¿”å› nullã€‚ ä¸ºäº†è¡¨ç¤ºç»™å®šé“¾è¡¨ä¸­çš„ç¯ï¼Œæˆ‘ä»¬ä½¿ç”¨æ•´æ•° pos æ¥è¡¨ç¤ºé“¾è¡¨å°¾è¿æ¥åˆ°é“¾è¡¨ä¸­çš„ä½ç½®ï¼ˆç´¢å¼•ä» 0 å¼€å§‹ï¼‰ã€‚ å¦‚æœ pos æ˜¯ -1ï¼Œåˆ™åœ¨è¯¥é“¾è¡¨ä¸­æ²¡æœ‰ç¯ã€‚ è¯´æ˜ï¼šä¸å…è®¸ä¿®æ”¹ç»™å®šçš„é“¾è¡¨ã€‚ 12345678910111213141516171819class Solution(object): def detectCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; fast, slow = head, head while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: break if fast is None or fast.next is None: return None fast = head while slow != fast: slow = slow.next fast = fast.next return slow 143. é‡æ’é“¾è¡¨ç»™å®šä¸€ä¸ªå•é“¾è¡¨ Lï¼šL0â†’L1â†’â€¦â†’Ln-1â†’Ln ï¼Œå°†å…¶é‡æ–°æ’åˆ—åå˜ä¸ºï¼š L0â†’Lnâ†’L1â†’Ln-1â†’L2â†’Ln-2â†’â€¦ ä½ ä¸èƒ½åªæ˜¯å•çº¯çš„æ”¹å˜èŠ‚ç‚¹å†…éƒ¨çš„å€¼ï¼Œè€Œæ˜¯éœ€è¦å®é™…çš„è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ã€‚ ç¤ºä¾‹ 1: ç»™å®šé“¾è¡¨ 1->2->3->4, é‡æ–°æ’åˆ—ä¸º 1->4->2->3. ç¤ºä¾‹ 2: ç»™å®šé“¾è¡¨ 1->2->3->4->5, é‡æ–°æ’åˆ—ä¸º 1->5->2->4->3. 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution(object): def reorderList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: None Do not return anything, modify head in-place instead. &quot;&quot;&quot; if head is None or head.next is None: return prev = None fast, slow = head, head while fast and fast.next: prev = slow slow = slow.next fast = fast.next.next prev.next = None slow = self.reverseList(slow) dummy = ListNode(-1) p = dummy while slow and head: ts, th = slow.next, head.next p.next = head p.next.next = slow slow = ts head = th p = p.next.next p.next = slow if slow else head p = dummy.next dummy.next = None def reverseList(self, head): if head is None or head.next is None: return head p, q = None, head while q: r = q.next q.next = p p = q q = r return p 147. å¯¹é“¾è¡¨è¿›è¡Œæ’å…¥æ’åº [n]12345678910111213141516171819202122class Solution(object): def insertionSortList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if head is None or head.next is None: return head dummy = ListNode(0) dummy.next = head while head.next: if head.val &lt;= head.next.val: head = head.next else: tmp = head.next head.next = tmp.next q = dummy while q.next and q.next.val &lt;= tmp.val: q = q.next tmp.next = q.next q.next = tmp return dummy.next 148. æ’åºé“¾è¡¨merge sort 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def sortList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if head is None or head.next is None: return head prev, fast, slow = None, head, head while fast and fast.next: prev = slow fast = fast.next.next slow = slow.next prev.next = None head = self.sortList(head) slow = self.sortList(slow) return self.merge(head, slow) def merge(self, l1, l2): dummy = ListNode(-1) p = dummy while l1 and l2: if l1.val &lt; l2.val: p.next = l1 l1 = l1.next else: p.next = l2 l2 = l2.next p = p.next p.next = l1 if l1 else l2 p = dummy.next dummy.next = None return p 234. å›æ–‡é“¾è¡¨è¯·åˆ¤æ–­ä¸€ä¸ªé“¾è¡¨æ˜¯å¦ä¸ºå›æ–‡é“¾è¡¨ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: 1->2 è¾“å‡º: false ç¤ºä¾‹ 2: è¾“å…¥: 1->2->2->1 è¾“å‡º: true 12345678910111213141516171819202122232425262728293031323334class Solution(object): def isPalindrome(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; if head is None or head.next is None: return True mid = self.get_mid_node(head) mid = self.reverse_list(mid) while mid: if mid.val != head.val: return False mid = mid.next head = head.next return True def get_mid_node(self, head): slow, fast = head, head while fast and fast.next: fast = fast.next.next slow = slow.next return slow def reverse_list(self, head): if head is None or head.next is None: return head p, q = None, head while q: r = q.next q.next = p p = q q = r return p 328. å¥‡å¶é“¾è¡¨ç»™å®šä¸€ä¸ªå•é“¾è¡¨ï¼ŒæŠŠæ‰€æœ‰çš„å¥‡æ•°èŠ‚ç‚¹å’Œå¶æ•°èŠ‚ç‚¹åˆ†åˆ«æ’åœ¨ä¸€èµ·ã€‚è¯·æ³¨æ„ï¼Œè¿™é‡Œçš„å¥‡æ•°èŠ‚ç‚¹å’Œå¶æ•°èŠ‚ç‚¹æŒ‡çš„æ˜¯èŠ‚ç‚¹ç¼–å·çš„å¥‡å¶æ€§ï¼Œè€Œä¸æ˜¯èŠ‚ç‚¹çš„å€¼çš„å¥‡å¶æ€§ã€‚ è¯·å°è¯•ä½¿ç”¨åŸåœ°ç®—æ³•å®Œæˆã€‚ä½ çš„ç®—æ³•çš„ç©ºé—´å¤æ‚åº¦åº”ä¸º O(1)ï¼Œæ—¶é—´å¤æ‚åº¦åº”ä¸º O(nodes)ï¼Œnodes ä¸ºèŠ‚ç‚¹æ€»æ•°ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: 1->2->3->4->5->NULL è¾“å‡º: 1->3->5->2->4->NULL ç¤ºä¾‹ 2: è¾“å…¥: 2->1->3->5->6->4->7->NULL è¾“å‡º: 2->3->6->7->1->5->4->NULL è¯´æ˜: åº”å½“ä¿æŒå¥‡æ•°èŠ‚ç‚¹å’Œå¶æ•°èŠ‚ç‚¹çš„ç›¸å¯¹é¡ºåºã€‚ é“¾è¡¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹è§†ä¸ºå¥‡æ•°èŠ‚ç‚¹ï¼Œç¬¬äºŒä¸ªèŠ‚ç‚¹è§†ä¸ºå¶æ•°èŠ‚ç‚¹ï¼Œä»¥æ­¤ç±»æ¨ã€‚ 123456789101112131415161718192021222324class Solution(object): def oddEvenList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if head is None or head.next is None: return head new_head_p, new_head_q = head, head.next p, q = head, head.next prev = None while p: next_p = q.next if q else None next_q = next_p.next if next_p else None p.next = next_p if q: q.next = next_q prev = p p = next_p q = next_q prev.next = new_head_q return new_head_p 430. æ‰å¹³åŒ–å¤šçº§åŒå‘é“¾è¡¨ [n]æ‚¨å°†è·å¾—ä¸€ä¸ªåŒå‘é“¾è¡¨ï¼Œé™¤äº†ä¸‹ä¸€ä¸ªå’Œå‰ä¸€ä¸ªæŒ‡é’ˆä¹‹å¤–ï¼Œå®ƒè¿˜æœ‰ä¸€ä¸ªå­æŒ‡é’ˆï¼Œå¯èƒ½æŒ‡å‘å•ç‹¬çš„åŒå‘é“¾è¡¨ã€‚è¿™äº›å­åˆ—è¡¨å¯èƒ½æœ‰ä¸€ä¸ªæˆ–å¤šä¸ªè‡ªå·±çš„å­é¡¹ï¼Œä¾æ­¤ç±»æ¨ï¼Œç”Ÿæˆå¤šçº§æ•°æ®ç»“æ„ï¼Œå¦‚ä¸‹é¢çš„ç¤ºä¾‹æ‰€ç¤ºã€‚ æ‰å¹³åŒ–åˆ—è¡¨ï¼Œä½¿æ‰€æœ‰ç»“ç‚¹å‡ºç°åœ¨å•çº§åŒé“¾è¡¨ä¸­ã€‚æ‚¨å°†è·å¾—åˆ—è¡¨ç¬¬ä¸€çº§çš„å¤´éƒ¨ã€‚ ç¤ºä¾‹: è¾“å…¥: 1---2---3---4---5---6--NULL | 7---8---9---10--NULL | 11--12--NULL è¾“å‡º: 1-2-3-7-8-11-12-9-10-4-5-6-NULL 123456789101112131415161718192021222324class Solution(object): def flatten(self, head): &quot;&quot;&quot; :type head: Node :rtype: Node &quot;&quot;&quot; self.dfs(head) return head def dfs(self, head): cur = head while cur: if cur.child: next = cur.next cur.next = cur.child cur.next.prev = cur child_last = self.dfs(cur.child) child_last.next = next if next: next.prev = child_last cur.child = None head = cur cur = cur.next return head 1019. é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªæ›´å¤§èŠ‚ç‚¹ç»™å‡ºä¸€ä¸ªä»¥å¤´èŠ‚ç‚¹ head ä½œä¸ºç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„é“¾è¡¨ã€‚é“¾è¡¨ä¸­çš„èŠ‚ç‚¹åˆ†åˆ«ç¼–å·ä¸ºï¼šnode_1, node_2, node_3, â€¦ ã€‚ æ¯ä¸ªèŠ‚ç‚¹éƒ½å¯èƒ½æœ‰ä¸‹ä¸€ä¸ªæ›´å¤§å€¼ï¼ˆnext larger valueï¼‰ï¼šå¯¹äº node_iï¼Œå¦‚æœå…¶ next_larger(node_i) æ˜¯ node_j.valï¼Œé‚£ä¹ˆå°±æœ‰ j &gt; i ä¸” node_j.val &gt; node_i.valï¼Œè€Œ j æ˜¯å¯èƒ½çš„é€‰é¡¹ä¸­æœ€å°çš„é‚£ä¸ªã€‚å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„ jï¼Œé‚£ä¹ˆä¸‹ä¸€ä¸ªæ›´å¤§å€¼ä¸º 0 ã€‚ è¿”å›æ•´æ•°ç­”æ¡ˆæ•°ç»„ answerï¼Œå…¶ä¸­ answer[i] = next_larger(node_{i+1}) ã€‚ æ³¨æ„ï¼šåœ¨ä¸‹é¢çš„ç¤ºä¾‹ä¸­ï¼Œè¯¸å¦‚ [2,1,5] è¿™æ ·çš„è¾“å…¥ï¼ˆä¸æ˜¯è¾“å‡ºï¼‰æ˜¯é“¾è¡¨çš„åºåˆ—åŒ–è¡¨ç¤ºï¼Œå…¶å¤´èŠ‚ç‚¹çš„å€¼ä¸º 2ï¼Œç¬¬äºŒä¸ªèŠ‚ç‚¹å€¼ä¸º 1ï¼Œç¬¬ä¸‰ä¸ªèŠ‚ç‚¹å€¼ä¸º 5 ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼š[2,1,5] è¾“å‡ºï¼š[5,5,0] ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼š[2,7,4,3,5] è¾“å‡ºï¼š[7,0,5,5,0] ç¤ºä¾‹ 3ï¼š è¾“å…¥ï¼š[1,7,5,1,9,2,5,1] è¾“å‡ºï¼š[7,9,9,9,0,5,0,0] æç¤ºï¼š å¯¹äºé“¾è¡¨ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹ï¼Œ1 &lt;= node.val &lt;= 10^9 ç»™å®šåˆ—è¡¨çš„é•¿åº¦åœ¨ [0, 10000] èŒƒå›´å†… 1234567891011121314151617class Solution(object): def nextLargerNodes(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: List[int] &quot;&quot;&quot; nums = [] while head: nums.append(head.val) head = head.next res = [0] * len(nums) stk = [] for i, v in enumerate(nums): while stk and nums[stk[-1]] &lt; v: res[stk.pop()] = v stk.append(i) return res 1171. ä»é“¾è¡¨ä¸­åˆ å»æ€»å’Œå€¼ä¸ºé›¶çš„è¿ç»­èŠ‚ç‚¹ [n]ç»™ä½ ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ headï¼Œè¯·ä½ ç¼–å†™ä»£ç ï¼Œåå¤åˆ å»é“¾è¡¨ä¸­ç”± æ€»å’Œ å€¼ä¸º 0 çš„è¿ç»­èŠ‚ç‚¹ç»„æˆçš„åºåˆ—ï¼Œç›´åˆ°ä¸å­˜åœ¨è¿™æ ·çš„åºåˆ—ä¸ºæ­¢ã€‚ åˆ é™¤å®Œæ¯•åï¼Œè¯·ä½ è¿”å›æœ€ç»ˆç»“æœé“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚ ä½ å¯ä»¥è¿”å›ä»»ä½•æ»¡è¶³é¢˜ç›®è¦æ±‚çš„ç­”æ¡ˆã€‚ ï¼ˆæ³¨æ„ï¼Œä¸‹é¢ç¤ºä¾‹ä¸­çš„æ‰€æœ‰åºåˆ—ï¼Œéƒ½æ˜¯å¯¹ ListNode å¯¹è±¡åºåˆ—åŒ–çš„è¡¨ç¤ºã€‚ï¼‰ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šhead = [1,2,-3,3,1] è¾“å‡ºï¼š[3,1] æç¤ºï¼šç­”æ¡ˆ [1,2,1] ä¹Ÿæ˜¯æ­£ç¡®çš„ã€‚ ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šhead = [1,2,3,-3,4] è¾“å‡ºï¼š[1,2,4] ç¤ºä¾‹ 3ï¼š è¾“å…¥ï¼šhead = [1,2,3,-3,-2] è¾“å‡ºï¼š[1] æç¤ºï¼š ç»™ä½ çš„é“¾è¡¨ä¸­å¯èƒ½æœ‰ 1 åˆ° 1000 ä¸ªèŠ‚ç‚¹ã€‚ å¯¹äºé“¾è¡¨ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹çš„å€¼ï¼š-1000 &lt;= node.val &lt;= 1000. 12345678910111213141516171819202122232425262728class Solution(object): def removeZeroSumSublists(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; m = &#123;&#125; dummy = ListNode(0) dummy.next = head p = dummy total = 0 while p: total += p.val m[total] = p p = p.next total = 0 p = dummy while p: total += p.val p.next = m[total].next p = p.next p = dummy.next dummy.next = None return p","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCodeä¹‹æ ˆå’Œé˜Ÿåˆ—","slug":"LeetCode-æ ˆå’Œé˜Ÿåˆ—","date":"2020-11-28T03:50:05.000Z","updated":"2020-12-27T05:07:12.635Z","comments":false,"path":"posts/1ccb8d85.html","link":"","permalink":"https://leel0330.github.io/posts/1ccb8d85.html","excerpt":"æ ˆä¸é˜Ÿåˆ—çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚","text":"æ ˆä¸é˜Ÿåˆ—çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ 394. å­—ç¬¦ä¸²è§£ç ç»™å®šä¸€ä¸ªç»è¿‡ç¼–ç çš„å­—ç¬¦ä¸²ï¼Œè¿”å›å®ƒè§£ç åçš„å­—ç¬¦ä¸²ã€‚ ç¼–ç è§„åˆ™ä¸º: k[encoded_string]ï¼Œè¡¨ç¤ºå…¶ä¸­æ–¹æ‹¬å·å†…éƒ¨çš„ encoded_string æ­£å¥½é‡å¤ k æ¬¡ã€‚æ³¨æ„ k ä¿è¯ä¸ºæ­£æ•´æ•°ã€‚ ä½ å¯ä»¥è®¤ä¸ºè¾“å…¥å­—ç¬¦ä¸²æ€»æ˜¯æœ‰æ•ˆçš„ï¼›è¾“å…¥å­—ç¬¦ä¸²ä¸­æ²¡æœ‰é¢å¤–çš„ç©ºæ ¼ï¼Œä¸”è¾“å…¥çš„æ–¹æ‹¬å·æ€»æ˜¯ç¬¦åˆæ ¼å¼è¦æ±‚çš„ã€‚ æ­¤å¤–ï¼Œä½ å¯ä»¥è®¤ä¸ºåŸå§‹æ•°æ®ä¸åŒ…å«æ•°å­—ï¼Œæ‰€æœ‰çš„æ•°å­—åªè¡¨ç¤ºé‡å¤çš„æ¬¡æ•° k ï¼Œä¾‹å¦‚ä¸ä¼šå‡ºç°åƒ 3a æˆ– 2[4] çš„è¾“å…¥ã€‚ ç¤ºä¾‹: s = \"3[a]2[bc]\", è¿”å› \"aaabcbc\". s = \"3[a2[c]]\", è¿”å› \"accaccacc\". s = \"2[abc]3[cd]ef\", è¿”å› \"abcabccdcdcdef\". PythonJava12345678910111213141516171819class Solution(object): def decodeString(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; stack, res, multi = [], &quot;&quot;, 0 for c in s: if c == &#x27;[&#x27;: stack.append([multi, res]) res, multi = &quot;&quot;, 0 elif c == &#x27;]&#x27;: cur_multi, last_res = stack.pop() res = last_res + cur_multi * res elif &#x27;0&#x27; &lt;= c &lt;= &#x27;9&#x27;: multi = multi * 10 + int(c) else: res += c return res12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; class Item &#123; public int num; public String str; public Item(int n, String s) &#123; this.num = n; this.str = s; &#125; &#125; public String decodeString(String s) &#123; String res = &quot;&quot;; int multi = 0; Stack&lt;Item&gt; stk = new Stack&lt;&gt;(); for(int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if(c == &#x27;[&#x27;) &#123; stk.add(new Item(multi, res)); res = &quot;&quot;; multi = 0; &#125;else if(c == &#x27;]&#x27;) &#123; Item item = stk.pop(); StringBuilder sb = new StringBuilder(); for(int k = 0; k &lt; item.num; k++) &#123; sb.append(res); &#125; res = item.str + sb.toString(); &#125;else if(c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; multi = multi * 10 + Integer.parseInt(c + &quot;&quot;); &#125;else&#123; res += c; &#125; &#125; return res; &#125;&#125; 402. ç§»æ‰Kä½æ•°å­—ç»™å®šä¸€ä¸ªä»¥å­—ç¬¦ä¸²è¡¨ç¤ºçš„éè´Ÿæ•´æ•° numï¼Œç§»é™¤è¿™ä¸ªæ•°ä¸­çš„ k ä½æ•°å­—ï¼Œä½¿å¾—å‰©ä¸‹çš„æ•°å­—æœ€å°ã€‚ æ³¨æ„: num çš„é•¿åº¦å°äº 10002 ä¸” â‰¥ kã€‚ num ä¸ä¼šåŒ…å«ä»»ä½•å‰å¯¼é›¶ã€‚ ç¤ºä¾‹ 1 : è¾“å…¥: num = \"1432219\", k = 3 è¾“å‡º: \"1219\" è§£é‡Š: ç§»é™¤æ‰ä¸‰ä¸ªæ•°å­— 4, 3, å’Œ 2 å½¢æˆä¸€ä¸ªæ–°çš„æœ€å°çš„æ•°å­— 1219ã€‚ ç¤ºä¾‹ 2 : è¾“å…¥: num = \"10200\", k = 1 è¾“å‡º: \"200\" è§£é‡Š: ç§»æ‰é¦–ä½çš„ 1 å‰©ä¸‹çš„æ•°å­—ä¸º 200. æ³¨æ„è¾“å‡ºä¸èƒ½æœ‰ä»»ä½•å‰å¯¼é›¶ã€‚ ç¤ºä¾‹ 3 : è¾“å…¥: num = \"10\", k = 2 è¾“å‡º: \"0\" è§£é‡Š: ä»åŸæ•°å­—ç§»é™¤æ‰€æœ‰çš„æ•°å­—ï¼Œå‰©ä½™ä¸ºç©ºå°±æ˜¯0ã€‚ PythonJava12345678910111213141516171819class Solution(object): def removeKdigits(self, num, k): &quot;&quot;&quot; :type num: str :type k: int :rtype: str &quot;&quot;&quot; stk = [] for c in num: while k and stk and stk[-1] &gt; c: stk.pop(-1) k -= 1 stk.append(c) while k: stk.pop(-1) k -= 1 if not stk: return &#x27;0&#x27; return str(int(&#x27;&#x27;.join(stk)))12345678910111213141516171819202122232425262728class Solution &#123; public String removeKdigits(String num, int k) &#123; Stack&lt;Character&gt; stk = new Stack&lt;&gt;(); for (int i = 0; i &lt; num.length(); i++) &#123; char c = num.charAt(i); while (k &gt; 0 &amp;&amp; !stk.empty() &amp;&amp; stk.peek() &gt; c) &#123; stk.pop(); k -= 1; &#125; stk.add(c); &#125; while (k &gt; 0) &#123; stk.pop(); k -= 1; &#125; while (!stk.empty() &amp;&amp; stk.get(0) == &#x27;0&#x27;) &#123; stk.remove(0); &#125; if (stk.empty()) &#123; return &quot;0&quot;; &#125; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; stk.size(); i++) &#123; sb.append(stk.get(i)); &#125; return sb.toString(); &#125;&#125; 456. 132æ¨¡å¼ç»™å®šä¸€ä¸ªæ•´æ•°åºåˆ—ï¼ša1, a2, â€¦, anï¼Œä¸€ä¸ª132æ¨¡å¼çš„å­åºåˆ— ai, aj, ak è¢«å®šä¹‰ä¸ºï¼šå½“ i &lt; j &lt; k æ—¶ï¼Œai &lt; ak &lt; ajã€‚è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œå½“ç»™å®šæœ‰ n ä¸ªæ•°å­—çš„åºåˆ—æ—¶ï¼ŒéªŒè¯è¿™ä¸ªåºåˆ—ä¸­æ˜¯å¦å«æœ‰132æ¨¡å¼çš„å­åºåˆ—ã€‚ æ³¨æ„ï¼šn çš„å€¼å°äº15000ã€‚ ç¤ºä¾‹1: è¾“å…¥: [1, 2, 3, 4] è¾“å‡º: False è§£é‡Š: åºåˆ—ä¸­ä¸å­˜åœ¨132æ¨¡å¼çš„å­åºåˆ—ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: [3, 1, 4, 2] è¾“å‡º: True è§£é‡Š: åºåˆ—ä¸­æœ‰ 1 ä¸ª132æ¨¡å¼çš„å­åºåˆ—ï¼š [1, 4, 2]. ç¤ºä¾‹ 3: è¾“å…¥: [-1, 3, 2, 0] è¾“å‡º: True è§£é‡Š: åºåˆ—ä¸­æœ‰ 3 ä¸ª132æ¨¡å¼çš„çš„å­åºåˆ—: [-1, 3, 2], [-1, 3, 0] å’Œ [-1, 2, 0]. PythonJava12345678910111213141516class Solution(object): def find132pattern(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; stk = [] INT_MIN = -(1 &lt;&lt; 31) third = INT_MIN for idx in xrange(len(nums) - 1, -1, -1): if nums[idx] &lt; third: return True while stk and stk[-1] &lt; nums[idx]: third = stk.pop(-1) stk.append(nums[idx]) return False1234567891011121314151617class Solution &#123; public boolean find132pattern(int[] nums) &#123; int INT_MIN = -(1 &lt;&lt; 31); int third = INT_MIN; Stack&lt;Integer&gt; stk = new Stack&lt;&gt;(); for (int i = nums.length - 1; i &gt;= 0; i--) &#123; if (nums[i] &lt; third) &#123; return true; &#125; while (!stk.empty() &amp;&amp; stk.peek() &lt; nums[i]) &#123; third = stk.pop(); &#125; stk.add(nums[i]); &#125; return false; &#125;&#125; 496. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  Iç»™å®šä¸¤ä¸ªæ²¡æœ‰é‡å¤å…ƒç´ çš„æ•°ç»„ nums1 å’Œ nums2 ï¼Œå…¶ä¸­nums1 æ˜¯ nums2 çš„å­é›†ã€‚æ‰¾åˆ° nums1 ä¸­æ¯ä¸ªå…ƒç´ åœ¨ nums2 ä¸­çš„ä¸‹ä¸€ä¸ªæ¯”å…¶å¤§çš„å€¼ã€‚ nums1 ä¸­æ•°å­— x çš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ æ˜¯æŒ‡ x åœ¨ nums2 ä¸­å¯¹åº”ä½ç½®çš„å³è¾¹çš„ç¬¬ä¸€ä¸ªæ¯” x å¤§çš„å…ƒç´ ã€‚å¦‚æœä¸å­˜åœ¨ï¼Œå¯¹åº”ä½ç½®è¾“å‡º-1ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: nums1 = [4,1,2], nums2 = [1,3,4,2]. è¾“å‡º: [-1,3,-1] è§£é‡Š: å¯¹äºnum1ä¸­çš„æ•°å­—4ï¼Œä½ æ— æ³•åœ¨ç¬¬äºŒä¸ªæ•°ç»„ä¸­æ‰¾åˆ°ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°å­—ï¼Œå› æ­¤è¾“å‡º -1ã€‚ å¯¹äºnum1ä¸­çš„æ•°å­—1ï¼Œç¬¬äºŒä¸ªæ•°ç»„ä¸­æ•°å­—1å³è¾¹çš„ä¸‹ä¸€ä¸ªè¾ƒå¤§æ•°å­—æ˜¯ 3ã€‚ å¯¹äºnum1ä¸­çš„æ•°å­—2ï¼Œç¬¬äºŒä¸ªæ•°ç»„ä¸­æ²¡æœ‰ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°å­—ï¼Œå› æ­¤è¾“å‡º -1ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: nums1 = [2,4], nums2 = [1,2,3,4]. è¾“å‡º: [3,-1] è§£é‡Š: å¯¹äºnum1ä¸­çš„æ•°å­—2ï¼Œç¬¬äºŒä¸ªæ•°ç»„ä¸­çš„ä¸‹ä¸€ä¸ªè¾ƒå¤§æ•°å­—æ˜¯3ã€‚ å¯¹äºnum1ä¸­çš„æ•°å­—4ï¼Œç¬¬äºŒä¸ªæ•°ç»„ä¸­æ²¡æœ‰ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°å­—ï¼Œå› æ­¤è¾“å‡º -1ã€‚ æ³¨æ„: nums1å’Œnums2ä¸­æ‰€æœ‰å…ƒç´ æ˜¯å”¯ä¸€çš„ã€‚ nums1å’Œnums2 çš„æ•°ç»„å¤§å°éƒ½ä¸è¶…è¿‡1000ã€‚ 123456789101112131415161718192021class Solution(object): def nextGreaterElement(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: List[int] &quot;&quot;&quot; m = &#123;&#125; stk = [] res = [-1 for _ in xrange(len(nums1))] for n in nums2: while len(stk) &gt; 0 and stk[-1] &lt; n: m[stk[-1]] = n stk.pop(-1) stk.append(n) for idx, n in enumerate(nums1): if n in m: res[idx] = m[n] else: res[idx] = -1 return res 503. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  II [n]ç»™å®šä¸€ä¸ªå¾ªç¯æ•°ç»„ï¼ˆæœ€åä¸€ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä¸ªå…ƒç´ æ˜¯æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œè¾“å‡ºæ¯ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ ã€‚æ•°å­— x çš„ä¸‹ä¸€ä¸ªæ›´å¤§çš„å…ƒç´ æ˜¯æŒ‰æ•°ç»„éå†é¡ºåºï¼Œè¿™ä¸ªæ•°å­—ä¹‹åçš„ç¬¬ä¸€ä¸ªæ¯”å®ƒæ›´å¤§çš„æ•°ï¼Œè¿™æ„å‘³ç€ä½ åº”è¯¥å¾ªç¯åœ°æœç´¢å®ƒçš„ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°ã€‚å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™è¾“å‡º -1ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [1,2,1] è¾“å‡º: [2,-1,2] è§£é‡Š: ç¬¬ä¸€ä¸ª 1 çš„ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°æ˜¯ 2ï¼› æ•°å­— 2 æ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°ï¼› ç¬¬äºŒä¸ª 1 çš„ä¸‹ä¸€ä¸ªæœ€å¤§çš„æ•°éœ€è¦å¾ªç¯æœç´¢ï¼Œç»“æœä¹Ÿæ˜¯ 2ã€‚ æ³¨æ„: è¾“å…¥æ•°ç»„çš„é•¿åº¦ä¸ä¼šè¶…è¿‡ 10000ã€‚ 123456789101112131415161718class Solution(object): def nextGreaterElements(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[int] &quot;&quot;&quot; n = len(nums) res = [-1 for _ in xrange(n)] stk = [] for idx in xrange(n * 2 - 1, -1, -1): while stk and stk[-1] &lt;= nums[idx % n]: stk.pop(-1) if len(stk) == 0: res[idx % n] = -1 else: res[idx % n] = stk[-1] stk.append(nums[idx % n]) return res 622. è®¾è®¡å¾ªç¯é˜Ÿåˆ—123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class MyCircularQueue(object): def __init__(self, k): &quot;&quot;&quot; Initialize your data structure here. Set the size of the queue to be k. :type k: int &quot;&quot;&quot; self.queue = [None] * k self.size = k self.real_cnt = 0 self.head = 0 self.tail = 0 # æœ‰æ•ˆå…ƒç´ å°¾éƒ¨çš„ä¸‹ä¸€ä¸ªä½ç½® def enQueue(self, value): &quot;&quot;&quot; Insert an element into the circular queue. Return true if the operation is successful. :type value: int :rtype: bool &quot;&quot;&quot; if self.isFull(): return False self.queue[self.tail] = value self.tail = (self.tail + 1) % self.size self.real_cnt += 1 return True def deQueue(self): &quot;&quot;&quot; Delete an element from the circular queue. Return true if the operation is successful. :rtype: bool &quot;&quot;&quot; if self.isEmpty(): return False self.head = (self.head + 1) % self.size self.real_cnt -= 1 return True def Front(self): &quot;&quot;&quot; Get the front item from the queue. :rtype: int &quot;&quot;&quot; if self.isEmpty(): return -1 return self.queue[self.head] def Rear(self): &quot;&quot;&quot; Get the last item from the queue. :rtype: int &quot;&quot;&quot; if self.isEmpty(): return -1 if self.tail == 0: return self.queue[self.size - 1] return self.queue[self.tail - 1] def isEmpty(self): &quot;&quot;&quot; Checks whether the circular queue is empty or not. :rtype: bool &quot;&quot;&quot; return self.real_cnt == 0 def isFull(self): &quot;&quot;&quot; Checks whether the circular queue is full or not. :rtype: bool &quot;&quot;&quot; return self.real_cnt == self.size 641. è®¾è®¡å¾ªç¯åŒç«¯é˜Ÿåˆ—123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109class MyCircularDeque(object): def __init__(self, k): &quot;&quot;&quot; Initialize your data structure here. Set the size of the deque to be k. :type k: int &quot;&quot;&quot; self.deque = [None] * k self.size = k self.real_cnt = 0 self.head = 0 self.tail = 0 # æœ‰æ•ˆå…ƒç´ å°¾éƒ¨çš„ä¸‹ä¸€ä¸ªä½ç½® def insertFront(self, value): &quot;&quot;&quot; Adds an item at the front of Deque. Return true if the operation is successful. :type value: int :rtype: bool &quot;&quot;&quot; if self.isFull(): return False if self.head == 0: self.head = self.size - 1 else: self.head = self.head - 1 self.deque[self.head] = value self.real_cnt += 1 return True def insertLast(self, value): &quot;&quot;&quot; Adds an item at the rear of Deque. Return true if the operation is successful. :type value: int :rtype: bool &quot;&quot;&quot; if self.isFull(): return False self.deque[self.tail] = value self.tail = (self.tail + 1) % self.size self.real_cnt += 1 return True def deleteFront(self): &quot;&quot;&quot; Deletes an item from the front of Deque. Return true if the operation is successful. :rtype: bool &quot;&quot;&quot; if self.isEmpty(): return False self.head = (self.head + 1) % self.size self.real_cnt -= 1 return True def deleteLast(self): &quot;&quot;&quot; Deletes an item from the rear of Deque. Return true if the operation is successful. :rtype: bool &quot;&quot;&quot; if self.isEmpty(): return False if self.tail == 0: self.tail = self.size - 1 else: self.tail = self.tail - 1 self.real_cnt -= 1 return True def getFront(self): &quot;&quot;&quot; Get the front item from the deque. :rtype: int &quot;&quot;&quot; if self.isEmpty(): return -1 return self.deque[self.head] def getRear(self): &quot;&quot;&quot; Get the last item from the deque. :rtype: int &quot;&quot;&quot; if self.isEmpty(): return -1 if self.tail == 0: return self.deque[self.size - 1] else: return self.deque[self.tail - 1] def isEmpty(self): &quot;&quot;&quot; Checks whether the circular deque is empty or not. :rtype: bool &quot;&quot;&quot; return self.real_cnt == 0 def isFull(self): &quot;&quot;&quot; Checks whether the circular deque is full or not. :rtype: bool &quot;&quot;&quot; return self.real_cnt == self.size 739. æ¯æ—¥æ¸©åº¦ [n]æ ¹æ®æ¯æ—¥ æ°”æ¸© åˆ—è¡¨ï¼Œè¯·é‡æ–°ç”Ÿæˆä¸€ä¸ªåˆ—è¡¨ï¼Œå¯¹åº”ä½ç½®çš„è¾“å…¥æ˜¯ä½ éœ€è¦å†ç­‰å¾…å¤šä¹…æ¸©åº¦æ‰ä¼šå‡é«˜è¶…è¿‡è¯¥æ—¥çš„å¤©æ•°ã€‚å¦‚æœä¹‹åéƒ½ä¸ä¼šå‡é«˜ï¼Œè¯·åœ¨è¯¥ä½ç½®ç”¨ 0 æ¥ä»£æ›¿ã€‚ ä¾‹å¦‚ï¼Œç»™å®šä¸€ä¸ªåˆ—è¡¨ temperatures = [73, 74, 75, 71, 69, 72, 76, 73]ï¼Œä½ çš„è¾“å‡ºåº”è¯¥æ˜¯ [1, 1, 4, 2, 1, 1, 0, 0]ã€‚ æç¤ºï¼šæ°”æ¸© åˆ—è¡¨é•¿åº¦çš„èŒƒå›´æ˜¯ [1, 30000]ã€‚æ¯ä¸ªæ°”æ¸©çš„å€¼çš„å‡ä¸ºåæ°åº¦ï¼Œéƒ½æ˜¯åœ¨ [30, 100] èŒƒå›´å†…çš„æ•´æ•°ã€‚ 1234567891011121314class Solution(object): def dailyTemperatures(self, T): &quot;&quot;&quot; :type T: List[int] :rtype: List[int] &quot;&quot;&quot; res = [0 for _ in xrange(len(T))] stk = [] for i in xrange(len(T) - 1, -1, -1): while stk and T[stk[-1]] &lt;= T[i]: stk.pop(-1) res[i] = 0 if not stk else stk[-1] - i stk.append(i) return res 856. æ‹¬å·çš„åˆ†æ•°ç»™å®šä¸€ä¸ªå¹³è¡¡æ‹¬å·å­—ç¬¦ä¸² Sï¼ŒæŒ‰ä¸‹è¿°è§„åˆ™è®¡ç®—è¯¥å­—ç¬¦ä¸²çš„åˆ†æ•°ï¼š () å¾— 1 åˆ†ã€‚AB å¾— A + B åˆ†ï¼Œå…¶ä¸­ A å’Œ B æ˜¯å¹³è¡¡æ‹¬å·å­—ç¬¦ä¸²ã€‚(A) å¾— 2 * A åˆ†ï¼Œå…¶ä¸­ A æ˜¯å¹³è¡¡æ‹¬å·å­—ç¬¦ä¸²ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼š \"()\" è¾“å‡ºï¼š 1 ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼š \"(())\" è¾“å‡ºï¼š 2 ç¤ºä¾‹ 3ï¼š è¾“å…¥ï¼š \"()()\" è¾“å‡ºï¼š 2 ç¤ºä¾‹ 4ï¼š è¾“å…¥ï¼š \"(()(()))\" è¾“å‡ºï¼š 6 æç¤ºï¼š S æ˜¯å¹³è¡¡æ‹¬å·å­—ç¬¦ä¸²ï¼Œä¸”åªå«æœ‰ ( å’Œ ) ã€‚ 2 &lt;= S.length &lt;= 50 123456789101112131415161718192021class Solution(object): def scoreOfParentheses(self, S): &quot;&quot;&quot; :type S: str :rtype: int &quot;&quot;&quot; stk = [] for c in S: if c == &#x27;(&#x27;: stk.append(-1) else: cnt = 0 while stk[-1] != -1: cnt += stk[-1] stk.pop(-1) stk.pop(-1) if cnt == 0: stk.append(1) else: stk.append(2 * cnt) return sum(stk) 880. ç´¢å¼•å¤„çš„è§£ç å­—ç¬¦ä¸² [n]ç»™å®šä¸€ä¸ªç¼–ç å­—ç¬¦ä¸² Sã€‚ä¸ºäº†æ‰¾å‡ºè§£ç å­—ç¬¦ä¸²å¹¶å°†å…¶å†™å…¥ç£å¸¦ï¼Œä»ç¼–ç å­—ç¬¦ä¸²ä¸­æ¯æ¬¡è¯»å–ä¸€ä¸ªå­—ç¬¦ï¼Œå¹¶é‡‡å–ä»¥ä¸‹æ­¥éª¤ï¼š å¦‚æœæ‰€è¯»çš„å­—ç¬¦æ˜¯å­—æ¯ï¼Œåˆ™å°†è¯¥å­—æ¯å†™åœ¨ç£å¸¦ä¸Šã€‚å¦‚æœæ‰€è¯»çš„å­—ç¬¦æ˜¯æ•°å­—ï¼ˆä¾‹å¦‚ dï¼‰ï¼Œåˆ™æ•´ä¸ªå½“å‰ç£å¸¦æ€»å…±ä¼šè¢«é‡å¤å†™ d-1 æ¬¡ã€‚ç°åœ¨ï¼Œå¯¹äºç»™å®šçš„ç¼–ç å­—ç¬¦ä¸² S å’Œç´¢å¼• Kï¼ŒæŸ¥æ‰¾å¹¶è¿”å›è§£ç å­—ç¬¦ä¸²ä¸­çš„ç¬¬ K ä¸ªå­—æ¯ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šS = \"leet2code3\", K = 10 è¾“å‡ºï¼š\"o\" è§£é‡Šï¼š è§£ç åçš„å­—ç¬¦ä¸²ä¸º \"leetleetcodeleetleetcodeleetleetcode\"ã€‚ å­—ç¬¦ä¸²ä¸­çš„ç¬¬ 10 ä¸ªå­—æ¯æ˜¯ \"o\"ã€‚ ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šS = \"ha22\", K = 5 è¾“å‡ºï¼š\"h\" è§£é‡Šï¼š è§£ç åçš„å­—ç¬¦ä¸²ä¸º \"hahahaha\"ã€‚ç¬¬ 5 ä¸ªå­—æ¯æ˜¯ \"h\"ã€‚ ç¤ºä¾‹ 3ï¼š è¾“å…¥ï¼šS = \"a2345678999999999999999\", K = 1 è¾“å‡ºï¼š\"a\" è§£é‡Šï¼š è§£ç åçš„å­—ç¬¦ä¸²ä¸º \"a\" é‡å¤ 8301530446056247680 æ¬¡ã€‚ç¬¬ 1 ä¸ªå­—æ¯æ˜¯ \"a\"ã€‚ æç¤ºï¼š 2 &lt;= S.length &lt;= 100 S åªåŒ…å«å°å†™å­—æ¯ä¸æ•°å­— 2 åˆ° 9 ã€‚ S ä»¥å­—æ¯å¼€å¤´ã€‚ 1 &lt;= K &lt;= 10^9 è§£ç åçš„å­—ç¬¦ä¸²ä¿è¯å°‘äº 2^63 ä¸ªå­—æ¯ã€‚ 12345678910111213141516171819202122class Solution(object): def decodeAtIndex(self, S, K): &quot;&quot;&quot; :type S: str :type K: int :rtype: str &quot;&quot;&quot; sz = 0 for c in S: if c.isdigit(): sz *= int(c) else: sz += 1 for c in S[::-1]: K %= sz if K == 0 and c.isalpha(): return c if c.isdigit(): sz /= int(c) else: sz -= 1 907. å­æ•°ç»„çš„æœ€å°å€¼ä¹‹å’Œ [n]ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ Aï¼Œæ‰¾åˆ° min(B) çš„æ€»å’Œï¼Œå…¶ä¸­ B çš„èŒƒå›´ä¸º A çš„æ¯ä¸ªï¼ˆè¿ç»­ï¼‰å­æ•°ç»„ã€‚ ç”±äºç­”æ¡ˆå¯èƒ½å¾ˆå¤§ï¼Œå› æ­¤è¿”å›ç­”æ¡ˆæ¨¡ 10^9 + 7ã€‚ ç¤ºä¾‹ï¼š è¾“å…¥ï¼š[3,1,2,4] è¾“å‡ºï¼š17 è§£é‡Šï¼š å­æ•°ç»„ä¸º [3]ï¼Œ[1]ï¼Œ[2]ï¼Œ[4]ï¼Œ[3,1]ï¼Œ[1,2]ï¼Œ[2,4]ï¼Œ[3,1,2]ï¼Œ[1,2,4]ï¼Œ[3,1,2,4]ã€‚ æœ€å°å€¼ä¸º 3ï¼Œ1ï¼Œ2ï¼Œ4ï¼Œ1ï¼Œ1ï¼Œ2ï¼Œ1ï¼Œ1ï¼Œ1ï¼Œå’Œä¸º 17ã€‚ æç¤ºï¼š 1 &lt;= A &lt;= 30000 1 &lt;= A[i] &lt;= 30000 12345678910111213141516171819202122232425262728class Solution(object): def sumSubarrayMins(self, A): MOD = 10**9 + 7 N = len(A) # prev has i* - 1 in increasing order of A[i* - 1] # where i* is the answer to query j stack = [] prev = [None] * N for i in xrange(N): while stack and A[i] &lt;= A[stack[-1]]: stack.pop() prev[i] = stack[-1] if stack else -1 stack.append(i) # next has k* + 1 in increasing order of A[k* + 1] # where k* is the answer to query j stack = [] next_ = [None] * N for k in xrange(N-1, -1, -1): while stack and A[k] &lt; A[stack[-1]]: stack.pop() next_[k] = stack[-1] if stack else N stack.append(k) # Use prev/next array to count answer return sum((i - prev[i]) * (next_[i] - i) * A[i] for i in xrange(N)) % MOD 946. éªŒè¯æ ˆåºåˆ—ç»™å®š pushed å’Œ popped ä¸¤ä¸ªåºåˆ—ï¼Œæ¯ä¸ªåºåˆ—ä¸­çš„ å€¼éƒ½ä¸é‡å¤ï¼Œåªæœ‰å½“å®ƒä»¬å¯èƒ½æ˜¯åœ¨æœ€åˆç©ºæ ˆä¸Šè¿›è¡Œçš„æ¨å…¥ push å’Œå¼¹å‡º pop æ“ä½œåºåˆ—çš„ç»“æœæ—¶ï¼Œè¿”å› trueï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼špushed = [1,2,3,4,5], popped = [4,5,3,2,1] è¾“å‡ºï¼štrue è§£é‡Šï¼šæˆ‘ä»¬å¯ä»¥æŒ‰ä»¥ä¸‹é¡ºåºæ‰§è¡Œï¼š push(1), push(2), push(3), push(4), pop() -> 4, push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1 ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼špushed = [1,2,3,4,5], popped = [4,3,5,1,2] è¾“å‡ºï¼šfalse è§£é‡Šï¼š1 ä¸èƒ½åœ¨ 2 ä¹‹å‰å¼¹å‡ºã€‚ æç¤ºï¼š 0 &lt;= pushed.length == popped.length &lt;= 1000 0 &lt;= pushed[i], popped[i] &lt; 1000 pushed æ˜¯ popped çš„æ’åˆ—ã€‚ 1234567891011121314151617181920class Solution(object): def validateStackSequences(self, pushed, popped): &quot;&quot;&quot; :type pushed: List[int] :type popped: List[int] :rtype: bool &quot;&quot;&quot; stk = [] i, j = 0, 0 n = len(pushed) m = len(popped) if m != n : return False while i &lt; n: stk.append(pushed[i]) while stk and stk[-1] == popped[j]: j += 1 stk.pop(-1) i += 1 return len(stk) == 0 and j == n 1019. é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªæ›´å¤§èŠ‚ç‚¹ [n]ç»™å‡ºä¸€ä¸ªä»¥å¤´èŠ‚ç‚¹ head ä½œä¸ºç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„é“¾è¡¨ã€‚é“¾è¡¨ä¸­çš„èŠ‚ç‚¹åˆ†åˆ«ç¼–å·ä¸ºï¼šnode_1, node_2, node_3, â€¦ ã€‚ æ¯ä¸ªèŠ‚ç‚¹éƒ½å¯èƒ½æœ‰ä¸‹ä¸€ä¸ªæ›´å¤§å€¼ï¼ˆnext larger valueï¼‰ï¼šå¯¹äº node_iï¼Œå¦‚æœå…¶ next_larger(node_i) æ˜¯ node_j.valï¼Œé‚£ä¹ˆå°±æœ‰ j &gt; i ä¸” node_j.val &gt; node_i.valï¼Œè€Œ j æ˜¯å¯èƒ½çš„é€‰é¡¹ä¸­æœ€å°çš„é‚£ä¸ªã€‚å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„ jï¼Œé‚£ä¹ˆä¸‹ä¸€ä¸ªæ›´å¤§å€¼ä¸º 0 ã€‚ è¿”å›æ•´æ•°ç­”æ¡ˆæ•°ç»„ answerï¼Œå…¶ä¸­ answer[i] = next_larger(node_{i+1}) ã€‚ æ³¨æ„ï¼šåœ¨ä¸‹é¢çš„ç¤ºä¾‹ä¸­ï¼Œè¯¸å¦‚ [2,1,5] è¿™æ ·çš„è¾“å…¥ï¼ˆä¸æ˜¯è¾“å‡ºï¼‰æ˜¯é“¾è¡¨çš„åºåˆ—åŒ–è¡¨ç¤ºï¼Œå…¶å¤´èŠ‚ç‚¹çš„å€¼ä¸º 2ï¼Œç¬¬äºŒä¸ªèŠ‚ç‚¹å€¼ä¸º 1ï¼Œç¬¬ä¸‰ä¸ªèŠ‚ç‚¹å€¼ä¸º 5 ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼š[2,1,5] è¾“å‡ºï¼š[5,5,0] ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼š[2,7,4,3,5] è¾“å‡ºï¼š[7,0,5,5,0] ç¤ºä¾‹ 3ï¼š è¾“å…¥ï¼š[1,7,5,1,9,2,5,1] è¾“å‡ºï¼š[7,9,9,9,0,5,0,0] æç¤ºï¼š å¯¹äºé“¾è¡¨ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹ï¼Œ1 &lt;= node.val &lt;= 10^9 ç»™å®šåˆ—è¡¨çš„é•¿åº¦åœ¨ [0, 10000] èŒƒå›´å†… 1234567891011121314151617class Solution(object): def nextLargerNodes(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: List[int] &quot;&quot;&quot; nums = [] while head: nums.append(head.val) head = head.next res = [0] * len(nums) stk = [] for i, v in enumerate(nums): while stk and nums[stk[-1]] &lt; v: res[stk.pop()] = v stk.append(i) return res 1209. åˆ é™¤å­—ç¬¦ä¸²ä¸­çš„æ‰€æœ‰ç›¸é‚»é‡å¤é¡¹ IIç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œã€Œk å€é‡å¤é¡¹åˆ é™¤æ“ä½œã€å°†ä¼šä» s ä¸­é€‰æ‹© k ä¸ªç›¸é‚»ä¸”ç›¸ç­‰çš„å­—æ¯ï¼Œå¹¶åˆ é™¤å®ƒä»¬ï¼Œä½¿è¢«åˆ å»çš„å­—ç¬¦ä¸²çš„å·¦ä¾§å’Œå³ä¾§è¿åœ¨ä¸€èµ·ã€‚ ä½ éœ€è¦å¯¹ s é‡å¤è¿›è¡Œæ— é™æ¬¡è¿™æ ·çš„åˆ é™¤æ“ä½œï¼Œç›´åˆ°æ— æ³•ç»§ç»­ä¸ºæ­¢ã€‚ åœ¨æ‰§è¡Œå®Œæ‰€æœ‰åˆ é™¤æ“ä½œåï¼Œè¿”å›æœ€ç»ˆå¾—åˆ°çš„å­—ç¬¦ä¸²ã€‚ æœ¬é¢˜ç­”æ¡ˆä¿è¯å”¯ä¸€ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šs = \"abcd\", k = 2 è¾“å‡ºï¼š\"abcd\" è§£é‡Šï¼šæ²¡æœ‰è¦åˆ é™¤çš„å†…å®¹ã€‚ ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šs = \"deeedbbcccbdaa\", k = 3 è¾“å‡ºï¼š\"aa\" è§£é‡Šï¼š å…ˆåˆ é™¤ \"eee\" å’Œ \"ccc\"ï¼Œå¾—åˆ° \"ddbbbdaa\" å†åˆ é™¤ \"bbb\"ï¼Œå¾—åˆ° \"dddaa\" æœ€ååˆ é™¤ \"ddd\"ï¼Œå¾—åˆ° \"aa\" ç¤ºä¾‹ 3ï¼š è¾“å…¥ï¼šs = \"pbbcggttciiippooaais\", k = 2 è¾“å‡ºï¼š\"ps\" æç¤ºï¼š 1 &lt;= s.length &lt;= 10^5 2 &lt;= k &lt;= 10^4 s ä¸­åªå«æœ‰å°å†™è‹±æ–‡å­—æ¯ã€‚ 12345678910111213141516171819class Solution(object): def removeDuplicates(self, s, k): &quot;&quot;&quot; :type s: str :type k: int :rtype: str &quot;&quot;&quot; stk = [] for c in s: if stk and stk[-1][0] == c: stk[-1][1] += 1 if stk[-1][1] == k: stk.pop(-1) else: stk.append([c, 1]) res = &#x27;&#x27; for v, i in stk: res += i * v return res 1249. ç§»é™¤æ— æ•ˆçš„æ‹¬å· [n]ç»™ä½ ä¸€ä¸ªç”± â€˜(â€˜ã€â€™)â€™ å’Œå°å†™å­—æ¯ç»„æˆçš„å­—ç¬¦ä¸² sã€‚ ä½ éœ€è¦ä»å­—ç¬¦ä¸²ä¸­åˆ é™¤æœ€å°‘æ•°ç›®çš„ â€˜(â€˜ æˆ–è€… â€˜)â€™ ï¼ˆå¯ä»¥åˆ é™¤ä»»æ„ä½ç½®çš„æ‹¬å·)ï¼Œä½¿å¾—å‰©ä¸‹çš„ã€Œæ‹¬å·å­—ç¬¦ä¸²ã€æœ‰æ•ˆã€‚ è¯·è¿”å›ä»»æ„ä¸€ä¸ªåˆæ³•å­—ç¬¦ä¸²ã€‚ æœ‰æ•ˆã€Œæ‹¬å·å­—ç¬¦ä¸²ã€åº”å½“ç¬¦åˆä»¥ä¸‹ ä»»æ„ä¸€æ¡ è¦æ±‚ï¼š ç©ºå­—ç¬¦ä¸²æˆ–åªåŒ…å«å°å†™å­—æ¯çš„å­—ç¬¦ä¸² å¯ä»¥è¢«å†™ä½œ ABï¼ˆA è¿æ¥ Bï¼‰çš„å­—ç¬¦ä¸²ï¼Œå…¶ä¸­ A å’Œ B éƒ½æ˜¯æœ‰æ•ˆã€Œæ‹¬å·å­—ç¬¦ä¸²ã€ å¯ä»¥è¢«å†™ä½œ (A) çš„å­—ç¬¦ä¸²ï¼Œå…¶ä¸­ A æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ã€Œæ‹¬å·å­—ç¬¦ä¸²ã€ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šs = \"lee(t(c)o)de)\" è¾“å‡ºï¼š\"lee(t(c)o)de\" è§£é‡Šï¼š\"lee(t(co)de)\" , \"lee(t(c)ode)\" ä¹Ÿæ˜¯ä¸€ä¸ªå¯è¡Œç­”æ¡ˆã€‚ ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šs = \"a)b(c)d\" è¾“å‡ºï¼š\"ab(c)d\" ç¤ºä¾‹ 3ï¼š è¾“å…¥ï¼šs = \"))((\" è¾“å‡ºï¼š\"\" è§£é‡Šï¼šç©ºå­—ç¬¦ä¸²ä¹Ÿæ˜¯æœ‰æ•ˆçš„ ç¤ºä¾‹ 4ï¼š è¾“å…¥ï¼šs = \"(a(b(c)d)\" è¾“å‡ºï¼š\"a(b(c)d)\" æç¤ºï¼š 1 &lt;= s.length &lt;= 10^5 s[i] å¯èƒ½æ˜¯ â€˜(â€˜ã€â€™)â€™ æˆ–è‹±æ–‡å°å†™å­—æ¯ 12345678910111213141516171819202122class Solution(object): def minRemoveToMakeValid(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; stk = [] for i, v in enumerate(s): if v == &#x27;(&#x27;: stk.append((i, v)) elif v == &#x27;)&#x27;: if stk and stk[-1][1] == &#x27;(&#x27;: stk.pop(-1) else: stk.append((i, v)) res, j = &quot;&quot;, 0 for i, v in enumerate(s): if j &lt; len(stk) and i == stk[j][0]: j += 1 else: res += v return res","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCodeä¹‹å“ˆå¸Œè¡¨","slug":"LeetCode-å“ˆå¸Œè¡¨","date":"2020-11-27T14:05:54.000Z","updated":"2020-12-27T05:06:16.073Z","comments":false,"path":"posts/2d8b42bd.html","link":"","permalink":"https://leel0330.github.io/posts/2d8b42bd.html","excerpt":"å“ˆå¸Œè¡¨çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚","text":"å“ˆå¸Œè¡¨çš„é¢˜ç›®æ±‡æ€»åœ¨æ­¤äº†ï¼Œæ¬¢è¿å¤§å®¶å…‰é¡¾ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ 202. å¿«ä¹æ•°ç¼–å†™ä¸€ä¸ªç®—æ³•æ¥åˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯ä¸æ˜¯â€œå¿«ä¹æ•°â€ã€‚ ä¸€ä¸ªâ€œå¿«ä¹æ•°â€å®šä¹‰ä¸ºï¼šå¯¹äºä¸€ä¸ªæ­£æ•´æ•°ï¼Œæ¯ä¸€æ¬¡å°†è¯¥æ•°æ›¿æ¢ä¸ºå®ƒæ¯ä¸ªä½ç½®ä¸Šçš„æ•°å­—çš„å¹³æ–¹å’Œï¼Œç„¶åé‡å¤è¿™ä¸ªè¿‡ç¨‹ç›´åˆ°è¿™ä¸ªæ•°å˜ä¸º 1ï¼Œä¹Ÿå¯èƒ½æ˜¯æ— é™å¾ªç¯ä½†å§‹ç»ˆå˜ä¸åˆ° 1ã€‚å¦‚æœå¯ä»¥å˜ä¸º 1ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°å°±æ˜¯å¿«ä¹æ•°ã€‚ ç¤ºä¾‹: è¾“å…¥: 19 è¾“å‡º: true è§£é‡Š: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 1234567891011121314class Solution(object): def isHappy(self, n): &quot;&quot;&quot; :type n: int :rtype: bool &quot;&quot;&quot; m = &#123;&#125; while True: n = str(sum([int(i) ** 2 for i in str(n)])) if n == &#x27;1&#x27;: return True if n in m: return False m[n] = True 290. å•è¯è§„å¾‹ç»™å®šä¸€ç§è§„å¾‹ pattern å’Œä¸€ä¸ªå­—ç¬¦ä¸² str ï¼Œåˆ¤æ–­ str æ˜¯å¦éµå¾ªç›¸åŒçš„è§„å¾‹ã€‚ è¿™é‡Œçš„ éµå¾ª æŒ‡å®Œå…¨åŒ¹é…ï¼Œä¾‹å¦‚ï¼Œ pattern é‡Œçš„æ¯ä¸ªå­—æ¯å’Œå­—ç¬¦ä¸² str ä¸­çš„æ¯ä¸ªéç©ºå•è¯ä¹‹é—´å­˜åœ¨ç€åŒå‘è¿æ¥çš„å¯¹åº”è§„å¾‹ã€‚ ç¤ºä¾‹1: è¾“å…¥: pattern = \"abba\", str = \"dog cat cat dog\" è¾“å‡º: true ç¤ºä¾‹ 2: è¾“å…¥:pattern = \"abba\", str = \"dog cat cat fish\" è¾“å‡º: false ç¤ºä¾‹ 3: è¾“å…¥: pattern = \"aaaa\", str = \"dog cat cat dog\" è¾“å‡º: false 123456789101112131415161718class Solution(object): def wordPattern(self, pattern, str): &quot;&quot;&quot; :type pattern: str :type str: str :rtype: bool &quot;&quot;&quot; return self.helper(pattern) == self.helper(str.split(&#x27; &#x27;)) def helper(self, s_list): m = &#123;&#125; res = [] for s in s_list: if s not in m: m[s] = len(m) + 1 res.append(m[s]) ss = &#x27;&#x27;.join([str(i) for i in res]) return ss 409. æœ€é•¿å›æ–‡ä¸²ç»™å®šä¸€ä¸ªåŒ…å«å¤§å†™å­—æ¯å’Œå°å†™å­—æ¯çš„å­—ç¬¦ä¸²ï¼Œæ‰¾åˆ°é€šè¿‡è¿™äº›å­—æ¯æ„é€ æˆçš„æœ€é•¿çš„å›æ–‡ä¸²ã€‚ åœ¨æ„é€ è¿‡ç¨‹ä¸­ï¼Œè¯·æ³¨æ„åŒºåˆ†å¤§å°å†™ã€‚æ¯”å¦‚ â€œAaâ€ ä¸èƒ½å½“åšä¸€ä¸ªå›æ–‡å­—ç¬¦ä¸²ã€‚ æ³¨æ„:å‡è®¾å­—ç¬¦ä¸²çš„é•¿åº¦ä¸ä¼šè¶…è¿‡ 1010ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: \"abccccdd\" è¾“å‡º: 7 è§£é‡Š: æˆ‘ä»¬å¯ä»¥æ„é€ çš„æœ€é•¿çš„å›æ–‡ä¸²æ˜¯\"dccaccd\", å®ƒçš„é•¿åº¦æ˜¯ 7ã€‚ 1234567891011121314151617181920212223class Solution(object): def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; m = &#123;&#125; for c in s: if c in m: m[c] += 1 else: m[c] = 1 max_odd = 0 res = 0 has_odd = False for k, v in m.iteritems(): if v % 2 == 0: res += v else: res += v - 1 if not has_odd: has_odd = True return res + 1 if has_odd else res 438. æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—æ¯å¼‚ä½è¯ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² s å’Œä¸€ä¸ªéç©ºå­—ç¬¦ä¸² pï¼Œæ‰¾åˆ° s ä¸­æ‰€æœ‰æ˜¯ p çš„å­—æ¯å¼‚ä½è¯çš„å­ä¸²ï¼Œè¿”å›è¿™äº›å­ä¸²çš„èµ·å§‹ç´¢å¼•ã€‚ å­—ç¬¦ä¸²åªåŒ…å«å°å†™è‹±æ–‡å­—æ¯ï¼Œå¹¶ä¸”å­—ç¬¦ä¸² s å’Œ p çš„é•¿åº¦éƒ½ä¸è¶…è¿‡ 20100ã€‚ è¯´æ˜ï¼š å­—æ¯å¼‚ä½è¯æŒ‡å­—æ¯ç›¸åŒï¼Œä½†æ’åˆ—ä¸åŒçš„å­—ç¬¦ä¸²ã€‚ ä¸è€ƒè™‘ç­”æ¡ˆè¾“å‡ºçš„é¡ºåºã€‚ ç¤ºä¾‹ 1: è¾“å…¥: s: \"cbaebabacd\" p: \"abc\" è¾“å‡º: [0, 6] è§£é‡Š: èµ·å§‹ç´¢å¼•ç­‰äº 0 çš„å­ä¸²æ˜¯ \"cba\", å®ƒæ˜¯ \"abc\" çš„å­—æ¯å¼‚ä½è¯ã€‚ èµ·å§‹ç´¢å¼•ç­‰äº 6 çš„å­ä¸²æ˜¯ \"bac\", å®ƒæ˜¯ \"abc\" çš„å­—æ¯å¼‚ä½è¯ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: s: \"abab\" p: \"ab\" è¾“å‡º: [0, 1, 2] è§£é‡Š: èµ·å§‹ç´¢å¼•ç­‰äº 0 çš„å­ä¸²æ˜¯ \"ab\", å®ƒæ˜¯ \"ab\" çš„å­—æ¯å¼‚ä½è¯ã€‚ èµ·å§‹ç´¢å¼•ç­‰äº 1 çš„å­ä¸²æ˜¯ \"ba\", å®ƒæ˜¯ \"ab\" çš„å­—æ¯å¼‚ä½è¯ã€‚ èµ·å§‹ç´¢å¼•ç­‰äº 2 çš„å­ä¸²æ˜¯ \"ab\", å®ƒæ˜¯ \"ab\" çš„å­—æ¯å¼‚ä½è¯ã€‚ PythonJava123456789101112131415161718192021222324252627282930313233class Solution(object): def findAnagrams(self, s, p): &quot;&quot;&quot; :type s: str :type p: str :rtype: List[int] &quot;&quot;&quot; ls, lp = len(s), len(p) cp = self.get_counter(p) cs = &#123;&#125; ans = [] for i in range(ls): if s[i] in cs: cs[s[i]] += 1 else: cs[s[i]] = 1 if i &gt;= lp: cs[s[i - lp]] -= 1 # startå‰ä¸€ä¸ªå…ƒç´  if cs[s[i - lp]] == 0: del cs[s[i - lp]] if cs == cp: # å› ä¸ºend - start + 1 = len; æ‰€ä»¥ start = end + 1 - len ans.append(i - lp + 1) return ans def get_counter(self, s): m = &#123;&#125; for c in s: if c in m: m[c] += 1 else: m[c] = 1 return m12345678910111213141516171819202122232425262728293031323334class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(s.isEmpty() || p.length() &gt; s.length()) &#123; return res; &#125; int[] hashS = new int[256]; int[] hashP = new int[256]; for (int i = 0; i &lt; p.length(); i++) &#123; hashP[p.charAt(i)]++; hashS[s.charAt(i)]++; &#125; if (isSameDict(hashS, hashP)) &#123; res.add(0); &#125; for (int i = p.length(); i &lt; s.length(); i++) &#123; hashS[s.charAt(i - p.length())]--; hashS[s.charAt(i)]++; if (isSameDict(hashS, hashP)) &#123; res.add(i + 1 - p.length()); &#125; &#125; return res; &#125; private boolean isSameDict(int[] hashS, int[] hashP) &#123; for (int i = 0; i &lt; hashS.length; i++) &#123; if (hashP[i] != hashS[i]) &#123; return false; &#125; &#125; return true; &#125;&#125; 454. å››æ•°ç›¸åŠ  II[n]ç»™å®šå››ä¸ªåŒ…å«æ•´æ•°çš„æ•°ç»„åˆ—è¡¨ A , B , C , D ,è®¡ç®—æœ‰å¤šå°‘ä¸ªå…ƒç»„ (i, j, k, l) ï¼Œä½¿å¾— A[i] + B[j] + C[k] + D[l] = 0ã€‚ ä¸ºäº†ä½¿é—®é¢˜ç®€å•åŒ–ï¼Œæ‰€æœ‰çš„ A, B, C, D å…·æœ‰ç›¸åŒçš„é•¿åº¦ Nï¼Œä¸” 0 â‰¤ N â‰¤ 500 ã€‚æ‰€æœ‰æ•´æ•°çš„èŒƒå›´åœ¨ -228 åˆ° 228 - 1 ä¹‹é—´ï¼Œæœ€ç»ˆç»“æœä¸ä¼šè¶…è¿‡ 231 - 1 ã€‚ ä¾‹å¦‚: è¾“å…¥: A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2] è¾“å‡º: 2 è§£é‡Š: ä¸¤ä¸ªå…ƒç»„å¦‚ä¸‹: 1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 PythonJava123456789101112131415161718192021222324class Solution(object): def fourSumCount(self, A, B, C, D): &quot;&quot;&quot; :type A: List[int] :type B: List[int] :type C: List[int] :type D: List[int] :rtype: int &quot;&quot;&quot; m = &#123;&#125; for i in xrange(len(A)): for j in xrange(len(B)): tmp = A[i] + B[j] if tmp in m: m[tmp] += 1 else: m[tmp] = 1 res = 0 for i in xrange(len(C)): for j in xrange(len(D)): tmp = 0 - (C[i] + D[j]) if tmp in m: res += m[tmp] return res123456789101112131415161718192021class Solution &#123; public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123; int res = 0; Map&lt;Integer, Integer&gt; counter = new HashMap&lt;&gt;(); for (int i = 0; i &lt; A.length; i++) &#123; for (int j = 0; j &lt; B.length; j++) &#123; int tmp = A[i] + B[j]; counter.put(tmp, counter.getOrDefault(tmp, 0) + 1); &#125; &#125; for (int i = 0; i &lt; C.length; i++) &#123; for (int j = 0; j &lt; D.length; j++) &#123; int tmp = C[i] + D[j]; if (counter.containsKey(-tmp)) &#123; res += counter.get(-tmp); &#125; &#125; &#125; return res; &#125;&#125; 525. è¿ç»­æ•°ç»„ç»™å®šä¸€ä¸ªäºŒè¿›åˆ¶æ•°ç»„, æ‰¾åˆ°å«æœ‰ç›¸åŒæ•°é‡çš„ 0 å’Œ 1 çš„æœ€é•¿è¿ç»­å­æ•°ç»„ï¼ˆçš„é•¿åº¦ï¼‰ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [0,1] è¾“å‡º: 2 è¯´æ˜: [0, 1] æ˜¯å…·æœ‰ç›¸åŒæ•°é‡0å’Œ1çš„æœ€é•¿è¿ç»­å­æ•°ç»„ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: [0,1,0] è¾“å‡º: 2 è¯´æ˜: [0, 1] (æˆ– [1, 0]) æ˜¯å…·æœ‰ç›¸åŒæ•°é‡0å’Œ1çš„æœ€é•¿è¿ç»­å­æ•°ç»„ã€‚ æ³¨æ„: ç»™å®šçš„äºŒè¿›åˆ¶æ•°ç»„çš„é•¿åº¦ä¸ä¼šè¶…è¿‡50000ã€‚ 123456789101112131415class Solution(object): def findMaxLength(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; m = &#123;0:-1&#125; res, cnt = 0, 0 for i, n in enumerate(nums): cnt = cnt + 1 if n == 1 else cnt - 1 if cnt in m: res = max(res, i - m[cnt]) else: m[cnt] = i return res 560. å’Œä¸ºKçš„å­æ•°ç»„ [n]ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„å’Œä¸€ä¸ªæ•´æ•° kï¼Œä½ éœ€è¦æ‰¾åˆ°è¯¥æ•°ç»„ä¸­å’Œä¸º k çš„è¿ç»­çš„å­æ•°ç»„çš„ä¸ªæ•°ã€‚ ç¤ºä¾‹ 1 : è¾“å…¥:nums = [1,1,1], k = 2 è¾“å‡º: 2 , [1,1] ä¸ [1,1] ä¸ºä¸¤ç§ä¸åŒçš„æƒ…å†µã€‚ è¯´æ˜ : æ•°ç»„çš„é•¿åº¦ä¸º [1, 20,000]ã€‚ æ•°ç»„ä¸­å…ƒç´ çš„èŒƒå›´æ˜¯ [-1000, 1000] ï¼Œä¸”æ•´æ•° k çš„èŒƒå›´æ˜¯ [-1e7, 1e7]ã€‚ 1234567891011121314151617class Solution(object): def subarraySum(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; res, cur_sum, pre_sum_map = 0, 0, &#123;0:1&#125; for n in nums: cur_sum += n if cur_sum - k in pre_sum_map: res += pre_sum_map[cur_sum - k] if cur_sum in pre_sum_map: pre_sum_map[cur_sum] += 1 else: pre_sum_map[cur_sum] = 1 return res 594. æœ€é•¿å’Œè°å­åºåˆ— [n]å’Œè°æ•°ç»„æ˜¯æŒ‡ä¸€ä¸ªæ•°ç»„é‡Œå…ƒç´ çš„æœ€å¤§å€¼å’Œæœ€å°å€¼ä¹‹é—´çš„å·®åˆ«æ­£å¥½æ˜¯1ã€‚ ç°åœ¨ï¼Œç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œä½ éœ€è¦åœ¨æ‰€æœ‰å¯èƒ½çš„å­åºåˆ—ä¸­æ‰¾åˆ°æœ€é•¿çš„å’Œè°å­åºåˆ—çš„é•¿åº¦ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [1,3,2,2,5,2,3,7] è¾“å‡º: 5 åŸå› : æœ€é•¿çš„å’Œè°æ•°ç»„æ˜¯ï¼š[3,2,2,2,3]. è¯´æ˜: è¾“å…¥çš„æ•°ç»„é•¿åº¦æœ€å¤§ä¸è¶…è¿‡20,000. 1234567891011121314151617181920class Solution(object): def findLHS(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; m = &#123;&#125; for n in nums: if n in m: m[n] += 1 else: m[n] = 1 res = 0 for n in set(nums): a, b = n - 1, n + 1 if a in m: res = max(res, m[a] + m[n]) if b in m: res = max(res, m[b] + m[n]) return res 648. å•è¯æ›¿æ¢ [n]åœ¨è‹±è¯­ä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªå«åš è¯æ ¹(root)çš„æ¦‚å¿µï¼Œå®ƒå¯ä»¥è·Ÿç€å…¶ä»–ä¸€äº›è¯ç»„æˆå¦ä¸€ä¸ªè¾ƒé•¿çš„å•è¯â€”â€”æˆ‘ä»¬ç§°è¿™ä¸ªè¯ä¸º ç»§æ‰¿è¯(successor)ã€‚ä¾‹å¦‚ï¼Œè¯æ ¹anï¼Œè·Ÿéšç€å•è¯ other(å…¶ä»–)ï¼Œå¯ä»¥å½¢æˆæ–°çš„å•è¯ another(å¦ä¸€ä¸ª)ã€‚ ç°åœ¨ï¼Œç»™å®šä¸€ä¸ªç”±è®¸å¤šè¯æ ¹ç»„æˆçš„è¯å…¸å’Œä¸€ä¸ªå¥å­ã€‚ä½ éœ€è¦å°†å¥å­ä¸­çš„æ‰€æœ‰ç»§æ‰¿è¯ç”¨è¯æ ¹æ›¿æ¢æ‰ã€‚å¦‚æœç»§æ‰¿è¯æœ‰è®¸å¤šå¯ä»¥å½¢æˆå®ƒçš„è¯æ ¹ï¼Œåˆ™ç”¨æœ€çŸ­çš„è¯æ ¹æ›¿æ¢å®ƒã€‚ ä½ éœ€è¦è¾“å‡ºæ›¿æ¢ä¹‹åçš„å¥å­ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: dict(è¯å…¸) = [\"cat\", \"bat\", \"rat\"] sentence(å¥å­) = \"the cattle was rattled by the battery\" è¾“å‡º: \"the cat was rat by the bat\" æ³¨: è¾“å…¥åªåŒ…å«å°å†™å­—æ¯ã€‚ 1 &lt;= å­—å…¸å•è¯æ•° &lt;=1000 1 &lt;= å¥ä¸­è¯è¯­æ•° &lt;= 1000 1 &lt;= è¯æ ¹é•¿åº¦ &lt;= 100 1 &lt;= å¥ä¸­è¯è¯­é•¿åº¦ &lt;= 1000 12345678910111213141516171819class Solution(object): def replaceWords(self, words, sentence): &quot;&quot;&quot; :type words: List[str] :type sentence: str :rtype: str &quot;&quot;&quot; res = [] wordset = set(words) for word in sentence.split(&#x27; &#x27;): res.append(self.replaceWord(word, wordset)) return &#x27; &#x27;.join(res) def replaceWord(self, word, wordset): for i in xrange(len(word)): if word[:i] in wordset: return word[:i] return word 720. è¯å…¸ä¸­æœ€é•¿çš„å•è¯ [n]ç»™å‡ºä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„wordsç»„æˆçš„ä¸€æœ¬è‹±è¯­è¯å…¸ã€‚ä»ä¸­æ‰¾å‡ºæœ€é•¿çš„ä¸€ä¸ªå•è¯ï¼Œè¯¥å•è¯æ˜¯ç”±wordsè¯å…¸ä¸­å…¶ä»–å•è¯é€æ­¥æ·»åŠ ä¸€ä¸ªå­—æ¯ç»„æˆã€‚è‹¥å…¶ä¸­æœ‰å¤šä¸ªå¯è¡Œçš„ç­”æ¡ˆï¼Œåˆ™è¿”å›ç­”æ¡ˆä¸­å­—å…¸åºæœ€å°çš„å•è¯ã€‚ è‹¥æ— ç­”æ¡ˆï¼Œåˆ™è¿”å›ç©ºå­—ç¬¦ä¸²ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: words = [\"w\",\"wo\",\"wor\",\"worl\", \"world\"] è¾“å‡º: \"world\" è§£é‡Š: å•è¯\"world\"å¯ç”±\"w\", \"wo\", \"wor\", å’Œ \"worl\"æ·»åŠ ä¸€ä¸ªå­—æ¯ç»„æˆã€‚ ç¤ºä¾‹ 2: è¾“å…¥: words = [\"a\", \"banana\", \"app\", \"appl\", \"ap\", \"apply\", \"apple\"] è¾“å‡º: \"apple\" è§£é‡Š: \"apply\"å’Œ\"apple\"éƒ½èƒ½ç”±è¯å…¸ä¸­çš„å•è¯ç»„æˆã€‚ä½†æ˜¯\"apple\"å¾—å­—å…¸åºå°äº\"apply\"ã€‚ æ³¨æ„: æ‰€æœ‰è¾“å…¥çš„å­—ç¬¦ä¸²éƒ½åªåŒ…å«å°å†™å­—æ¯ã€‚ wordsæ•°ç»„é•¿åº¦èŒƒå›´ä¸º[1,1000]ã€‚ words[i]çš„é•¿åº¦èŒƒå›´ä¸º[1,30]ã€‚ 123456789101112131415class Solution(object): def longestWord(self, words): &quot;&quot;&quot; :type words: List[str] :rtype: str &quot;&quot;&quot; words = sorted(words) word_set = set([&#x27;&#x27;])# å·§å¦™ä¹‹å¤„ res = &#x27;&#x27; for word in words: if word[:-1] in word_set: word_set.add(word) if len(word) &gt; len(res): res = word return res","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"},{"name":"Tech","slug":"Tech","permalink":"https://leel0330.github.io/categories/Tech/"},{"name":"Book","slug":"Book","permalink":"https://leel0330.github.io/categories/Book/"}],"tags":[]}