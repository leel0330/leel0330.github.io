{"meta":{"title":"PingCoder","subtitle":"","description":"less is more","author":"PingCoder","url":"https://leel0330.github.io","root":"/"},"pages":[{"title":"","date":"2020-11-27T13:37:29.000Z","updated":"2020-12-26T07:21:26.332Z","comments":false,"path":"about/index.html","permalink":"https://leel0330.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-27T13:37:44.000Z","updated":"2020-11-27T13:38:19.224Z","comments":true,"path":"categories/index.html","permalink":"https://leel0330.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-12-26T03:48:15.000Z","updated":"2020-12-26T07:21:18.683Z","comments":false,"path":"friends/index.html","permalink":"https://leel0330.github.io/friends/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-27T13:40:50.000Z","updated":"2020-11-27T13:41:07.414Z","comments":true,"path":"tags/index.html","permalink":"https://leel0330.github.io/tags/index.html","excerpt":"","text":""},{"title":"动态","date":"2020-12-13T14:45:30.000Z","updated":"2020-12-26T07:21:09.194Z","comments":false,"path":"timeline/index.html","permalink":"https://leel0330.github.io/timeline/index.html","excerpt":"","text":"2020年 12月26日 一个阳光灿烂的下午 小时候喜欢Jerry的聪明，长大了才发现Tom的“全能”才更惹人喜爱。 12月25日 圣诞节晚上 之前博客用的Next主题，可是发现网上用这个主题的人太多了。。。虽然Next简洁大方，但还是有点太简洁了，索性今天花了点时间更新主题到volantis了。volantis可以支持我之前md的语法，几乎不需要修改，这点对我还是挺吸引的，现在的博客相较之前，看起来确实更美观了~ 12月20日 周日面试了字节，项目经历没有答好，自己对以前做的项目思考还不够，看来这块需要加强。面试官出了一道单调栈的算法题(下来搜了一下才知道是单调栈)打算劝退吧，我自己都没想到居然做出来了。可惜没什么用了诶(服了我自己，算法题没做出来的时候前面答的好，算法题做出来了前面却答不好，总是二缺一)，前面的问题回答的不太好，给面试官留下了不好的印象，看来算法和项目得两手抓，希望自己早日能面上大厂，只能祝自己以后好运了。 12月13日 今天开始写一些简单的文字，来记录一下当天的心情。第一天，不知道写什么，那开始按照学习编程语言的惯例，写下大大的Hello World!哆啦A梦祝我好运连连"}],"posts":[{"title":"牛客题霸-名企高频面试题","slug":"牛客题霸-名企高频面试题","date":"2020-12-22T13:46:09.000Z","updated":"2020-12-26T07:22:16.499Z","comments":false,"path":"posts/1369037266.html","link":"","permalink":"https://leel0330.github.io/posts/1369037266.html","excerpt":"终于把牛客题霸-名企高频面试题刷完了，在这里汇总一下。","text":"终于把牛客题霸-名企高频面试题刷完了，在这里汇总一下。 NC21. 链表内指定区间反转将一个链表 m 位置到 n 位置之间的区间反转，要求时间复杂度，空间复杂度。 示例1 输入: {1,2,3,4,5},2,4 返回值: {1,4,3,2,5} 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; // write code here ListNode *dummy = new ListNode(-1); dummy-&gt;next = head; ListNode *p = dummy, *prev = nullptr; ListNode *q = dummy, *next = nullptr; for(int i = 0;i &lt; m; i++) &#123; prev = p; p = p-&gt;next; &#125; for(int i = 0; i &lt; n; i++) &#123; q = q-&gt;next; &#125; next = q-&gt;next; pair&lt;ListNode*, ListNode*&gt; res = reverse(prev, p, next); prev-&gt;next = res.first; res.second-&gt;next = next; head = dummy-&gt;next; dummy-&gt;next = nullptr; delete dummy; return head; &#125; pair&lt;ListNode*, ListNode*&gt; reverse(ListNode *prev, ListNode *head, ListNode *tail) &#123; ListNode *p = head, *q = prev; while(p != tail) &#123; ListNode *nextNode = p-&gt;next; p-&gt;next = q; q = p; p = nextNode; &#125; pair&lt;ListNode*, ListNode*&gt; res; res.first = q; res.second = prev-&gt;next; return res; &#125;&#125;; NC24. 删除有序链表中重复出现的元素给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。例如：给出的链表为1→2→3→3→4→4→5, 返回1→2→5.给出的链表为1→1→1→2→3, 返回2→3. PythonC++1234567891011121314151617181920212223242526class Solution: def deleteDuplicates(self , head): # write code here if not head or head.next is None: return head dummy = ListNode(-1) dummy.next = head p = dummy q = head while q: cur = q cur_v = q.val cnt = 1 while cur.next and cur.next.val == cur_v: cur = cur.next cnt += 1 if cnt == 1: p.next = cur q = cur.next p = cur else: p.next = cur.next q = cur.next p = dummy.next dummy.next = None return p1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: /** * * @param head ListNode类 * @return ListNode类 */ ListNode* deleteDuplicates(ListNode* head) &#123; // write code here if(head == nullptr || head-&gt;next == nullptr) &#123; return head; &#125; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode *p = dummy, *q = head; while(q) &#123; ListNode *cur = q; int curVal = cur-&gt;val; int cnt = 1; while(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == curVal) &#123; cnt += 1; cur = cur-&gt;next; &#125; if(cnt &gt; 1) &#123; p-&gt;next = cur-&gt;next; q = cur-&gt;next; &#125;else &#123; p-&gt;next = cur; q = cur-&gt;next; p = cur; &#125; &#125; p = dummy-&gt;next; dummy-&gt;next = nullptr; delete dummy; return p; &#125;&#125;; NC35. 最小编辑代价 [n]给定两个字符串str1和str2，再给定三个整数ic，dc和rc，分别代表插入、删除和替换一个字符的代价，请输出将str1编辑成str2的最小代价。 示例1 输入: \"abc\",\"adc\",5,3,2 返回值: 2 示例2 输入: \"abc\",\"adc\",5,3,100 返回值: 8 1234567891011121314151617181920212223242526272829public class Solution &#123; public int minEditCost (String str1, String str2, int ic, int dc, int rc) &#123; // write code here int m = str1.length(); int n = str2.length(); int[][] dp = new int[m+1][n+1]; for(int i = 1; i &lt;= m; i++) &#123; dp[i][0] = i*dc; &#125; for(int j = 1; j &lt;= n; j++) &#123; dp[0][j] = j*ic; &#125; for(int i = 1; i &lt;= m; i++) &#123; char c1 = str1.charAt(i-1); for(int j = 1; j &lt;= n; j++) &#123; char c2 = str2.charAt(j-1); if(c1 == c2) &#123; dp[i][j] = dp[i-1][j-1]; &#125; else &#123; int insert = dp[i][j-1] + ic; int delete = dp[i-1][j] + dc; int replace = dp[i-1][j-1] + rc; dp[i][j] = Math.min(replace, Math.min(insert, delete)); &#125; &#125; &#125; return dp[m][n]; &#125;&#125; NC44. 通配符匹配 [n]请实现支持’?’and’*‘.的通配符模式匹配。‘?’ 可以匹配任何单个字符。‘*‘ 可以匹配任何字符序列（包括空序列）。 12345678910111213141516171819202122class Solution: def isMatch(self , s , p ): # write code here i, j = 0, 0 backi, backj = -1, -1 while i &lt; len(s): if j &lt; len(p) and (s[i] == p[j] or p[j] == &#x27;?&#x27;): i += 1 j += 1 elif j &lt; len(p) and p[j] == &#x27;*&#x27;: backi = i backj = j j += 1 elif backj != -1: i = backi + 1 j = backj + 1 backi = i else: return False while j &lt; len(p) and p[j] == &#x27;*&#x27;: j += 1 return j == len(p) NC49. 最长的括号子串给出一个仅包含字符’(‘和’)’的字符串，计算最长的格式正确的括号子串的长度。对于字符串”(()”来说，最长的格式正确的子串是”()”，长度为2.再举一个例子：对于字符串”)()())”,来说，最长的格式正确的子串是”()()”，长度为4. 输入: \"(()\" 返回值: 2 12345678910111213141516171819202122class Solution: def longestValidParentheses(self , s ): # write code here s_len = len(s) if s_len &lt; 1: return 0 stk = [] max_len = 0 last = -1 for i in xrange(s_len): if s[i] == &#x27;(&#x27;: stk.append(i) else: if len(stk) == 0: last = i else: stk.pop(-1) if len(stk) == 0: max_len = max(max_len, i - last) else: max_len = max(max_len, i - stk[-1]) return max_len NC50. 链表中的节点每k个一组翻转 [n]将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样你不能更改节点中的值，只能更改节点本身。要求空间复杂度 O(1)例如：给定的链表是1→2→3→4→5对于 k=2, 你应该返回 2→1→4→3→5对于 k=3, 你应该返回 3→2→1→4→5 1234567891011121314151617181920212223242526272829303132class Solution: def reverse(self, head, tail): prev = tail.next p = head while prev != tail: nex = p.next p.next = prev prev = p p = nex return tail, head def reverseKGroup(self, head, k): dummy = ListNode(-1) dummy.next = head pre = dummy while head: tail = pre # 查看剩余部分长度是否大于等于 k for i in range(k): tail = tail.next if not tail: return dummy.next nex = tail.next head, tail = self.reverse(head, tail) # 把子链表重新接回原链表 pre.next = head tail.next = nex pre = tail head = tail.next return dummy.next NC57. 反转数字将给出的32位整数x翻转。例1:x=123，返回321。例2:x=-123，返回-321。 你有注意到翻转后的整数可能溢出吗？因为给出的是32位整数，则其数值范围为[−2^{31}, 2^{31} − 1]。翻转可能会导致溢出，如果反转后的结果会溢出就返回 0。 输入: -123 返回值: -321 1234567891011121314151617class Solution: def reverse(self , x ): # write code here INT_MIN = -(1 &lt;&lt; 31) INT_MAX = (1 &lt;&lt; 31) - 1 sign = x &lt; 0 x = abs(x) res = 0 while x: v = x % 10 x = x // 10 if res &gt; INT_MAX / 10 or (res == INT_MAX / 10 and v &gt; 7): return 0 if sign and (-res &lt; INT_MIN / 10 or (-res == INT_MIN / 10 and v &lt; -8)): return 0 res = res * 10 + v return res if not sign else -res NC62. 平衡二叉树输入一棵二叉树，判断该二叉树是否是平衡二叉树。 在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树。 平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 输入: {1,2,3,4,5,6,7} 返回值: true 123456789101112131415161718class Solution: def IsBalanced_Solution(self, pRoot): # write code here return self.helper(pRoot) != -1 def helper(self, root): if not root: return 0 left = self.helper(root.left) if left == -1: return -1 right = self.helper(root.right) if right == -1: return -1 v = abs(left - right) if v &gt; 1: return -1 return max(left, right) + 1 NC64. 二叉搜索树与双向链表输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 123456789101112131415161718192021222324class Solution: def __init__(self): self.last_node = None def Convert(self, pRootOfTree): # write code here if not pRootOfTree: return pRootOfTree self.last_node = None self.helper(pRootOfTree) while pRootOfTree.left: pRootOfTree = pRootOfTree.left return pRootOfTree def helper(self, root): if not root: return if root.left: self.helper(root.left) root.left = self.last_node if self.last_node: self.last_node.right = root self.last_node = root if root.right: self.helper(root.right) NC75. 数组中只出现一次的数字一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 12345678910111213141516171819202122class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): # write code here x = 0 for n in array: x ^= n idx = 0 while x &amp; 1 == 0: x &gt;&gt;= 1 idx += 1 n1, n2 = 0, 0 for n in array: if self.f(n, idx): n1 ^= n else: n2 ^= n return [n1, n2] def f(self, n, idx): n &gt;&gt;= idx return(n &amp; 1) == 1 NC82. 滑动窗口的最大值给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。窗口大于数组长度的时候，返回空 示例1 输入: [2,3,4,2,6,2,5,1],3 返回值: [4,4,6,6,6,5] 12345678910111213141516class Solution: def maxInWindows(self, nums, size): # write code here queue = [] if not size: return queue res = [] for i, v in enumerate(nums): while queue and queue[0] &lt;= i - size: queue.pop(0) while queue and v &gt; nums[queue[-1]]: queue.pop(-1) queue.append(i) if i &gt;= size - 1: res.append(nums[queue[0]]) return res NC88. 寻找第K大有一个整数数组，请你根据快速排序的思路，找出数组中第K大的数。 给定一个整数数组a,同时给定它的大小n和要找的K(K在1到n之间)，请返回第K大的数，保证答案存在。 示例1 输入: [1,3,5,2,2],5,3 返回值: 2 12345678910111213141516171819202122232425class Finder: def findKth(self, a, n, K): # write code here return self.helper(a, 0, n - 1, K) def helper(self, a, left, right, K): idx = self.paritition(a, left, right) if idx == K - 1: return a[idx] elif idx &lt; K - 1: return self.helper(a, idx + 1, right, K) else: return self.helper(a, left, idx - 1, K) def paritition(self, a, low, high): pivot = a[low] while low &lt; high: while low &lt; high and a[high] &lt;= pivot: high -= 1 a[low] = a[high] while low &lt; high and a[low] &gt;= pivot: low += 1 a[high] = a[low] a[low] = pivot return low NC91. 最长递增子序列 [n]给定数组arr，设长度为n，输出arr的最长递增子序列。（如果有多个答案，请输出其中字典序最小的）。 示例1 输入: [2,1,5,3,6,4,8,9,7] 返回值: [1,3,4,8,9] 示例2 输入: [1,2,8,6,4] 返回值: [1,2,4] 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;int&gt; LIS(vector&lt;int&gt;&amp; arr) &#123; // write code here // 第一步：利用贪心+二分求最长递增子序列长度 vector&lt;int&gt; res; vector&lt;int&gt; maxLen; if (arr.size() &lt; 1) return res; res.emplace_back(arr[0]); // 注：emplace_back(val)作用同push_back，效率更高 maxLen.emplace_back(1); for (int i = 1; i &lt; arr.size(); ++i) &#123; if (arr[i] &gt; res.back()) &#123; res.emplace_back(arr[i]); maxLen.emplace_back(res.size()); &#125; else &#123; // lower_bound(begin, end, val)包含在&lt;algorithm&gt;中 // 它的作用是返回有序数组begin..end中第一个大于等于val的元素的迭代器 int pos = lower_bound(res.begin(), res.end(), arr[i]) - res.begin(); res[pos] = arr[i]; maxLen.emplace_back(pos+1); &#125; &#125; // 第二步：填充最长递增子序列 for (int i = arr.size()-1, j = res.size(); j &gt; 0; --i) &#123; if (maxLen[i] == j) &#123; res[--j] = arr[i]; &#125; &#125; return res; &#125;&#125;; NC92. 最长公共子序列 [n]给定两个字符串str1和str2，输出连个字符串的最长公共子序列。如过最长公共子序列为空，则输出-1。 示例1 输入: \"1A2C3D4B56\",\"B1D23CA45B6A\" 返回值: \"123456\" 1234567891011121314151617181920212223242526272829class Solution &#123;public: string LCS(string s1, string s2) &#123; // write code here if(s1.size() == 0 || s2.size() == 0) return &quot;-1&quot;; int maxLen = 0, start = -1; vector&lt;int&gt; dp(s2.size() + 1, 0); for(int i = 1; i &lt;= s1.size(); ++i)&#123; int last = dp[0]; for(int j = 1; j &lt;= s2.size(); ++j)&#123; int tmp = dp[j]; if(s1[i - 1] == s2[j - 1])&#123; dp[j] = last + 1; &#125;else&#123; dp[j] = 0; &#125; last = tmp; if(maxLen &lt; dp[j])&#123; maxLen = dp[j]; start = i; &#125; &#125; &#125; if(maxLen == 0) return &quot;-1&quot;; return s1.substr(start-maxLen, maxLen); &#125;&#125;; NC108. 最大正方形给定一个由0和1组成的2维矩阵，返回该矩阵中最大的由1组成的正方形的面积 示例1 输入: [[1,0,1,0,0],[1,0,1,1,1],[1,1,1,1,1],[1,0,0,1,0]] 返回值: 4 12345678910111213141516171819202122232425262728class Solution &#123;public: int solve(vector&lt;vector&lt;char&gt; &gt;&amp; matrix) &#123; // write code here int maxEdge = 0; if(matrix.size() == 0 || matrix[0].size() == 0) &#123; return maxEdge; &#125; int rows = matrix.size(), cols = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(rows, vector&lt;int&gt;(cols, 0)); for(int i = 0; i &lt; rows; i++) &#123; for(int j = 0; j &lt; cols; j++) &#123; if(matrix[i][j] == &#x27;0&#x27;) &#123; dp[i][j] = 0; &#125;else &#123; if(i ==0 || j == 0) &#123; dp[i][j] = 1; &#125;else &#123; int temp = min(dp[i - 1][j - 1], dp[i][j - 1]); dp[i][j] = min(dp[i - 1][j], temp) + 1; &#125; &#125; maxEdge = max(maxEdge, dp[i][j]); &#125; &#125; return maxEdge * maxEdge; &#125;&#125;; NC116. 把数字翻译成字符串有一种将字母编码成数字的方式：’a’-&gt;1, ‘b-&gt;2’, … , ‘z-&gt;26’。 现在给一串数字，返回有多少种可能的译码结果 示例1 输入: \"12\" 返回值: 2 示例1 输入: \"31717126241541717\" 返回值: 192 123456789101112131415class Solution: def solve(self , nums ): # write code here n = len(nums) dp = [0 for _ in xrange(n + 1)] dp[0] = 1 dp[1] = 1 if nums[0] != &#x27;0&#x27; else 0 for i in xrange(2, n + 1): two = nums[i - 2: i] one = nums[i - 1:i] if 10 &lt;= int(two) &lt;= 26: dp[i] += dp[i - 2] if 1 &lt;= int(one) &lt;= 9: dp[i] += dp[i - 1] return dp[n] NC118. 数组中的逆序对在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 示例1 输入: [1,2,3,4,5,6,7,0] 返回值: 7 12345678910111213141516171819202122232425262728293031323334class Solution: def InversePairs(self, data): # write code here n = len(data) tmp = [0 for _ in xrange(n)] res = self.mergeSort(data, tmp, 0, n - 1) return res % 1000000007 def mergeSort(self, data, tmp, left, right): if left &gt;= right: return 0 mid = (left + right) // 2 res = self.mergeSort(data, tmp, left, mid) + \\ self.mergeSort(data, tmp, mid + 1, right) i, j = left, mid + 1 pos = left while i &lt;= mid and j &lt;= right: if data[i] &lt;= data[j]: tmp[pos] = data[i] i += 1 res += j - (mid + 1) else: tmp[pos] = data[j] j += 1 pos += 1 for k in xrange(i, mid + 1): tmp[pos] = data[k] pos += 1 res += j - (mid + 1) for k in xrange(j, right + 1): tmp[pos] = data[k] pos += 1 data[left: right + 1] = tmp[left: right + 1] return res NC122. 正则表达式匹配 [n]请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 示例1 输入: \"aaa\",\"a*a\" 返回值: true 1234567891011121314151617181920212223242526272829class Solution: # s, pattern都是字符串 def match(self, s, pattern): # write code here if not s and not pattern: return True s_len = len(s) p_len = len(pattern) dp = [[False for _ in xrange(p_len + 1)] for _ in xrange(s_len + 1)] dp[0][0] = True for i in xrange(s_len + 1): for j in xrange(1, p_len + 1): if pattern[j - 1] == &#x27;*&#x27;: dp[i][j] = dp[i][j - 2] if self.isOK(s, pattern, i, j - 1): dp[i][j] = dp[i][j] or dp[i - 1][j] else: if self.isOK(s, pattern, i, j): dp[i][j] = dp[i - 1][j - 1] return dp[s_len][p_len] def isOK(self, s, pattern, i, j): if i == 0: return False if pattern[j - 1] == &#x27;.&#x27;: return True return s[i - 1] == pattern[j - 1] NC126. 换钱的最少货币数 [n]给定数组arr，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个aim，代表要找的钱数，求组成aim的最少货币数。如果无解，请返回-1.【要求】时间复杂度O(n×aim)，空间复杂度O(n)。 示例1 输入: [5,2,3],20 返回值: 4 1234567891011class Solution: def minMoney(self, arr, aim): # write code here INT_MAX = (1 &lt;&lt; 31) - 1 dp = [INT_MAX for _ in xrange(aim + 1)] dp[0] = 0 for n in xrange(aim + 1): for v in arr: if n &gt;= v: dp[n] = min(dp[n], dp[n - v] + 1) return dp[aim] if dp[aim] != INT_MAX else -1 NC127. 最长公共子串 [n]给定两个字符串str1和str2,输出两个字符串的最长公共子串，如果最长公共子串为空，输出-1。 示例1 输入: \"1AB2345CD\",\"12345EF\" 返回值: \"2345\" Python会超时。 12345678910111213141516171819202122232425public class Solution &#123; public String LCS (String str1, String str2) &#123; // write code here int m = str1.length(); int n = str2.length(); int res = 0; String tmp = &quot;&quot;; int[][] dp = new int[m + 1][n + 1]; for(int i = 1;i &lt; m + 1; i++) &#123; for(int j = 1; j &lt; n + 1; j++) &#123; if(str1.charAt(i - 1) == str2.charAt(j - 1)) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; if(dp[i][j] &gt; res) &#123; res = dp[i][j]; tmp = str1.substring(i - dp[i][j], i); &#125; &#125; &#125; if(tmp.length() == 0) &#123; return &quot;-1&quot;; &#125; return tmp; &#125;&#125; NC128. 容器盛水问题 [n]给定一个整形数组arr，已知其中所有的值都是非负的，将这个数组看作一个容器，请返回容器能装多少水。具体请参考样例解释 示例1 输入: [3,1,2,5,2,4] 返回值: 5 示例2 输入: [4,5,1,3,2] 返回值: 2 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: /** * max water * @param arr int整型vector the array * @return long长整型 */ long long maxWater(vector&lt;int&gt;&amp; arr) &#123; // write code here if(arr.size() &lt;= 2) &#123; return 0; &#125; int left = 0, right = arr.size() - 1; long long res = 0; int min = getMin(arr[left], arr[right]); while(left &lt; right) &#123; if(arr[left] &lt; arr[right]) &#123; left += 1; if(arr[left] &lt; min) &#123; res += min - arr[left]; &#125;else &#123; min = getMin(arr[left], arr[right]); &#125; &#125;else &#123; right -= 1; if(arr[right] &lt; min) &#123; res += min - arr[right]; &#125;else &#123; min = getMin(arr[left], arr[right]); &#125; &#125; &#125; return res; &#125; int getMin(int a, int b) &#123; return a &gt; b ? b: a; &#125;&#125;; NC138. 矩阵最长递增路径给定一个矩阵，矩阵内所有数均为非负整数。求一条路径，该路径上所有数是递增的。这个路径必须满足以下条件：1、对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外。2、你不能走重复的单元格。即每个格子最多只能走一次。 示例1 输入: [[1,2,3],[4,5,6],[7,8,9]] 返回值: 5 示例2 输入: [[1,2],[4,3]] 返回值: 4 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int solve(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123; // write code here if(matrix.size() == 0 || matrix[0].size() == 0) &#123; return 0; &#125; int rows = matrix.size(), cols = matrix[0].size(); int res = 0; int dirs[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; vector&lt;vector&lt;int&gt;&gt; memo(rows, vector&lt;int&gt;(cols, 0)); for(int i = 0; i &lt; rows; i++) &#123; for(int j = 0; j &lt; cols; j++) &#123; int cur = dfs(matrix, i, j, rows, cols, memo, dirs); res = max(res, cur); &#125; &#125; return res; &#125; int dfs(const vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int i, int j, int rows, int cols, vector&lt;vector&lt;int&gt;&gt;&amp; memo, int dirs[4][2]) &#123; if(memo[i][j] != 0) &#123; return memo[i][j]; &#125; memo[i][j] += 1; for(int k = 0; k &lt; 4; k++) &#123; int newI = dirs[k][0] + i, newJ = dirs[k][1] + j; if(newI &gt;= 0 &amp;&amp; newI &lt; rows &amp;&amp; newJ &gt;= 0 &amp;&amp; newJ &lt; cols &amp;&amp; matrix[i][j] &lt; matrix[newI][newJ]) &#123; memo[i][j] = max(memo[i][j], dfs(matrix, newI, newJ, rows, cols, memo, dirs) + 1); &#125; &#125; return memo[i][j]; &#125;&#125;;","categories":[{"name":"Tech","slug":"Tech","permalink":"https://leel0330.github.io/categories/Tech/"}],"tags":[]},{"title":"Docker构建包含zsh和vim的Ubuntu","slug":"Docker构建包含zsh和vim的Ubuntu","date":"2020-12-18T15:24:31.000Z","updated":"2020-12-26T07:21:34.609Z","comments":false,"path":"posts/2954551561.html","link":"","permalink":"https://leel0330.github.io/posts/2954551561.html","excerpt":"晚上花了点时间研究了下如何在Docker环境下构建属于自己的Ubuntu。该Ubuntu包含了zsh和Oh-my-zsh插件，也包含了YouCompleteMe插件的Vim编辑器。 含泪说下:网上的YouCompleteMe很多教程都已经过时了，还是得以官方文档为主来配置该插件，否则你会安装的很痛苦。 另外，该Ubuntu也包含了C/C++的编译环境，如gcc、g++、gdb和valgrind常用工具。","text":"晚上花了点时间研究了下如何在Docker环境下构建属于自己的Ubuntu。该Ubuntu包含了zsh和Oh-my-zsh插件，也包含了YouCompleteMe插件的Vim编辑器。 含泪说下:网上的YouCompleteMe很多教程都已经过时了，还是得以官方文档为主来配置该插件，否则你会安装的很痛苦。 另外，该Ubuntu也包含了C/C++的编译环境，如gcc、g++、gdb和valgrind常用工具。 预安装123456789apt updateapt install systemdapt install curlapt install wgetapt install git 安装zsh1234567apt install zshsh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlightinggit clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 在.zshrc配置插件 1plugins=(git zsh-syntax-highlighting zsh-autosuggestions) 避免复制命令在控制台是一个个字符显示出来 123456789101112# This speeds up pasting w/ autosuggest# https://github.com/zsh-users/zsh-autosuggestions/issues/238pasteinit() &#123; OLD_SELF_INSERT=$&#123;$&#123;(s.:.)widgets[self-insert]&#125;[2,3]&#125; zle -N self-insert url-quote-magic # I wonder if you&#x27;d need `.url-quote-magic`?&#125;pastefinish() &#123; zle -N self-insert $OLD_SELF_INSERT&#125;zstyle :bracketed-paste-magic paste-init pasteinitzstyle :bracketed-paste-magic paste-finish pastefinish (不一定会碰到这个问题)按tab键shell中重复显示命令的前几个字符问题修复: 12345678apt-get install -y localesrm -rf /var/lib/apt/lists/*localedef -i en_US -c -f UTF-8 -A /usr/share/locale/locale.alias en_US.UTF-8echo &#x27;export LANG=en_US.utf8&#x27; &gt;&gt; ~/.zshrcsource ~/.zshrc 以上都放置在.zshrc文件就可以，然后重启下就可以了。 安装vim并配置 按照插件管理器Vundle。1git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 建立默认.vimrc文件在~目录下，内容为:1234567891011121314151617181920212223242526272829set nocompatible &quot; be iMproved, requiredfiletype off &quot; required&quot; set the runtime path to include Vundle and initializeset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()&quot; alternatively, pass a path where Vundle should install plugins&quot;call vundle#begin(&#x27;~/some/path/here&#x27;)&quot; let Vundle manage Vundle, requiredPlugin &#x27;VundleVim/Vundle.vim&#x27;&quot; plugins here&quot; All of your Plugins must be added before the following linecall vundle#end() &quot; requiredfiletype plugin indent on &quot; required&quot; To ignore plugin indent changes, instead use:&quot;filetype plugin on&quot;&quot; Brief help&quot; :PluginList - lists configured plugins&quot; :PluginInstall - installs plugins; append `!` to update or just :PluginUpdate&quot; :PluginSearch foo - searches for foo; append `!` to refresh local cache&quot; :PluginClean - confirms removal of unused plugins; append `!` to auto-approve removal&quot;&quot; see :h vundle for more details or wiki for FAQ&quot; Put your non-Plugin stuff after this line 安装YouCompleteMe插件 在.vimrc添加如下内容:1Plugin &#39;Valloric&#x2F;YouCompleteMe&#39; 拉取YouCompleteMe插件代码:12345cd ~/.vim/bundlegit clone https://github.com/Valloric/YouCompleteMe.gitcd ~/.vim/bundle/YouCompleteMegit submodule update --init --recursive(注意:这个命令可能花时间比较久) 拉取构建YouCompleteMe依赖:1apt install build-essential cmake vim-nox python3-dev 安装代码提示:123cd ~/.vim/bundle/YouCompleteMepython3 install.py --clangd-completer 这4步完成后YouCompleteMe插件就算完成了，网上好多说要配置.ycm_extra_conf.py。其实这个文件已经在这个~/.vim/bundle/YouCompleteMe目录下了，你可以通过ls -a来看到那个文件。 安装C/C++环境1234567apt install gccapt install g++apt install valgrindapt install gdb","categories":[{"name":"Tech","slug":"Tech","permalink":"https://leel0330.github.io/categories/Tech/"}],"tags":[]},{"title":"谈一谈你对进程和线程的认识(未完待续...)","slug":"谈一谈进程和线程","date":"2020-12-14T12:37:25.000Z","updated":"2020-12-26T07:22:23.577Z","comments":false,"path":"posts/3970838420.html","link":"","permalink":"https://leel0330.github.io/posts/3970838420.html","excerpt":"这是自己看完几本操作系统书和网上一些博客后，为了加深自己对进程和线程的认识，写的总结性的文章，也希望这篇文章能让你耳目一新^_^。 这篇文章只谈概念，不谈代码。如果你理解了概念，写代码的时候思路就会变得很清晰，不会陷入我也不知道自己在写神马的困境。","text":"这是自己看完几本操作系统书和网上一些博客后，为了加深自己对进程和线程的认识，写的总结性的文章，也希望这篇文章能让你耳目一新^_^。 这篇文章只谈概念，不谈代码。如果你理解了概念，写代码的时候思路就会变得很清晰，不会陷入我也不知道自己在写神马的困境。 什么是进程？ 进程是执行中的程序，是操作系统分配资源的基本单位。 内存中的进程结构如图所示: 进程在执行时会改变状态，每个进程可能处于下列状态中的某一个，如图所示: 每个进程在操作系统内用程序控制块(PCB)来表示。PCB通常包含了以下几类信息: 程序状态:包括新的、就绪、运行、等待、停止等。 程序计数器:计数器表示进程要执行的下个指令的地址。 CPU寄存器:与程序计数器一起，寄存器的状态信息在出现中断时也需要保存，以便进程以后能正确地继续执行。 CPU调度信息:包括进程优先级、调度队列的指针和其他调度参数。 内存管理信息:包括基址和界限寄存器的值、页表或段表。 记账信息:包括CPU时间、实际使用时间、时间界限、记账数据、作业或进程数量等。 I/O状态信息:包括分配给进程的I/O设备列表、打开的文件列表等。 驻留在内存中就绪的、等待运行的进程保存在就绪队列中，该队列通常用双向链表来实现。等待特定I/O设备的进程列表称为设备队列，每个设备都有自己的设备队列。 绝大多数进程可以分为I/O密集型或CPU密集型。I/O密集型的进程在执行I/O方面比执行计算要花费更多的时间。CPU密集型的进程将更多的时间用在计算上。 将CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态，这一任务被称为上下文切换。上下文切换时间是额外开销，因为切换时系统并不能做什么有用的工作。 进程在执行过程中，能够通过创建进程系统调用创建多个新进程。大多数操作系统根据一个唯一的进程标识符来识别进程，pid(process identifier)通常是一个整数值。 进程间通信有两种基本模式:共享内存和消息传递。在共享内存模式中，建立起一块共进程共享的内存区域，进程通过向此共享区域读或写入数据来交换信息。在消息传递模式中，通过在进程间交换消息来实现通信。 消息传递对于交换较少数量的数据很有用，因为不需要避免冲突。对于计算机间的通信，消息传递也比共享内存更易于实现。共享内存允许以最快的速度进行方便的通信，在计算机中它可以达到内存的速度。共享内存比消息传递快，消息传递系统通常用系统调用来实现，因此需要更多的内核介入的时间消耗。共享内存系统中仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有的访问都被处理为常规的内存访问，不需要内核的帮助。(共享内存和消息传递的比较) 什么是线程？ 线程是操作系统调度的基本单位，由线程ID、程序计数器、寄存器集合和栈组成。它与属于同一进程的其他线程共享代码段、数据段和其他操作系统资源，如打开文件和信号。 多线程编程有4个优点: 响应度高:如果对一个交互程序采用多线程，那么即使其他部分阻塞或执行较冗长的操作，该程序仍能继续执行，从而增加了对用户的响应程度。 资源共享:线程默认共享它们所属进程的内存和资源。 经济:进程创建所需要的内存和资源的分配比较昂贵。由于线程共享它们所属进程的资源，所以创建和切换线程会更为经济。 多处理器体系结构的利用:能充分利用多处理器体系结构，以便每个进程能并行运行在不同的处理器上。在多CPU上使用多线程加强了并发功能。 线程池的主要思想是在进程开始时创建一定数量的线程，并放入到池中以等待工作。当服务器收到请求时，它会唤醒池中的一个线程，并将要处理的请求传递给它。一旦线程完成了服务，它会返回池中再等待工作。如果池中没有可用的线程，那么服务器会一直等到有空线程为止。线程池有如下几个优点: 通常用现有线程处理请求要比等待创建新的线程要快。 线程池限制了在任何时候可用线程的数量。这对那些不能支持大量并发线程的系统非常重要。 线程池中的线程数量由系统CPU的数量、物理内存的大小和并发客户请求的期望值等因素决定。 进程和线程有哪些联系和区别？多进程还是多线程？我该怎么选择呢？参考资料 《操作系统概念》","categories":[{"name":"Tech","slug":"Tech","permalink":"https://leel0330.github.io/categories/Tech/"}],"tags":[]},{"title":"LeetCode之字符串(中等)","slug":"LeetCode-字符串-中等","date":"2020-12-12T09:03:40.000Z","updated":"2020-12-26T07:21:55.564Z","comments":false,"path":"posts/723701661.html","link":"","permalink":"https://leel0330.github.io/posts/723701661.html","excerpt":"字符串(中等)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"字符串(中等)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 3. 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。 示例 1: 输入: \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2: 输入: \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3: 输入: \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 PythonJava123456789101112131415161718class Solution(object): def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; n = len(s) cset = set() i, j, res = 0, 0, 0 while i &lt; n and j &lt; n: if s[j] not in cset: cset.add(s[j]) res = max(res, j - i + 1) j += 1 else: cset.remove(s[i]) i += 1 return res12345678910111213141516171819class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int i = 0, j = 0; Set&lt;Character&gt; hashSet = new HashSet&lt;&gt;(); int n = s.length(); int res = 0; while (i &lt; n) &#123; if (hashSet.contains(s.charAt(i))) &#123; hashSet.remove(s.charAt(j)); j += 1; &#125; else &#123; hashSet.add(s.charAt(i)); i += 1; &#125; res = Math.max(res, i - j); &#125; return res; &#125;&#125; 5. 最长回文子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: \"babad\" 输出: \"bab\" 注意: \"aba\" 也是一个有效答案。 示例 2： 输入: \"cbbd\" 输出: \"bb\" PythonJava123456789101112131415161718192021222324252627class Solution(object): def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; if s is None or len(s) == 0: return &quot;&quot; res_left, res_right, res_len = 0, 0, 0 for i in xrange(0, len(s)): l1, r1, len1 = self.helper(s, i, i) l2, r2, len2 = self.helper(s, i, i + 1) if len1 &gt; len2: if len1 &gt; res_len: res_left, res_right, res_len = l1, r1, len1 else: if len2 &gt; res_len: res_left, res_right, res_len = l2, r2, len2 res_str = s[res_left:res_right + 1] return res_str def helper(self, s, left, right): L, R = left, right while L &gt;= 0 and R &lt; len(s) and s[L] == s[R]: L -= 1 R += 1 return L + 1, R - 1, R - L - 112345678910111213141516171819202122232425262728class Solution &#123; private int len; private String res; public String longestPalindrome(String s) &#123; len = 0; res = &quot;&quot;; int n = s.length(); for (int i = 0; i &lt; n; i++) &#123; helper(s, i, i); helper(s, i, i + 1); &#125; return res; &#125; private void helper(String s, int left, int right) &#123; int i = left, j = right; int n = s.length(); while (i &gt; -1 &amp;&amp; j &lt; n &amp;&amp; s.charAt(i) == s.charAt(j)) &#123; i -= 1; j += 1; &#125; if (j - i - 1 &gt; len) &#123; len = j - i - 1; res = s.substring(i + 1, j); &#125; &#125;&#125; 6. ZZ 字形变换将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下： L C I R E T O E S I I G E D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 示例 1: 输入: s = \"LEETCODEISHIRING\", numRows = 3 输出: \"LCIRETOESIIGEDHN\" 示例 2: 输入: s = \"LEETCODEISHIRING\", numRows = 4 输出: \"LDREOEIIECIHNTSG\" 解释: L D R E O E I I E C I H N T S G PythonJava12345678910111213141516171819202122class Solution(object): def convert(self, s, numRows): &quot;&quot;&quot; :type s: str :type numRows: int :rtype: str &quot;&quot;&quot; s_list = [[] for _ in xrange(numRows)] i, n = 0, len(s) while i &lt; n: for j in xrange(0, numRows): if i &lt; n: s_list[j].append(s[i]) i += 1 for j in xrange(numRows - 2, 0, -1): if i &lt; n: s_list[j].append(s[i]) i += 1 res = [] for i in xrange(numRows): res.extend(s_list[i]) return &#x27;&#x27;.join(res)123456789101112131415161718192021222324252627282930class Solution &#123; public String convert(String s, int numRows) &#123; List&lt;StringBuilder&gt; sbs = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; numRows; j++) &#123; sbs.add(new StringBuilder()); &#125; System.out.println(sbs.size()); int i = 0, n = s.length(); while (i &lt; n) &#123; for (int j = 0; j &lt; numRows; j++) &#123; if (i &lt; n) &#123; sbs.get(j).append(s.charAt(i)); i += 1; &#125; &#125; for (int j = numRows - 2; j &gt; 0; j--) &#123; if (i &lt; n) &#123; sbs.get(j).append(s.charAt(i)); i += 1; &#125; &#125; &#125; StringBuilder res = new StringBuilder(); for (StringBuilder sb : sbs) &#123; res.append(sb.toString()); &#125; return res.toString(); &#125;&#125; 22. 括号生成给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： [ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] PythonJava12345678910111213141516171819class Solution(object): def generateParenthesis(self, n): &quot;&quot;&quot; :type n: int :rtype: List[str] &quot;&quot;&quot; item, res = &#x27;&#x27;, [] self.helper(res, item, 0, 0, n) return res def helper(self, res, item, left, right, n): if left == n and right == n: res.append(item) return if left &lt; n: self.helper(res, item + &#x27;(&#x27;, left + 1, right, n) if right &lt; left: self.helper(res, item + &#x27;)&#x27;, left, right + 1, n)12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if (n == 0) &#123; return res; &#125; helper(n, n, &quot;&quot;, res); return res; &#125; private void helper(int left, int right, String cur, List&lt;String&gt; res) &#123; if (left &gt; right) &#123; return; &#125; if (left == 0 &amp;&amp; right == 0) &#123; res.add(cur); return; &#125; if (left &gt; 0) &#123; helper(left - 1, right, cur + &quot;(&quot;, res); &#125; if (right &gt; left) &#123; helper(left, right - 1, cur + &quot;)&quot;, res); &#125; &#125;&#125; 91. 解码方法一条包含字母 A-Z 的消息通过以下方式进行了编码： 'A' -> 1 'B' -> 2 ... 'Z' -> 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1: 输入: \"12\" 输出: 2 解释: 它可以解码为 \"AB\"（1 2）或者 \"L\"（12）。 示例 2: 输入: \"226\" 输出: 3 解释: 它可以解码为 \"BZ\" (2 26), \"VF\" (22 6), 或者 \"BBF\" (2 2 6) 。 PythonJava1234567891011121314151617181920class Solution(object): def numDecodings(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; if s is None or len(s) == 0: return 0 n = len(s) dp = [0 for _ in xrange(n + 1)] dp[0] = 1 dp[1] = 1 if s[0] != &#x27;0&#x27; else 0 for i in xrange(2, n + 1): one_c = int(s[i - 1:i]) two_c = int(s[i - 2:i]) if 1 &lt;= one_c &lt;= 9: dp[i] += dp[i - 1] if 10 &lt;= two_c &lt;= 26: dp[i] += dp[i - 2] return dp[n]123456789101112131415161718192021class Solution &#123; public int numDecodings(String s) &#123; int n = s.length(); int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = s.charAt(0) == &#x27;0&#x27; ? 0 : 1; for (int i = 2; i &lt; n + 1; i++) &#123; String one_s = s.substring(i - 1, i); String two_s = s.substring(i - 2, i); int one = Integer.parseInt(one_s); if (1 &lt;= one &amp;&amp; one &lt;= 9) &#123; dp[i] += dp[i - 1]; &#125; int two = Integer.parseInt(two_s); if (two &gt;= 10 &amp;&amp; two &lt;= 26) &#123; dp[i] += dp[i - 2]; &#125; &#125; return dp[n]; &#125;&#125; 93. 复原IP地址给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 示例: 输入: \"25525511135\" 输出: [\"255.255.11.135\", \"255.255.111.35\"] PythonJava123456789101112131415161718192021222324252627282930class Solution(object): def restoreIpAddresses(self, s): &quot;&quot;&quot; :type s: str :rtype: List[str] &quot;&quot;&quot; item, res = [], [] if s is None or len(s) &lt; 4 or len(s) &gt; 12: return res self.helper(s, item, res) return res def helper(self, s, item, res): if s == &#x27;&#x27; and len(item) == 4: res.append(&#x27;.&#x27;.join(item[:])) return for i in xrange(1, 4): sub_s = s[:i] if len(sub_s) == i and self.ok(sub_s): item.append(sub_s) self.helper(s[i:], item, res) item.pop(-1) def ok(self, s): if len(s) == 0: return False if len(s) &gt; 1 and s[0] == &#x27;0&#x27;: return False n = int(s) return 0 &lt;= n &lt;= 2551234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public List&lt;String&gt; restoreIpAddresses(String s) &#123; int n = s.length(); List&lt;String&gt; res = new ArrayList&lt;&gt;(); if (n &lt; 4 || n &gt; 12) &#123; return res; &#125; List&lt;String&gt; item = new ArrayList&lt;&gt;(); helper(s, 0, item, res); return res; &#125; private void helper(String s, int idx, List&lt;String&gt; item, List&lt;String&gt; res) &#123; if (idx == 4) &#123; if (s.length() &gt; 0) &#123; return; &#125; List&lt;String&gt; tmp = new ArrayList&lt;&gt;(); tmp.addAll(item); res.add(String.join(&quot;.&quot;, tmp)); return; &#125; for (int i = 1; i &lt; 4; i++) &#123; if (s.length() &lt; i) &#123; continue; &#125; String substr = s.substring(0, i); if (isOK(substr)) &#123; item.add(substr); helper(s.substring(i), idx + 1, item, res); item.remove(item.size() - 1); &#125; &#125; &#125; private boolean isOK(String s) &#123; if (s.length() == 0 || s.length() &gt; 3) &#123; return false; &#125; if (s.length() &gt; 1 &amp;&amp; s.charAt(0) == &#x27;0&#x27;) &#123; return false; &#125; int n = Integer.parseInt(s); return n &gt;= 0 &amp;&amp; n &lt;= 255; &#125;&#125; 316. 去除重复字母 [n]给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。 示例 1： 输入：s = \"bcabc\" 输出：\"abc\" 示例 2： 输入：s = \"cbacdcbc\" 输出：\"acdb\" 提示： 1 &lt;= s.length &lt;= 10^4 s 由小写英文字母组成 PythonJava1234567891011121314151617class Solution(object): def removeDuplicateLetters(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; stk = [] seen = set() m = &#123;c: i for i, c in enumerate(s)&#125; for i, c in enumerate(s): if c not in seen: while stk and stk[-1] &gt; c and m[stk[-1]] &gt; i: rm_c = stk.pop(-1) seen.discard(rm_c) seen.add(c) stk.append(c) return &#x27;&#x27;.join(stk)1234567891011121314151617181920212223242526class Solution &#123; public String removeDuplicateLetters(String s) &#123; Stack&lt;Character&gt; stk = new Stack&lt;&gt;(); Set&lt;Character&gt; seen = new HashSet&lt;&gt;(); Map&lt;Character, Integer&gt; m = new HashMap&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; m.put(s.charAt(i), i); &#125; for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if (!seen.contains(c)) &#123; while (stk.size() &gt; 0 &amp;&amp; stk.peek() &gt; c &amp;&amp; m.get(stk.peek()) &gt; i) &#123; char rm_c = stk.pop().charValue(); seen.remove(rm_c); &#125; seen.add(c); stk.add(c); &#125; &#125; StringBuilder res = new StringBuilder(stk.size()); for (int i = 0; i &lt; stk.size(); i++) &#123; res.append(stk.get(i)); &#125; return res.toString(); &#125;&#125; 402. 移掉K位数字给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。 注意: num 的长度小于 10002 且 ≥ k。 num 不会包含任何前导零。 示例 1 : 输入: num = \"1432219\", k = 3 输出: \"1219\" 解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。 示例 2 : 输入: num = \"10200\", k = 1 输出: \"200\" 解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。 示例 3 : 输入: num = \"10\", k = 2 输出: \"0\" 解释: 从原数字移除所有的数字，剩余为空就是0。 12345678910111213141516171819class Solution(object): def removeKdigits(self, num, k): &quot;&quot;&quot; :type num: str :type k: int :rtype: str &quot;&quot;&quot; stk = [] for c in num: while k and stk and stk[-1] &gt; c: stk.pop(-1) k -= 1 stk.append(c) while k: stk.pop(-1) k -= 1 if not stk: return &#x27;0&#x27; return str(int(&#x27;&#x27;.join(stk))) 424. 替换后的最长重复字符[n]给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。 注意: 字符串长度 和 k 不会超过 104。 示例 1: 输入: s = \"ABAB\", k = 2 输出: 4 解释: 用两个'A'替换为两个'B',反之亦然。 示例 2: 输入: s = \"AABABBA\", k = 1 输出: 4 解释: 将中间的一个'A'替换为'B',字符串变为 \"AABBBBA\"。 子串 \"BBBB\" 有最长重复字母, 答案为 4。 123456789101112131415161718class Solution(object): def characterReplacement(self, s, k): &quot;&quot;&quot; :type s: str :type k: int :rtype: int &quot;&quot;&quot; m = &#123;&#125; start, end, max_freq, res = 0, 0, 0, 0 while end &lt; len(s): m[s[end]] = 1 if s[end] not in m else m[s[end]] + 1 max_freq = max(max_freq, m[s[end]]) if end - start + 1 - max_freq &gt; k: m[s[start]] -= 1 start += 1 res = max(res, end - start + 1) end += 1 return res 556. Next Greater Element III [n]给定一个32位正整数 n，你需要找到最小的32位整数，其与 n 中存在的位数完全相同，并且其值大于n。如果不存在这样的32位整数，则返回-1。 示例 1: 输入: 12 输出: 21 示例 2: 输入: 21 输出: -1 1234567891011121314151617181920212223242526class Solution(object): def nextGreaterElement(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; max_val = (1 &lt;&lt; 32) - 1 nums = [int(i) for i in str(n)] i = len(nums) - 1 while i &gt; 0: if nums[i - 1] &lt; nums[i]: break i -= 1 if i == 0: return -1 x = nums[i - 1] smallest = i for j in xrange(i + 1, len(nums)): if nums[j] &gt; x and nums[j] &lt; nums[smallest]: smallest = j nums[i - 1], nums[smallest] = nums[smallest], nums[i - 1] left = nums[:i] right = sorted(nums[i:]) nums = left + right v = int(&#x27;&#x27;.join([str(i) for i in nums])) return v if v &lt; max_val else -1 583. 两个字符串的删除操作 [n]给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。 示例 1: 输入: \"sea\", \"eat\" 输出: 2 解释: 第一步将\"sea\"变为\"ea\"，第二步将\"eat\"变为\"ea\" 说明: 给定单词的长度不超过500。 给定单词中的字符只含有小写字母。 12345678910111213141516171819class Solution(object): def minDistance(self, word1, word2): &quot;&quot;&quot; :type word1: str :type word2: str :rtype: int &quot;&quot;&quot; len1, len2 = len(word1), len(word2) dp = [[0 for _ in xrange(len2 + 1)] for _ in xrange(len1 + 1)] for i in xrange(len1 + 1): for j in xrange(len2 + 1): if i == 0 or j == 0: continue elif word1[i - 1] == word2[j - 1]: dp[i][j] = 1 + dp[i - 1][j - 1] else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) lcs = dp[len1][len2] return len1 + len2 - 2 * lcs 647. 回文子串给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。 示例 1: 输入: \"abc\" 输出: 3 解释: 三个回文子串: \"a\", \"b\", \"c\". 示例 2: 输入: \"aaa\" 输出: 6 说明: 6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\". 注意: 输入的字符串长度不会超过1000。 1234567891011121314151617181920class Solution(object): def __init__(self): self.res = 0 def countSubstrings(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; self.res = 0 for i in xrange(0, len(s)): self.helper(s, i, i) self.helper(s, i, i + 1) return self.res def helper(self, s, left, right): while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]: self.res += 1 left -= 1 right += 1 678. 有效的括号字符串 [n]给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则： 任何左括号 ( 必须有相应的右括号 )。 任何右括号 ) 必须有相应的左括号 ( 。 左括号 ( 必须在对应的右括号之前 )。 * 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。 一个空字符串也被视为有效字符串。 示例 1: 输入: \"()\" 输出: True 示例 2: 输入: \"(*)\" 输出: True 示例 3: 输入: \"(*))\" 输出: True 注意: 字符串大小将在 [1，100] 范围内。 123456789101112131415161718192021class Solution(object): def checkValidString(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; low, high = 0, 0 for c in s: if c == &#x27;(&#x27;: low, high = low +1, high + 1 elif c == &#x27;)&#x27;: if low &gt; 0: low -= 1 high -= 1 else: if low &gt; 0: low -= 1 high += 1 if high &lt; 0: return False return low == 0 767. 重构字符串给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。 若可行，输出任意可行的结果。若不可行，返回空字符串。 示例 1: 输入: S = \"aab\" 输出: \"aba\" 示例 2: 输入: S = \"aaab\" 输出: \"\" 注意: S 只包含小写字母并且长度在[1, 500]区间内。 123456789101112131415161718192021222324252627282930313233343536class Solution(object): def reorganizeString(self, S): &quot;&quot;&quot; :type S: str :rtype: str &quot;&quot;&quot; char_cnt = [0 for _ in xrange(26)] max_char = None i_a = ord(&#x27;a&#x27;) for c in S: i = ord(c) - i_a char_cnt[i] += 1 if max_char is None: max_char = c else: j = ord(max_char) - i_a if char_cnt[i] &gt; char_cnt[j]: max_char = c if 2 * char_cnt[ord(max_char) - i_a] -1 &gt; len(S): return &quot;&quot; res = [&#x27;&#x27; for _ in xrange(len(S))] i_max_char = ord(max_char) - i_a i = 0 for j in xrange (char_cnt[i_max_char]): res[i] = max_char i += 2 char_cnt[i_max_char] = 0 for j in xrange(26): if char_cnt[j] &gt; 0: c = chr(j + i_a) for k in xrange(char_cnt[j]): if i &gt;= len(S): i = 1 res[i] = c i += 2 return &quot;&quot;.join(res) 856. 括号的分数给定一个平衡括号字符串 S，按下述规则计算该字符串的分数： () 得 1 分。AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。(A) 得 2 * A 分，其中 A 是平衡括号字符串。 示例 1： 输入： \"()\" 输出： 1 示例 2： 输入： \"(())\" 输出： 2 示例 3： 输入： \"()()\" 输出： 2 示例 4： 输入： \"(()(()))\" 输出： 6 提示： S 是平衡括号字符串，且只含有 ( 和 ) 。 2 &lt;= S.length &lt;= 50 123456789101112131415161718192021class Solution(object): def scoreOfParentheses(self, S): &quot;&quot;&quot; :type S: str :rtype: int &quot;&quot;&quot; stk = [] for c in S: if c == &#x27;(&#x27;: stk.append(-1) else: cnt = 0 while stk[-1] != -1: cnt += stk[-1] stk.pop(-1) stk.pop(-1) if cnt == 0: stk.append(1) else: stk.append(2 * cnt) return sum(stk) 890. 查找和替换模式你有一个单词列表 words 和一个模式 pattern，你想知道 words 中的哪些单词与模式匹配。 如果存在字母的排列 p ，使得将模式中的每个字母 x 替换为 p(x) 之后，我们就得到了所需的单词，那么单词与模式是匹配的。 （回想一下，字母的排列是从字母到字母的双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母。） 返回 words 中与给定模式匹配的单词列表。 你可以按任何顺序返回答案。 示例： 输入：words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\" 输出：[\"mee\",\"aqq\"] 解释： \"mee\" 与模式匹配，因为存在排列 {a -> m, b -> e, ...}。 \"ccc\" 与模式不匹配，因为 {a -> c, b -> c, ...} 不是排列。 因为 a 和 b 映射到同一个字母。 提示： 1 &lt;= words.length &lt;= 50 1 &lt;= pattern.length = words[i].length &lt;= 20 12345678910111213141516171819202122232425class Solution(object): def findAndReplacePattern(self, words, pattern): &quot;&quot;&quot; :type words: List[str] :type pattern: str :rtype: List[str] &quot;&quot;&quot; res = [] p = self.helper(pattern) for w in words: pw = self.helper(w) if pw == p: res.append(w) return res def helper(self, pattern): m = &#123;&#125; res = [] for c in pattern: if c in m: res.append(m[c]) else: m[c] = len(m) + 1 res.append(m[c]) return &#x27;&#x27;.join([str(i) for i in res])","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode之字符串(简单)","slug":"LeetCode-字符串-简单","date":"2020-12-11T13:38:13.000Z","updated":"2020-12-26T07:22:01.160Z","comments":false,"path":"posts/c026ad95.html","link":"","permalink":"https://leel0330.github.io/posts/c026ad95.html","excerpt":"字符串(简单)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"字符串(简单)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 14. 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1: 输入: [\"flower\",\"flow\",\"flight\"] 输出: \"fl\" 示例 2: 输入: [\"dog\",\"racecar\",\"car\"] 输出: \"\" 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 123456789101112131415class Solution(object): def longestCommonPrefix(self, strs): &quot;&quot;&quot; :type strs: List[str] :rtype: str &quot;&quot;&quot; res = &quot;&quot; if strs is None or len(strs) == 0: return res for i, c in enumerate(strs[0]): for j in xrange(1, len(strs)): if i &gt;= len(strs[j]) or strs[j][i] != c: return res res += c return res 443. 压缩字符串给定一组字符，使用原地算法将其压缩。 压缩后的长度必须始终小于或等于原数组长度。 数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。 在完成原地修改输入数组后，返回数组的新长度。 进阶： 你能否仅使用O(1) 空间解决问题？ 示例 1： 输入： [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"] 输出： 返回6，输入数组的前6个字符应该是：[\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"] 说明： \"aa\"被\"a2\"替代。\"bb\"被\"b2\"替代。\"ccc\"被\"c3\"替代。 示例 2： 输入： [\"a\"] 输出： 返回1，输入数组的前1个字符应该是：[\"a\"] 说明： 没有任何字符串被替代。 示例 3： 输入： [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"] 输出： 返回4，输入数组的前4个字符应该是：[\"a\",\"b\",\"1\",\"2\"]。 说明： 由于字符\"a\"不重复，所以不会被压缩。\"bbbbbbbbbbbb\"被“b12”替代。 注意每个数字在数组中都有它自己的位置。 注意： 所有字符都有一个ASCII值在[35, 126]区间内。 1 &lt;= len(chars) &lt;= 1000。 123456789101112131415161718192021class Solution(object): def compress(self, chars): &quot;&quot;&quot; :type chars: List[str] :rtype: int &quot;&quot;&quot; res = [] i = 0 while i &lt; len(chars): c, cnt = chars[i], 0 while i &lt; len(chars) and chars[i] == c: cnt += 1 i += 1 if cnt == 1: res.append(c) else: res.append(c) res.extend([c for c in str(cnt)]) for idx, c in enumerate(res): chars[idx] = c return len(res) 680. 验证回文字符串 Ⅱ给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例 1: 输入: \"aba\" 输出: True 示例 2: 输入: \"abca\" 输出: True 解释: 你可以删除c字符。 注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000 12345678910111213141516171819202122232425class Solution(object): def validPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; i, j = 0, len(s) - 1 while i &lt; j and s[i] == s[j]: i += 1 j -= 1 if i &gt;= j: return True if self.isPalindrome(s, i + 1, j) or self.isPalindrome(s, i, j - 1): return True return False def isPalindrome(self, s, i, j): if i &gt; j: return False while i &lt; j: if s[i] != s[j]: return False i += 1 j -= 1 return True 696. 计数二进制子串 [n]给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。 重复出现的子串要计算它们出现的次数。 示例 1 : 输入: \"00110011\" 输出: 6 解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。 请注意，一些重复出现的子串要计算它们出现的次数。 另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。 示例 2 : 输入: \"10101\" 输出: 4 解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。 注意： s.length 在1到50,000之间。 s 只包含“0”或“1”字符。 123456789101112131415161718class Solution(object): def countBinarySubstrings(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; res = pre = 0 cur = 1 n = len(s) for i in xrange(1, n): if s[i] == s[i - 1]: cur += 1 else: pre = cur cur = 1 if pre &gt;= cur: res += 1 return res 788. 旋转数字我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。 如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。 现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？ 示例: 输入: 10 输出: 4 解释: 在[1, 10]中有四个好数： 2, 5, 6, 9。 注意 1 和 10 不是好数, 因为他们在旋转之后不变。 注意: N 的取值范围是 [1, 10000]。 123456789101112131415161718class Solution(object): def rotatedDigits(self, N): &quot;&quot;&quot; :type N: int :rtype: int &quot;&quot;&quot; cnt = 0 for i in xrange(1, N + 1): if self.isGoodNum(i): cnt += 1 return cnt def isGoodNum(self, n): if any(x in str(n) for x in [&#x27;3&#x27;, &#x27;4&#x27;, &#x27;7&#x27;]): return False if any(x in str(n) for x in [&#x27;2&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;9&#x27;]): return True return False 859. 亲密字符串给定两个由小写字母构成的字符串 A 和 B ，只要我们可以通过交换 A 中的两个字母得到与 B 相等的结果，就返回 true ；否则返回 false 。 示例 1： 输入： A = \"ab\", B = \"ba\" 输出： true 示例 2： 输入： A = \"ab\", B = \"ab\" 输出： false 示例 3: 输入： A = \"aa\", B = \"aa\" 输出： true 示例 4： 输入： A = \"aaaaaaabc\", B = \"aaaaaaacb\" 输出： true 示例 5： 输入： A = \"\", B = \"aa\" 输出： false 提示： 0 &lt;= A.length &lt;= 20000 0 &lt;= B.length &lt;= 20000 A 和 B 仅由小写字母构成。 1234567891011121314151617class Solution(object): def buddyStrings(self, A, B): if len(A) != len(B): return False if A == B: seen = set() for a in A: if a in seen: return True seen.add(a) return False else: pairs = [] for a, b in zip(A, B): if a != b: pairs.append((a, b)) if len(pairs) &gt; 2: return False return len(pairs) == 2 and pairs[0] == pairs[1][::-1] 925. 长按键入你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。 你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。 示例 1： 输入：name = \"alex\", typed = \"aaleex\" 输出：true 解释：'alex' 中的 'a' 和 'e' 被长按。 示例 2： 输入：name = \"saeed\", typed = \"ssaaedd\" 输出：false 解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。 示例 3： 输入：name = \"leelee\", typed = \"lleeelee\" 输出：true 示例 4： 输入：name = \"laiden\", typed = \"laiden\" 输出：true 解释：长按名字中的字符并不是必要的。 提示： name.length &lt;= 1000 typed.length &lt;= 1000 name 和 typed 的字符都是小写字母。 123456789101112131415161718192021222324252627282930class Solution(object): def isLongPressedName(self, name, typed): &quot;&quot;&quot; :type name: str :type typed: str :rtype: bool &quot;&quot;&quot; a = self.getHelper(name) b = self.getHelper(typed) if len(a) != len(b): return False for idx in xrange(0, len(a), 2): if a[idx] != b[idx]: return False if a[idx + 1] &gt; b[idx + 1]: return False return True def getHelper(self, s): res = [] idx = 0 while idx &lt; len(s): cur_c, cnt = s[idx], 0 while idx &lt; len(s) and s[idx] == cur_c: idx += 1 cnt += 1 res.append(cur_c) res.append(cnt) return res","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode刷题指南(持续更新中)","slug":"LeetCode刷题指南","date":"2020-12-05T07:07:21.000Z","updated":"2020-12-26T07:22:11.806Z","comments":false,"path":"posts/af9ea9dd.html","link":"","permalink":"https://leel0330.github.io/posts/af9ea9dd.html","excerpt":"这个LeetCode分类是我刷题过程中整理出来的值得刷的题目。 因为我对Python比较熟练，所以大部分代码是用Python实现的😬。","text":"这个LeetCode分类是我刷题过程中整理出来的值得刷的题目。 因为我对Python比较熟练，所以大部分代码是用Python实现的😬。 首先需要说明的是，本人不做大而全的刷题目录，题目现在实在太多了，而且网上已经有一些人这么做了，对于刚开始刷题的你其实并不是十分友好。如果需要我可以在结尾给出一些链接，基本涵盖了所有题目，而且也有一些详细的解释。本人也不做题解，因为代码能看懂的话基本上不需要再阐释了，如果你需要，可以参考我给出的链接，我在刷题过程中也参考了别人的解法。总之三人行，必有我师。希望你的刷题之路顺利。 本人刷题一开始是按照官方上Tag来刷了，因为自己的算法基础比较薄弱，就采取了相对比较容易的路子。同时按照Tag刷，暗示了题目可能会用到的算法和数据结构，本人又只选取了简单和中等的题目，所以刷起来相对轻松一点。为了方便，这里列出了一些本人认为非常重要的Tag(✅表示已完成)： Tag类别完成状态防迷路链接 字符串(简单)✅LeetCode之字符串(简单) 字符串(中等)✅LeetCode之字符串(中等) 二叉树(简单)✅LeetCode之二叉树(简单) 二叉树(中等)✅LeetCode之二叉树(中等) 链表✅LeetCode之链表 哈希表✅LeetCode之哈希表 栈和队列✅LeetCode之栈和队列 数组 堆 图 二分查找 深度优先遍历 广度优先遍历 双指针 回溯 动态规划(如果你很厉害，可以直接上，本人是最后统一刷的🤦‍♂️) 如果按照这些Tag来刷，并选择简单和中等的题目，大概可以刷400-500的题目，基础和经典的题目基本都能覆盖到，对于首次刷题的你还是很友好的。 另一种刷的方式就是按照公司来刷，比如你心意的FLAG(Facebook,Linkedin,Amazon,Google)和Microsoft。可以小试牛刀，看下各家面试题的风格。这里罗列几个比较出名的公司： Google [✅] Microsoft [✅] Linkedin [✅] Facebook [✅] Amazon [✅] 最后的最后，给出本人认为比较好的几个人的刷题链接，在刷题的过程中可以看下别人的解法，对自己写代码的能力提升会很有帮助，废话不多讲，传送门如下： 首推花花酱：https://zxi.mytechroad.com/blog/ grandyang的博客： https://www.cnblogs.com/grandyang/p/4606334.html https://github.com/luliyucoordinate/Leetcode https://github.com/WuLC/LeetCode/tree/master/Algorithm/Python http://bookshadow.com/leetcode/ https://blog.csdn.net/fuxuemingzhu 如果你需要的话，可以联系我，把你的刷题链接附上来，方便大家你我他😁。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode之二叉树(中等)","slug":"LeetCode-二叉树-中等","date":"2020-12-05T02:29:51.000Z","updated":"2020-12-26T07:21:41.483Z","comments":false,"path":"posts/3ddb3bb0.html","link":"","permalink":"https://leel0330.github.io/posts/3ddb3bb0.html","excerpt":"二叉树(中等)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"二叉树(中等)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 95. 不同的二叉搜索树 II [n]给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。 示例: 输入: 3 输出: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] 解释: 以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 12345678910111213141516171819202122232425class Solution(object): def generateTrees(self, n): &quot;&quot;&quot; :type n: int :rtype: List[TreeNode] &quot;&quot;&quot; if n == 0: return [] return self.helper(1, n) def helper(self, start, end): if start &gt; end: return [None] res = [] for i in xrange(start, end + 1): lefts = self.helper(start, i - 1) rights = self.helper(i + 1, end) for left in lefts: for right in rights: node = TreeNode(i) node.left = left node.right = right res.append(node) return res 96. 不同的二叉搜索树 [n]给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 123456789101112class Solution(object): def numTrees(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; dp = [0 for _ in xrange(n + 1)] dp[0] = dp[1] = 1 for i in xrange(2, n + 1): for j in xrange(0, i): dp[i] += dp[j] * dp[i - 1 - j]#减一是因为根节点 return dp[n] 105. 从前序与中序遍历序列构造二叉树根据一棵树的前序遍历与中序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素。 例如，给出 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 12345678910111213141516171819202122232425class Solution(object): def buildTree(self, preorder, inorder): &quot;&quot;&quot; :type preorder: List[int] :type inorder: List[int] :rtype: TreeNode &quot;&quot;&quot; m = &#123;&#125; for idx, v in enumerate(inorder): m[v] = idx return self.helper(preorder, 0, len(preorder) - 1, \\ inorder, 0, len(inorder) - 1, m) def helper(self, preorder, pre_s, pre_e, inorder, in_s, in_e, m): if pre_s &gt; pre_e or in_s &gt; in_e: return None root_v = preorder[pre_s] root_idx = m[root_v] left_len = root_idx - in_s root = TreeNode(root_v) root.left = self.helper(preorder, pre_s + 1, pre_s + left_len, \\ inorder, in_s, root_idx - 1, m) root.right = self.helper(preorder, pre_s + left_len + 1, pre_e, \\ inorder, root_idx + 1, in_e, m) return root 106. 从中序与后序遍历序列构造二叉树根据一棵树的中序遍历与后序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素。 例如，给出 中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 12345678910111213141516171819202122232425class Solution(object): def buildTree(self, inorder, postorder): &quot;&quot;&quot; :type inorder: List[int] :type postorder: List[int] :rtype: TreeNode &quot;&quot;&quot; m = &#123;&#125; for idx, v in enumerate(inorder): m[v] = idx return self.helper(inorder, 0, len(inorder) - 1, \\ postorder, 0, len(postorder) - 1, m) def helper(self, inorder, in_left, in_right, postorder, post_left, post_right, m): if in_left &gt; in_right: return None root_val = postorder[post_right] root_idx = m[root_val] left_len = root_idx - in_left root = TreeNode(root_val) root.left = self.helper(inorder, in_left, root_idx - 1, \\ postorder, post_left, post_left + left_len - 1, m) root.right = self.helper(inorder, root_idx + 1, in_right, \\ postorder, post_left + left_len, post_right - 1, m) return root 114. 二叉树展开为链表给定一个二叉树，原地将它展开为链表。 例如，给定二叉树 1 / \\ 2 5 / \\ \\ 3 4 6 将其展开为： 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 12345678910111213141516171819202122232425class Solution(object): def flatten(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: None Do not return anything, modify root in-place instead. &quot;&quot;&quot; items = self.pre_order(root) for i in xrange(len(items) - 1): items[i].left = None items[i].right = items[i + 1] return root def pre_order(self, root): # 前序遍历 items = [] p = root stk = [] while p or stk: while p: items.append(p) stk.append(p) p = p.left node = stk.pop(-1) p = node.right return items 117. 填充每个节点的下一个右侧节点指针 II给定一个二叉树 struct Node { int val; Node *left; Node *right; Node *next; } 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 12345678910111213141516171819202122class Solution(object): def connect(self, root): &quot;&quot;&quot; :type root: Node :rtype: Node &quot;&quot;&quot; if root is None: return root queue = [root] while queue: sz = len(queue) prev = None for i in xrange(sz): node = queue.pop(0) if prev: prev.next = node prev = node if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root 236. 二叉树的最近公共祖先 [n]给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 示例 1: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 123456789101112131415class Solution(object): def lowestCommonAncestor(self, root, p, q): &quot;&quot;&quot; :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode &quot;&quot;&quot; if root is None or root == p or root == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if left and right: return root return left if left else right 331. 验证二叉树的前序序列化 [n]序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。 _9_ / \\ 3 2 / \\ / \\ 4 1 # 6 / \\ / \\ / \\ # # # # # # 例如，上面的二叉树可以被序列化为字符串 “9,3,4,#,#,1,#,#,2,#,6,#,#”，其中 # 代表一个空节点。 给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 ‘#’ 。 你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 “1,,3” 。 示例 1: 输入: \"9,3,4,#,#,1,#,#,2,#,6,#,#\" 输出: true 示例 2: 输入: \"1,#\" 输出: false 示例 3: 输入: \"9,#,#,1\" 输出: false 12345678910111213class Solution(object): def isValidSerialization(self, preorder): &quot;&quot;&quot; :type preorder: str :rtype: bool &quot;&quot;&quot; stk = [] for c in preorder.split(&#x27;,&#x27;): stk.append(c) while len(stk) &gt;= 3 and stk[-2:] == [&#x27;#&#x27;, &#x27;#&#x27;] and stk[-3] != &#x27;#&#x27;: stk = stk[:-3] stk.append(&#x27;#&#x27;) return stk == [&#x27;#&#x27;] 337. 打家劫舍 III [n]在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 示例 1: 输入: [3,2,3,null,3,null,1] 3 / \\ 2 3 \\ \\ 3 1 输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7. 示例 2: 输入: [3,4,5,1,3,null,1] 3 / \\ 4 5 / \\ \\ 1 3 1 输出: 9 解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9. 123456789101112131415161718192021222324class Solution(object): def rob(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; if root is None: return 0 m = &#123;&#125; return self.helper(root, m) def helper(self, root, m): if root is None: return 0 if root in m: return m[root] val = root.val if root.left: val += self.helper(root.left.left, m) + self.helper(root.left.right, m) if root.right: val += self.helper(root.right.left, m) + self.helper(root.right.right, m) res = max(val, self.helper(root.left, m) + self.helper(root.right, m)) m[root] = res return res 437. 路径总和 III给定一个二叉树，它的每个结点都存放着一个整数值。 找出路径和等于给定数值的路径总数。 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。 示例： root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\ 3 -2 1 返回 3。和等于 8 的路径有: 1. 5 -> 3 2. 5 -> 2 -> 1 3. -3 -> 11 123456789101112131415161718192021222324252627class Solution(object): def pathSum(self, root, target): &quot;&quot;&quot; :type root: TreeNode :type target: int :rtype: int &quot;&quot;&quot; if root is None: return 0 self.res = 0 queue = [root] while queue: node = queue.pop(0) self.dfs(node, target) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return self.res def dfs(self, root, target): if root is None: return if root.val == target: self.res += 1 self.dfs(root.left, target - root.val) self.dfs(root.right, target - root.val) 449. 序列化和反序列化二叉搜索树12345678910111213141516171819202122232425262728293031323334353637383940class Codec: def serialize(self, root): &quot;&quot;&quot;Encodes a tree to a single string. :type root: TreeNode :rtype: str &quot;&quot;&quot; stk, p = [], root res = [] while stk or p: while p: res.append(p.val) stk.append(p) p = p.left node = stk.pop(-1) p = node.right return &#x27; &#x27;.join(map(str, res)) def deserialize(self, data): &quot;&quot;&quot;Decodes your encoded data to tree. :type data: str :rtype: TreeNode &quot;&quot;&quot; preorder = map(int, data.split()) inorder = sorted(preorder) return self.build_tree(preorder, inorder) def build_tree(self, preorder, inorder): if not preorder: return None root_v = preorder[0] idx = inorder.index(root_v) root = TreeNode(root_v) root.left = self.build_tree(preorder[1:1+idx], inorder[:idx]) root.right =self.build_tree(preorder[1+idx:], inorder[idx+1:]) return root 450. 删除二叉搜索树中的节点 [n]给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 一般来说，删除节点可分为两个步骤： 首先找到需要删除的节点；如果找到了，删除它。说明： 要求算法时间复杂度为 O(h)，h 为树的高度。 示例: root = [5,3,6,2,4,null,7] key = 3 5 / \\ 3 6 / \\ \\ 2 4 7 给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。 一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。 5 / \\ 4 6 / \\ 2 7 另一个正确答案是 [5,2,6,null,4,null,7]。 5 / \\ 2 6 \\ \\ 4 7 12345678910111213141516171819202122232425262728class Solution(object): def deleteNode(self, root, key): &quot;&quot;&quot; :type root: TreeNode :type key: int :rtype: TreeNode &quot;&quot;&quot; if root is None: return root if key &lt; root.val: root.left = self.deleteNode(root.left, key) elif key &gt; root.val: root.right = self.deleteNode(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left else: node = self.findMin(root.right) root.val = node.val root.right = self.deleteNode(root.right, node.val) return root def findMin(self, node): while node.left: node = node.left return node 508. 出现次数最多的子树元素和给出二叉树的根，找出出现次数最多的子树元素和。一个结点的子树元素和定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。然后求出出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的元素（不限顺序）。 示例 1 输入: 5 / \\ 2 -3 返回 [2, -3, 4]，所有的值均只出现一次，以任意顺序返回所有值。 示例 2 输入: 5 / \\ 2 -5 返回 [2]，只有 2 出现两次，-5 只出现 1 次。 123456789101112131415161718192021222324252627class Solution(object): def findFrequentTreeSum(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[int] &quot;&quot;&quot; self.m = &#123;&#125; self.res = [] self.cnt = 0 self.helper(root) for k, v in self.m.iteritems(): if v == self.cnt: self.res.append(k) return self.res def helper(self, root): if root is None: return 0 left = self.helper(root.left) right = self.helper(root.right) cur_sum = left + right + root.val if cur_sum in self.m: self.m[cur_sum] += 1 else: self.m[cur_sum] = 1 self.cnt = max(self.cnt, self.m[cur_sum]) return cur_sum 538. 把二叉搜索树转换为累加树给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。 例如： 输入: 二叉搜索树: 5 / \\ 2 13 输出: 转换为累加树: 18 / \\ 20 13 12345678910111213141516171819class Solution(object): def convertBST(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; p = root stk = [] prev = 0 while p or stk: while p: stk.append(p) p = p.right node = stk.pop(-1) old_v = node.val node.val += prev prev += old_v p = node.left return root 623. 在二叉树中增加一行给定一个二叉树，根节点为第1层，深度为 1。在其第 d 层追加一行值为 v 的节点。 添加规则：给定一个深度值 d （正整数），针对深度为 d-1 层的每一非空节点 N，为 N 创建两个值为 v 的左子树和右子树。 将 N 原先的左子树，连接为新节点 v 的左子树；将 N 原先的右子树，连接为新节点 v 的右子树。 如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。 示例 1: 输入: 二叉树如下所示: 4 / \\ 2 6 / \\ / 3 1 5 v = 1 d = 2 输出: 4 / \\ 1 1 / \\ 2 6 / \\ / 3 1 5 示例 2: 输入: 二叉树如下所示: 4 / 2 / \\ 3 1 v = 1 d = 3 输出: 4 / 2 / \\ 1 1 / \\ 3 1 注意: 输入的深度值 d 的范围是：[1，二叉树最大深度 + 1]。 输入的二叉树至少有一个节点。 1234567891011121314151617181920212223242526272829303132class Solution(object): def addOneRow(self, root, v, d): &quot;&quot;&quot; :type root: TreeNode :type v: int :type d: int :rtype: TreeNode &quot;&quot;&quot; if d == 1: new_root = TreeNode(v) new_root.left = root return new_root queue = [root] for _ in xrange(d - 2): sz = len(queue) for _ in xrange(sz): node = queue.pop(0) if node.left: queue.append(node.left) if node.right: queue.append(node.right) while queue: node = queue.pop(0) tmp = node.left new_node = TreeNode(v) new_node.left = tmp node.left = new_node tmp = node.right new_node = TreeNode(v) new_node.right = tmp node.right = new_node return root 652. 寻找重复的子树 [n]给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。 两棵树重复是指它们具有相同的结构以及相同的结点值。 示例 1： 1 / \\ 2 3 / / \\ 4 2 4 / 4 下面是两个重复的子树： 2 / 4 和 4 因此，你需要以列表的形式返回上述重复子树的根结点。 1234567891011121314151617181920212223class Solution(object): def findDuplicateSubtrees(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[TreeNode] &quot;&quot;&quot; m, res = &#123;&#125;, [] self.helper(root, m) for k, v in m.iteritems(): if len(v) &gt; 1: res.append(v[0]) return res def helper(self, root, m): if root is None: return &quot;&quot; s = &quot;(&quot; + self.helper(root.left, m) + str(root.val) + \\ self.helper(root.right, m) + &quot;)&quot; if s in m: m[s].append(root) else: m[s] = [root] return s 654. 最大二叉树给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下： 二叉树的根是数组中的最大元素。 左子树是通过数组中最大值左边部分构造出的最大二叉树。 右子树是通过数组中最大值右边部分构造出的最大二叉树。 通过给定的数组构建最大二叉树，并且输出这个树的根节点。 示例 ： 输入：[3,2,1,6,0,5] 输出：返回下面这棵树的根节点： 6 / \\ 3 5 \\ / 2 0 \\ 1 提示： 给定的数组的大小在 [1, 1000] 之间。 1234567891011121314151617181920class Solution(object): def constructMaximumBinaryTree(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: TreeNode &quot;&quot;&quot; m = &#123;&#125; for idx, v in enumerate(nums): m[v] = idx return self.helper(nums, 0, len(nums) - 1, m) def helper(self, nums, left, right, m): if left &gt; right: return None max_v = max(nums[left: right + 1]) max_idx = m[max_v] root = TreeNode(max_v) root.left = self.helper(nums, left, max_idx - 1, m) root.right = self.helper(nums, max_idx + 1, right, m) return root 655. 输出二叉树 [n]在一个 m*n 的二维字符串数组中输出二叉树，并遵守以下规则： 行数 m 应当等于给定二叉树的高度。 列数 n 应当总是奇数。 根节点的值（以字符串格式给出）应当放在可放置的第一行正中间。根节点所在的行与列会将剩余空间划分为两部分（左下部分和右下部分）。你应该将左子树输出在左下部分，右子树输出在右下部分。左下和右下部分应当有相同的大小。即使一个子树为空而另一个非空，你不需要为空的子树输出任何东西，但仍需要为另一个子树留出足够的空间。然而，如果两个子树都为空则不需要为它们留出任何空间。 每个未使用的空间应包含一个空的字符串””。 使用相同的规则输出子树。 示例 1: 输入: 1 / 2 输出: [[\"\", \"1\", \"\"], [\"2\", \"\", \"\"]] 示例 2: 输入: 1 / \\ 2 3 \\ 4 输出: [[\"\", \"\", \"\", \"1\", \"\", \"\", \"\"], [\"\", \"2\", \"\", \"\", \"\", \"3\", \"\"], [\"\", \"\", \"4\", \"\", \"\", \"\", \"\"]] 示例 3: 输入: 1 / \\ 2 5 / 3 / 4 输出: [[\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"1\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"] [\"\", \"\", \"\", \"2\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"5\", \"\", \"\", \"\"] [\"\", \"3\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"] [\"4\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]] 注意: 二叉树的高度在范围 [1, 10] 中。 1234567891011121314151617181920212223242526class Solution(object): def printTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[List[str]] &quot;&quot;&quot; if root is None: return [] height = self.getHeight(root) width = (1 &lt;&lt; height) - 1 res = [[&quot;&quot;] * width for _ in xrange(height)] self.helper(root, 0, width - 1, 0, height, res) return res def helper(self, root, left, right, h, height, res): if root is None or h == height: return mid = (left + right) / 2 res[h][mid] = str(root.val) self.helper(root.left, left, mid - 1, h + 1, height, res) self.helper(root.right, mid + 1, right, h + 1, height, res) def getHeight(self, root): if root is None: return 0 return max(self.getHeight(root.left), self.getHeight(root.right)) + 1 687. 最长同值路径 [n]给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。 注意：两个节点之间的路径长度由它们之间的边数表示。 示例 1: 输入: 5 / \\ 4 5 / \\ \\ 1 1 5 输出: 2 示例 2: 输入: 1 / \\ 4 5 / \\ \\ 4 4 5 输出: 2 注意: 给定的二叉树不超过10000个结点。 树的高度不超过1000。 12345678910111213141516171819202122class Solution(object): def longestUnivaluePath(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; self.res = 0 self.helper(root) return self.res def helper(self, root): if root is None: return 0 left = self.helper(root.left) right = self.helper(root.right) pl, pr = 0, 0 if root.left and root.left.val == root.val: pl = left + 1 if root.right and root.right.val == root.val: pr = right + 1 self.res = max(self.res, pl + pr) return max(pl, pr) 701. 二叉搜索树中的插入操作给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。 例如, 给定二叉搜索树: 4 / \\ 2 7 / \\ 1 3 和 插入的值: 5 你可以返回这个二叉搜索树: 4 / \\ 2 7 / \\ / 1 3 5 或者这个树也是有效的: 5 / \\ 2 7 / \\ 1 3 \\ 4 1234567891011121314class Solution(object): def insertIntoBST(self, root, val): &quot;&quot;&quot; :type root: TreeNode :type val: int :rtype: TreeNode &quot;&quot;&quot; if root is None: return TreeNode(val) if root.val &gt; val: root.left = self.insertIntoBST(root.left, val) else: root.right = self.insertIntoBST(root.right, val) return root 814. 二叉树剪枝 [n]给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。 返回移除了所有不包含 1 的子树的原二叉树。 ( 节点 X 的子树为 X 本身，以及所有 X 的后代。) 示例1: 输入: [1,null,0,0,1] 输出: [1,null,0,null,1] 解释: 只有红色节点满足条件“所有不包含 1 的子树”。 右图为返回的答案。 示例2: 输入: [1,0,1,0,0,0,1] 输出: [1,null,1,null,1] 示例3: 输入: [1,1,0,1,1,0,1,0] 输出: [1,1,0,1,1,null,1] 说明: 给定的二叉树最多有 100 个节点。 每个节点的值只会为 0 或 1 。 12345678910111213class Solution(object): def pruneTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; if root is None: return None root.left = self.pruneTree(root.left) root.right = self.pruneTree(root.right) if root.left is None and root.right is None and root.val == 0: return None return root 863. 二叉树中所有距离为 K 的结点 [n]给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。 返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。 示例 1： 输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2 输出：[7,4,1] 解释： 所求结点为与目标结点（值为 5）距离为 2 的结点， 值分别为 7，4，以及 1 提示： 给定的树是非空的，且最多有 K 个结点。 树上的每个结点都具有唯一的值 0 &lt;= node.val &lt;= 500 。 目标结点 target 是树上的结点。 0 &lt;= K &lt;= 1000. 123456789101112131415161718192021222324252627282930313233class Solution(object): def distanceK(self, root, target, K): &quot;&quot;&quot; :type root: TreeNode :type target: TreeNode :type K: int :rtype: List[int] &quot;&quot;&quot; m = collections.defaultdict(list) self.helper(None, root, m) queue = [target.val] visited = set([target.val]) for _ in xrange(K): sz = len(queue) for _ in xrange(sz): v = queue.pop(0) for i in m[v]: if i not in visited: visited.add(i) queue.append(i) return queue def helper(self, parent, child, m): if parent and child: m[child.val].append(parent.val) m[parent.val].append(child.val) if child.left: self.helper(child, child.left, m) if child.right: self.helper(child, child.right, m) 865. 具有所有最深结点的最小子树 [n]给定一个根为 root 的二叉树，每个结点的深度是它到根的最短距离。 如果一个结点在整个树的任意结点之间具有最大的深度，则该结点是最深的。 一个结点的子树是该结点加上它的所有后代的集合。 返回能满足“以该结点为根的子树中包含所有最深的结点”这一条件的具有最大深度的结点。 示例： 输入：[3,5,1,6,2,0,8,null,null,7,4] 输出：[2,7,4] 解释： 我们返回值为 2 的结点，在图中用黄色标记。 在图中用蓝色标记的是树的最深的结点。 输入 \"[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]\" 是对给定的树的序列化表述。 输出 \"[2, 7, 4]\" 是对根结点的值为 2 的子树的序列化表述。 输入和输出都具有 TreeNode 类型。 提示： 树中结点的数量介于 1 和 500 之间。 每个结点的值都是独一无二的。 12345678910111213141516171819class Solution(object): def subtreeWithAllDeepest(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; depth, res = self.helper(root) return res def helper(self, root): if root is None: return (0, None) left_pair = self.helper(root.left) right_pair = self.helper(root.right) dl, dr = left_pair[0], right_pair[0] root_depth = max(dl, dr) + 1 if dl == dr: return (root_depth, root) return (root_depth, left_pair[1]) if dl &gt; dr else (root_depth, right_pair[1]) 894. 所有可能的满二叉树 [n]满二叉树是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。 返回包含 N 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。 答案中每个树的每个结点都必须有 node.val=0。 你可以按任何顺序返回树的最终列表。 示例： 输入：7 输出： [[0,0,0,null,null,0,0,null,null,0,0], [0,0,0,null,null,0,0,0,0], [0,0,0,0,0,0,0], [0,0,0,0,0,null,null,null,null,0,0], [0,0,0,0,0,null,null,0,0]] 123456789101112131415161718192021class Solution(object): def allPossibleFBT(self, N): &quot;&quot;&quot; :type N: int :rtype: List[TreeNode] &quot;&quot;&quot; if N % 2 == 0: return [] if N == 1: return [TreeNode(0)] res = [] for i in xrange(1, N, 2): lefts = self.allPossibleFBT(i) rights = self.allPossibleFBT(N - 1 - i) for left in lefts: for right in rights: root = TreeNode(0) root.left = left root.right = right res.append(root) return res 951. 翻转等价二叉树 [n]我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。 只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转等价于二叉树 Y。 编写一个判断两个二叉树是否是翻转等价的函数。这些树由根节点 root1 和 root2 给出。 示例： 输入：root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7] 输出：true 解释：We flipped at nodes with values 1, 3, and 5. 提示： 每棵树最多有 100 个节点。 每棵树中的每个值都是唯一的、在 [0, 99] 范围内的整数。 12345678910111213141516class Solution(object): def flipEquiv(self, root1, root2): &quot;&quot;&quot; :type root1: TreeNode :type root2: TreeNode :rtype: bool &quot;&quot;&quot; if root1 == root2: return True if root1 is None or root2 is None or root1.val != root2.val: return False a = self.flipEquiv(root1.left, root2.left) and \\ self.flipEquiv(root1.right, root2.right) b = self.flipEquiv(root1.left, root2.right) and \\ self.flipEquiv(root1.right, root2.left) return a or b 958. 二叉树的完全性检验给定一个二叉树，确定它是否是一个完全二叉树。 百度百科中对完全二叉树的定义如下： 若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。） 1234567891011121314151617181920class Solution(object): def isCompleteTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; if root is None: return True queue = [root] flag = False while queue: node = queue.pop(0) if node: if flag: return False queue.append(node.left) queue.append(node.right) else: flag = True return True 971. 翻转二叉树以匹配先序遍历 [n]给定一个有 N 个节点的二叉树，每个节点都有一个不同于其他节点且处于 {1, …, N} 中的值。 通过交换节点的左子节点和右子节点，可以翻转该二叉树中的节点。 考虑从根节点开始的先序遍历报告的 N 值序列。将这一 N 值序列称为树的行程。 （回想一下，节点的先序遍历意味着我们报告当前节点的值，然后先序遍历左子节点，再先序遍历右子节点。） 我们的目标是翻转最少的树中节点，以便树的行程与给定的行程 voyage 相匹配。 如果可以，则返回翻转的所有节点的值的列表。你可以按任何顺序返回答案。 如果不能，则返回列表 [-1]。 示例 1： 输入：root = [1,2], voyage = [2,1] 输出：[-1] 示例 2： 输入：root = [1,2,3], voyage = [1,3,2] 输出：[1] 示例 3： 输入：root = [1,2,3], voyage = [1,2,3] 输出：[] 提示： 1 &lt;= N &lt;= 100 12345678910111213141516171819202122232425class Solution(object): def flipMatchVoyage(self, root, voyage): &quot;&quot;&quot; :type root: TreeNode :type voyage: List[int] :rtype: List[int] &quot;&quot;&quot; self.pos, self.res = 0, [] self.dfs(root, voyage) print(self.res) return self.res def dfs(self, root, voyage): if root is None: return if root.val != voyage[self.pos]: self.res = [-1] return self.res if root.left and root.left.val != voyage[self.pos + 1]: root.left, root.right = root.right, root.left self.res.append(root.val) self.pos += 1 self.dfs(root.left, voyage) self.dfs(root.right, voyage) 979. 在二叉树中分配硬币 [n]给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。 在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。 返回使每个结点上只有一枚硬币所需的移动次数。 示例 1： 输入：[3,0,0] 输出：2 解释：从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。 示例 2： 输入：[0,3,0] 输出：3 解释：从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。 示例 3： 输入：[1,0,2] 输出：2 示例 4： 输入：[1,0,0,null,3] 输出：4 提示： 1&lt;= N &lt;= 100 0 &lt;= node.val &lt;= N 1234567891011121314151617class Solution(object): def distributeCoins(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; self.res = 0 self.helper(root) return self.res def helper(self, root): if root is None: return 0 left = self.helper(root.left) right = self.helper(root.right) self.res += abs(left) + abs(right) return root.val - 1 + left + right","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"那些我认为不错的计算机专业书(仅面向后台开发)","slug":"计算机专业图书推荐","date":"2020-12-04T13:40:04.000Z","updated":"2020-12-26T07:22:20.084Z","comments":false,"path":"posts/4f424561.html","link":"","permalink":"https://leel0330.github.io/posts/4f424561.html","excerpt":"如果你是程序员新人，那么这篇文章对你很有用，能让你少走一些弯路，多看一些经典书籍，打下扎实的计算机基础。 如果你是职场老鸟，那么这篇文章可能适合选读。有些书还是不错的，值得多读几遍。 友情提示：点击图书可以跳转到豆瓣，查看相应图书的目录内容和用户评价。","text":"如果你是程序员新人，那么这篇文章对你很有用，能让你少走一些弯路，多看一些经典书籍，打下扎实的计算机基础。 如果你是职场老鸟，那么这篇文章可能适合选读。有些书还是不错的，值得多读几遍。 友情提示：点击图书可以跳转到豆瓣，查看相应图书的目录内容和用户评价。 前言，那些我想对你说的话作为一名程序员，猿龄有四五年了。断断续续看了不少专业书，有些书还是让我成长了不少的，所以安耐不住内心的冲动，非常想分享一波，正好借本人的博客与大家交流一下☺️。 可以这么说，每个分类都是本人精心挑选过的，本人也有看过才会推荐。不过一千个读者眼里有一千个哈姆雷特，每个人的经历和认知差异比较大，很难满足每个人的口味。所以这里只是挑选出每个分类下个人认为不错的top3。 再次提示：点击图书可以跳转到豆瓣，查看相应图书的目录内容和用户评价哦~ 慢着，看XX语言之前你可能需要先看这里，嘿嘿我想你的脑子里肯定蹦出来一句话:”你给我推荐这么多语言的书看虾米，我看不过来啊!“。是的，你看不过来的，我也看不过来，但是我为了推荐的完整性，就都罗列出来了。 不瞒你说，你需要从上述基本语言挑出你自己喜欢的主力语言和辅助语言了，因为不同语言可以满足不同的需求，有它自身的一些特点。选择的话你可以考虑以下几点: 不会就选C。所以说它是必修课!(是的，你没看错就是C语言！你没得选，因为计算机软件专业课，第一门要学的语言就是它！这里强调一点，Linux操作系统就是C语言实现的哦！) 这门语言好学吗？我现在很想快点上手写一些代码呢？！(这条我推Python，只此一家，别无分店) 简单的我不想学，我想先学有难度的，因为难得东西好哈哈！(这条不说了，大家都明白，选C++吧，你会爱上它的o(￣︶￣)o) 我只想学一门语言，而且我想在这门语言深耕。(嗯不错，专一挺好的，那我推荐C++或者Java) 我已经会了C，也学了一门面向对象的语言(C++或者Java)，我想扩展一下，那可以学下Go看看。 时间是有限的，你不可能上来就什么都学，那样的话你什么都没有学会，还有可能因为学太多而走火入魔。早点做选择也没有坏处，需要做选择的时候就要果断点。当然你可以先大概了解一下每一门语言然后再深入学你喜欢的，这样也没问题的。 废话少说，快开始你的表演吧~，那我就开始咯，show time! C语言 C++语言因为C++很难，所以这里多推荐一些书，哈哈，可能这里就劝退了一波人啦，坚持下来的人加油哦！高精尖技术等着你开发呢😀~ Java语言老实说，Java要推荐的书也不少。 Python语言Python版本有2和3之分，2的话官方好像已经停止维护了，所以推荐直接学Python3吧。 Go语言 数据结构和算法 操作系统这几本操作系统书内容比较全面，对本科生来说深度也可以。需要重点关注的章节是进程、内存和IO。 计算机网络现在的应用程序可以说都离不开网络，无论什么客户端，都需要和server进行交互去拿相应的数据。因此掌握计算机网络相关知识就显得尤为重要。 对与《TCP/IP详解 卷1：协议》和《计算机网络》这两本书，需要重点关注的是运输层和应用层。也就是TCP/UDP和HTTP这几个协议。毕竟和程序员打交道最多的就是这两层了。希望同学能认真读完并掌握哦~ 对于《UNIX网络编程 卷1》。最需要掌握的是C/S编程范式(主要是tcp的socket编程，包括多进程、多线程和I/O复用)。 Linux编程 后记，既然看到这里了，再听我唠叨几句又何妨(手动狗头)如果你认真看完了上面所列的书籍，除了运气成分外，面大厂你的基础应该是很扎实了，但是有句话还是要讲一下就是”纸上得来终觉浅，绝知此事要躬行”，这句话对看这篇文章的人讲，也是对我自己讲。实践是1，看书是0，有了实践再看书相当于往1后面添加0，如果不实践看再多的书也是0。希望和大家一起共勉把！","categories":[{"name":"Book","slug":"Book","permalink":"https://leel0330.github.io/categories/Book/"}],"tags":[]},{"title":"LeetCode之二叉树(简单)","slug":"LeetCode-二叉树-简单","date":"2020-12-03T13:26:41.000Z","updated":"2020-12-26T07:21:45.879Z","comments":false,"path":"posts/94def828.html","link":"","permalink":"https://leel0330.github.io/posts/94def828.html","excerpt":"二叉树(简单)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"二叉树(简单)的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 101. 对称二叉树给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 Python(BFS)Python(递归)1234567891011121314151617181920212223class Solution(object): def isSymmetric(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; if root is None: return True queue = [root, root] while queue: t1 = queue.pop(0) t2 = queue.pop(0) if t1 is None and t2 is None: continue if t1 is None or t2 is None: return False if t1.val != t2.val: return False queue.append(t1.left) queue.append(t2.right) queue.append(t1.right) queue.append(t2.left) return True123456789101112131415class Solution(object): def isSymmetric(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; return self.isMirror(root, root) def isMirror(self, p, q): if p is None and q is None: return True if p is None or q is None: return False return p.val == q.val and self.isMirror(p.left, q.right) \\ and self.isMirror(p.right, q.left) 110. 平衡二叉树给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 示例 1: 给定二叉树 [3,9,20,null,null,15,7] 3 / \\ 9 20 / \\ 15 7 返回 true 。 示例 2: 给定二叉树 [1,2,2,3,3,null,null,4,4] 1 / \\ 2 2 / \\ 3 3 / \\ 4 4 返回 false 。 1234567891011121314151617181920class Solution(object): def isBalanced(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; return self.helper(root) != -1 def helper(self, root): if root is None: return 0 left_height = self.helper(root.left) if left_height == -1: return -1 right_height = self.helper(root.right) if right_height == -1: return -1 if abs(left_height - right_height) &gt; 1: return -1 return 1 + max(left_height, right_height) 111. 二叉树的最小深度给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回它的最小深度 2. 123456789101112131415161718192021class Solution(object): def minDepth(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; if not root: return 0 queue = [root] level = 0 while queue: n = len(queue) level += 1 for i in xrange(n): node = queue.pop(0) if node.left is None and node.right is None: return level if node.left: queue.append(node.left) if node.right: queue.append(node.right) 226. 翻转二叉树翻转一棵二叉树。 示例： 输入： 4 / \\ 2 7 / \\ / \\ 1 3 6 9 输出： 4 / \\ 7 2 / \\ / \\ 9 6 3 1 1234567891011121314151617class Solution(object): def invertTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; if not root: return root queue = [root] while queue: node = queue.pop(0) node.left, node.right = node.right, node.left if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root 257. 二叉树的所有路径给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 输入: 1 / \\ 2 3 \\ 5 输出: [\"1->2->5\", \"1->3\"] 解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3 123456789101112131415161718192021class Solution(object): def binaryTreePaths(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[str] &quot;&quot;&quot; if not root: return [] item, res = [], [] self.dfs(root, item, res) return res def dfs(self, root, item, res): if root is None: return if root.left is None and root.right is None: tmp = item[:] + [str(root.val)] res.append(&#x27;-&gt;&#x27;.join(tmp)) return self.dfs(root.left, item + [str(root.val)], res) self.dfs(root.right, item + [str(root.val)], res) 501. 二叉搜索树中的众数 [n]给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。 假定 BST 有如下定义： 结点左子树中所含结点的值小于等于当前结点的值 结点右子树中所含结点的值大于等于当前结点的值 左子树和右子树都是二叉搜索树 例如： 给定 BST [1,null,2,2], 1 \\ 2 / 2 返回[2]. 提示：如果众数超过1个，不需考虑输出顺序 进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内） 123456789101112131415161718192021222324252627282930class Solution(object): def findMode(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[int] &quot;&quot;&quot; self.count = 0 self.max_count = 0 self.res = [] self.prev = None self.helper(root) return self.res def helper(self, root): if root is None: return self.helper(root.left) if self.prev is None: self.count = 1 elif self.prev.val == root.val: self.count += 1 else: self.count = 1 self.prev = root if self.count == self.max_count: self.res.append(self.prev.val) if self.count &gt; self.max_count: self.max_count = self.count self.res = [self.prev.val] self.helper(root.right) 543. 二叉树的直径给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。 示例 : 给定二叉树 1 / \\ 2 3 / \\ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。 注意：两结点之间的路径长度是以它们之间边的数目表示。 1234567891011121314151617class Solution(object): def diameterOfBinaryTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; self.ans = 1 self.helper(root) return self.ans - 1 def helper(self, root): if not root: return 0 left = self.helper(root.left) right = self.helper(root.right) self.ans = max(self.ans, left + right + 1) return max(left, right) + 1 563. 二叉树的坡度给定一个二叉树，计算整个树的坡度。 一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。 整个树的坡度就是其所有节点的坡度之和。 示例: 输入: 1 / \\ 2 3 输出: 1 解释: 结点的坡度 2 : 0 结点的坡度 3 : 0 结点的坡度 1 : |2-3| = 1 树的坡度 : 0 + 0 + 1 = 1 1234567891011121314151617class Solution(object): def findTilt(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; self.res = 0 self.helper(root) return self.res def helper(self, root): if root is None: return 0 L = self.helper(root.left) R = self.helper(root.right) self.res += abs(L - R) return L + R + root.val 572. 另一个树的子树给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。 示例 1: 给定的树 s: 3 / \\ 4 5 / \\ 1 2 给定的树 t： 4 / \\ 1 2 返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。 示例 2: 给定的树 s： 3 / \\ 4 5 / \\ 1 2 / 0 给定的树 t： 4 / \\ 1 2 返回 false。 123456789101112131415161718192021222324252627class Solution(object): def isSubtree(self, s, t): &quot;&quot;&quot; :type s: TreeNode :type t: TreeNode :rtype: bool &quot;&quot;&quot; queue = [s] while queue: node = queue.pop(0) if self.isSameTree(node, t): return True if node.left: queue.append(node.left) if node.right: queue.append(node.right) return False def isSameTree(self, s, t): if s is None and t is None: return True if s is None or t is None: return False if s.val != t.val: return False return self.isSameTree(s.left, t.left) \\ and self.isSameTree(s.right, t.right) 606. 根据二叉树创建字符串 [n]你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。 空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。 示例 1: 输入: 二叉树: [1,2,3,4] 1 / \\ 2 3 / 4 输出: \"1(2(4))(3)\" 解释: 原本将是“1(2(4)())(3())”， 在你省略所有不必要的空括号对之后， 它将是“1(2(4))(3)”。 示例 2: 输入: 二叉树: [1,2,3,null,4] 1 / \\ 2 3 \\ 4 输出: \"1(2()(4))(3)\" 解释: 和第一个示例相似， 除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。 12345678910111213class Solution(object): def tree2str(self, t): &quot;&quot;&quot; :type t: TreeNode :rtype: str &quot;&quot;&quot; if t is None: return &quot;&quot; if t.left is None and t.right is None: return str(t.val) left = &#x27;()&#x27; if t.left is None else &#x27;(&#x27; + self.tree2str(t.left) + &#x27;)&#x27; right = &#x27;&#x27; if t.right is None else &#x27;(&#x27; + self.tree2str(t.right) + &#x27;)&#x27; return str(t.val) + left + right 897. 递增顺序查找树给定一个树，按中序遍历重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。 示例 ： 输入：[5,3,6,2,4,null,8,1,null,null,null,7,9] 5 / \\ 3 6 / \\ \\ 2 4 8 / / \\ 1 7 9 输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 \\ 7 \\ 8 \\ 9 提示： 给定树中的结点数介于 1 和 100 之间。 每个结点都有一个从 0 到 1000 范围内的唯一整数值。 1234567891011121314151617181920212223242526class Solution(object): def increasingBST(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; res = self.inorder(root) if not res: return None for i in xrange(len(res) - 1): res[i].right = res[i + 1] return res[0] def inorder(self, root): res = [] p = root stk = [] while p or stk: while p: stk.append(p) p = p.left node = stk.pop(-1) node.left = None res.append(node) p = node.right return res 993. 二叉树的堂兄弟节点在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。 如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。 我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。 只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。 示例 1： 输入：root = [1,2,3,4], x = 4, y = 3 输出：false 示例 2： 输入：root = [1,2,3,null,4,null,5], x = 5, y = 4 输出：true 示例 3： 输入：root = [1,2,3,null,4], x = 2, y = 3 输出：false 提示： 二叉树的节点数介于 2 到 100 之间。 每个节点的值都是唯一的、范围为 1 到 100 的整数。 12345678910111213141516171819202122232425262728class Solution(object): def isCousins(self, root, x, y): &quot;&quot;&quot; :type root: TreeNode :type x: int :type y: int :rtype: bool &quot;&quot;&quot; if root is None: return False queue = [(root, None)] m = &#123;&#125; depth = 0 while queue: sz = len(queue) for i in xrange(sz): node, parent = queue.pop(0) m[node.val] = (parent, depth) if node.left: queue.append((node.left, node)) if node.right: queue.append((node.right, node)) depth += 1 px, dx = m[x] py, dy = m[y] return px != py and dx == dy","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode之链表","slug":"LeetCode-链表","date":"2020-11-29T04:27:42.000Z","updated":"2020-12-26T07:22:08.843Z","comments":false,"path":"posts/fb43e507.html","link":"","permalink":"https://leel0330.github.io/posts/fb43e507.html","excerpt":"链表的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"链表的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 24. 两两交换链表中的节点给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例: 给定 1->2->3->4, 你应该返回 2->1->4->3. 12345678910111213141516171819202122class Solution(object): def swapPairs(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if head is None or head.next is None: return head dummy = ListNode(-1) dummy.next = head r = dummy p, q = head, head.next while p and q: r.next = q p.next = q.next q.next = p r = p p = r.next q = p.next if p else None r = dummy.next dummy.next = None return r 82. 删除排序链表中的重复元素 II给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1: 输入: 1->2->3->3->4->4->5 输出: 1->2->5 示例 2: 输入: 1->1->1->2->3 输出: 2->3 123456789101112131415161718192021222324252627class Solution(object): def deleteDuplicates(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if head is None or head.next is None: return head dummy = ListNode(-1) dummy.next = head p, cur = dummy, head while cur: cnt = 1 v = cur.val while cur.next and cur.next.val == v: cur = cur.next cnt += 1 if cnt == 1: p.next = cur cur = cur.next p = p.next else: p.next = cur.next cur = cur.next p = dummy.next dummy.next = None return p 92. 反转链表 II反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明: 1 ≤ m ≤ n ≤ 链表长度。 示例: 输入: 1->2->3->4->5->NULL, m = 2, n = 4 输出: 1->4->3->2->5->NULL 1234567891011121314151617181920212223242526class Solution &#123; public ListNode reverseBetween(ListNode head, int m, int n) &#123; ListNode dummy = new ListNode(-1); dummy.next = head; ListNode prev = dummy, cur = head; int step = 0; while (step &lt; m - 1) &#123; prev = prev.next; cur = cur.next; step += 1; &#125; for (int i = 0; i &lt; n - m; i++) &#123; ListNode removed = cur.next; cur.next = cur.next.next; removed.next = prev.next; prev.next = removed; &#125; ListNode newHead = dummy.next; dummy.next = null; return newHead; &#125;&#125; 109. 有序链表转换二叉搜索树给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 PythonJava12345678910111213141516171819class Solution(object): def sortedListToBST(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: TreeNode &quot;&quot;&quot; return self.buildTree(head, None) def buildTree(self, head, tail): if head == tail: return None fast = slow = head while fast != tail and fast.next != tail: fast = fast.next.next slow = slow.next root = TreeNode(slow.val) root.left = self.buildTree(head, slow) root.right = self.buildTree(slow.next, tail) return root1234567891011121314151617181920class Solution &#123; public TreeNode sortedListToBST(ListNode head) &#123; return buildTree(head, null); &#125; public TreeNode buildTree(ListNode head, ListNode tail) &#123; if (head == tail) &#123; return null; &#125; ListNode fast = head, slow = head; while (fast != tail &amp;&amp; fast.next != tail) &#123; fast = fast.next.next; slow = slow.next; &#125; TreeNode root = new TreeNode(slow.val); root.left = buildTree(head, slow); root.right = buildTree(slow.next, tail); return root; &#125;&#125; 142. 环形链表 II给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 12345678910111213141516171819class Solution(object): def detectCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; fast, slow = head, head while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: break if fast is None or fast.next is None: return None fast = head while slow != fast: slow = slow.next fast = fast.next return slow 143. 重排链表给定一个单链表 L：L0→L1→…→Ln-1→Ln ，将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1: 给定链表 1->2->3->4, 重新排列为 1->4->2->3. 示例 2: 给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3. 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution(object): def reorderList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: None Do not return anything, modify head in-place instead. &quot;&quot;&quot; if head is None or head.next is None: return prev = None fast, slow = head, head while fast and fast.next: prev = slow slow = slow.next fast = fast.next.next prev.next = None slow = self.reverseList(slow) dummy = ListNode(-1) p = dummy while slow and head: ts, th = slow.next, head.next p.next = head p.next.next = slow slow = ts head = th p = p.next.next p.next = slow if slow else head p = dummy.next dummy.next = None def reverseList(self, head): if head is None or head.next is None: return head p, q = None, head while q: r = q.next q.next = p p = q q = r return p 147. 对链表进行插入排序 [n]12345678910111213141516171819202122class Solution(object): def insertionSortList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if head is None or head.next is None: return head dummy = ListNode(0) dummy.next = head while head.next: if head.val &lt;= head.next.val: head = head.next else: tmp = head.next head.next = tmp.next q = dummy while q.next and q.next.val &lt;= tmp.val: q = q.next tmp.next = q.next q.next = tmp return dummy.next 148. 排序链表merge sort 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def sortList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if head is None or head.next is None: return head prev, fast, slow = None, head, head while fast and fast.next: prev = slow fast = fast.next.next slow = slow.next prev.next = None head = self.sortList(head) slow = self.sortList(slow) return self.merge(head, slow) def merge(self, l1, l2): dummy = ListNode(-1) p = dummy while l1 and l2: if l1.val &lt; l2.val: p.next = l1 l1 = l1.next else: p.next = l2 l2 = l2.next p = p.next p.next = l1 if l1 else l2 p = dummy.next dummy.next = None return p 234. 回文链表请判断一个链表是否为回文链表。 示例 1: 输入: 1->2 输出: false 示例 2: 输入: 1->2->2->1 输出: true 12345678910111213141516171819202122232425262728293031323334class Solution(object): def isPalindrome(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; if head is None or head.next is None: return True mid = self.get_mid_node(head) mid = self.reverse_list(mid) while mid: if mid.val != head.val: return False mid = mid.next head = head.next return True def get_mid_node(self, head): slow, fast = head, head while fast and fast.next: fast = fast.next.next slow = slow.next return slow def reverse_list(self, head): if head is None or head.next is None: return head p, q = None, head while q: r = q.next q.next = p p = q q = r return p 328. 奇偶链表给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。 示例 1: 输入: 1->2->3->4->5->NULL 输出: 1->3->5->2->4->NULL 示例 2: 输入: 2->1->3->5->6->4->7->NULL 输出: 2->3->6->7->1->5->4->NULL 说明: 应当保持奇数节点和偶数节点的相对顺序。 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。 123456789101112131415161718192021222324class Solution(object): def oddEvenList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if head is None or head.next is None: return head new_head_p, new_head_q = head, head.next p, q = head, head.next prev = None while p: next_p = q.next if q else None next_q = next_p.next if next_p else None p.next = next_p if q: q.next = next_q prev = p p = next_p q = next_q prev.next = new_head_q return new_head_p 430. 扁平化多级双向链表 [n]您将获得一个双向链表，除了下一个和前一个指针之外，它还有一个子指针，可能指向单独的双向链表。这些子列表可能有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。 扁平化列表，使所有结点出现在单级双链表中。您将获得列表第一级的头部。 示例: 输入: 1---2---3---4---5---6--NULL | 7---8---9---10--NULL | 11--12--NULL 输出: 1-2-3-7-8-11-12-9-10-4-5-6-NULL 123456789101112131415161718192021222324class Solution(object): def flatten(self, head): &quot;&quot;&quot; :type head: Node :rtype: Node &quot;&quot;&quot; self.dfs(head) return head def dfs(self, head): cur = head while cur: if cur.child: next = cur.next cur.next = cur.child cur.next.prev = cur child_last = self.dfs(cur.child) child_last.next = next if next: next.prev = child_last cur.child = None head = cur cur = cur.next return head 1019. 链表中的下一个更大节点给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, … 。 每个节点都可能有下一个更大值（next larger value）：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j &gt; i 且 node_j.val &gt; node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。 返回整数答案数组 answer，其中 answer[i] = next_larger(node_{i+1}) 。 注意：在下面的示例中，诸如 [2,1,5] 这样的输入（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。 示例 1： 输入：[2,1,5] 输出：[5,5,0] 示例 2： 输入：[2,7,4,3,5] 输出：[7,0,5,5,0] 示例 3： 输入：[1,7,5,1,9,2,5,1] 输出：[7,9,9,9,0,5,0,0] 提示： 对于链表中的每个节点，1 &lt;= node.val &lt;= 10^9 给定列表的长度在 [0, 10000] 范围内 1234567891011121314151617class Solution(object): def nextLargerNodes(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: List[int] &quot;&quot;&quot; nums = [] while head: nums.append(head.val) head = head.next res = [0] * len(nums) stk = [] for i, v in enumerate(nums): while stk and nums[stk[-1]] &lt; v: res[stk.pop()] = v stk.append(i) return res 1171. 从链表中删去总和值为零的连续节点 [n]给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。 删除完毕后，请你返回最终结果链表的头节点。 你可以返回任何满足题目要求的答案。 （注意，下面示例中的所有序列，都是对 ListNode 对象序列化的表示。） 示例 1： 输入：head = [1,2,-3,3,1] 输出：[3,1] 提示：答案 [1,2,1] 也是正确的。 示例 2： 输入：head = [1,2,3,-3,4] 输出：[1,2,4] 示例 3： 输入：head = [1,2,3,-3,-2] 输出：[1] 提示： 给你的链表中可能有 1 到 1000 个节点。 对于链表中的每个节点，节点的值：-1000 &lt;= node.val &lt;= 1000. 12345678910111213141516171819202122232425262728class Solution(object): def removeZeroSumSublists(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; m = &#123;&#125; dummy = ListNode(0) dummy.next = head p = dummy total = 0 while p: total += p.val m[total] = p p = p.next total = 0 p = dummy while p: total += p.val p.next = m[total].next p = p.next p = dummy.next dummy.next = None return p","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode之栈和队列","slug":"LeetCode-栈和队列","date":"2020-11-28T03:50:05.000Z","updated":"2020-12-26T07:22:05.265Z","comments":false,"path":"posts/1ccb8d85.html","link":"","permalink":"https://leel0330.github.io/posts/1ccb8d85.html","excerpt":"栈与队列的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"栈与队列的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 394. 字符串解码给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例: s = \"3[a]2[bc]\", 返回 \"aaabcbc\". s = \"3[a2[c]]\", 返回 \"accaccacc\". s = \"2[abc]3[cd]ef\", 返回 \"abcabccdcdcdef\". PythonJava12345678910111213141516171819class Solution(object): def decodeString(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; stack, res, multi = [], &quot;&quot;, 0 for c in s: if c == &#x27;[&#x27;: stack.append([multi, res]) res, multi = &quot;&quot;, 0 elif c == &#x27;]&#x27;: cur_multi, last_res = stack.pop() res = last_res + cur_multi * res elif &#x27;0&#x27; &lt;= c &lt;= &#x27;9&#x27;: multi = multi * 10 + int(c) else: res += c return res12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; class Item &#123; public int num; public String str; public Item(int n, String s) &#123; this.num = n; this.str = s; &#125; &#125; public String decodeString(String s) &#123; String res = &quot;&quot;; int multi = 0; Stack&lt;Item&gt; stk = new Stack&lt;&gt;(); for(int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if(c == &#x27;[&#x27;) &#123; stk.add(new Item(multi, res)); res = &quot;&quot;; multi = 0; &#125;else if(c == &#x27;]&#x27;) &#123; Item item = stk.pop(); StringBuilder sb = new StringBuilder(); for(int k = 0; k &lt; item.num; k++) &#123; sb.append(res); &#125; res = item.str + sb.toString(); &#125;else if(c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; multi = multi * 10 + Integer.parseInt(c + &quot;&quot;); &#125;else&#123; res += c; &#125; &#125; return res; &#125;&#125; 402. 移掉K位数字给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。 注意: num 的长度小于 10002 且 ≥ k。 num 不会包含任何前导零。 示例 1 : 输入: num = \"1432219\", k = 3 输出: \"1219\" 解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。 示例 2 : 输入: num = \"10200\", k = 1 输出: \"200\" 解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。 示例 3 : 输入: num = \"10\", k = 2 输出: \"0\" 解释: 从原数字移除所有的数字，剩余为空就是0。 PythonJava12345678910111213141516171819class Solution(object): def removeKdigits(self, num, k): &quot;&quot;&quot; :type num: str :type k: int :rtype: str &quot;&quot;&quot; stk = [] for c in num: while k and stk and stk[-1] &gt; c: stk.pop(-1) k -= 1 stk.append(c) while k: stk.pop(-1) k -= 1 if not stk: return &#x27;0&#x27; return str(int(&#x27;&#x27;.join(stk)))12345678910111213141516171819202122232425262728class Solution &#123; public String removeKdigits(String num, int k) &#123; Stack&lt;Character&gt; stk = new Stack&lt;&gt;(); for (int i = 0; i &lt; num.length(); i++) &#123; char c = num.charAt(i); while (k &gt; 0 &amp;&amp; !stk.empty() &amp;&amp; stk.peek() &gt; c) &#123; stk.pop(); k -= 1; &#125; stk.add(c); &#125; while (k &gt; 0) &#123; stk.pop(); k -= 1; &#125; while (!stk.empty() &amp;&amp; stk.get(0) == &#x27;0&#x27;) &#123; stk.remove(0); &#125; if (stk.empty()) &#123; return &quot;0&quot;; &#125; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; stk.size(); i++) &#123; sb.append(stk.get(i)); &#125; return sb.toString(); &#125;&#125; 456. 132模式给定一个整数序列：a1, a2, …, an，一个132模式的子序列 ai, aj, ak 被定义为：当 i &lt; j &lt; k 时，ai &lt; ak &lt; aj。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。 注意：n 的值小于15000。 示例1: 输入: [1, 2, 3, 4] 输出: False 解释: 序列中不存在132模式的子序列。 示例 2: 输入: [3, 1, 4, 2] 输出: True 解释: 序列中有 1 个132模式的子序列： [1, 4, 2]. 示例 3: 输入: [-1, 3, 2, 0] 输出: True 解释: 序列中有 3 个132模式的的子序列: [-1, 3, 2], [-1, 3, 0] 和 [-1, 2, 0]. PythonJava12345678910111213141516class Solution(object): def find132pattern(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; stk = [] INT_MIN = -(1 &lt;&lt; 31) third = INT_MIN for idx in xrange(len(nums) - 1, -1, -1): if nums[idx] &lt; third: return True while stk and stk[-1] &lt; nums[idx]: third = stk.pop(-1) stk.append(nums[idx]) return False1234567891011121314151617class Solution &#123; public boolean find132pattern(int[] nums) &#123; int INT_MIN = -(1 &lt;&lt; 31); int third = INT_MIN; Stack&lt;Integer&gt; stk = new Stack&lt;&gt;(); for (int i = nums.length - 1; i &gt;= 0; i--) &#123; if (nums[i] &lt; third) &#123; return true; &#125; while (!stk.empty() &amp;&amp; stk.peek() &lt; nums[i]) &#123; third = stk.pop(); &#125; stk.add(nums[i]); &#125; return false; &#125;&#125; 496. 下一个更大元素 I给定两个没有重复元素的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。 nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。 示例 1: 输入: nums1 = [4,1,2], nums2 = [1,3,4,2]. 输出: [-1,3,-1] 解释: 对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。 对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。 对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。 示例 2: 输入: nums1 = [2,4], nums2 = [1,2,3,4]. 输出: [3,-1] 解释: 对于num1中的数字2，第二个数组中的下一个较大数字是3。 对于num1中的数字4，第二个数组中没有下一个更大的数字，因此输出 -1。 注意: nums1和nums2中所有元素是唯一的。 nums1和nums2 的数组大小都不超过1000。 123456789101112131415161718192021class Solution(object): def nextGreaterElement(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: List[int] &quot;&quot;&quot; m = &#123;&#125; stk = [] res = [-1 for _ in xrange(len(nums1))] for n in nums2: while len(stk) &gt; 0 and stk[-1] &lt; n: m[stk[-1]] = n stk.pop(-1) stk.append(n) for idx, n in enumerate(nums1): if n in m: res[idx] = m[n] else: res[idx] = -1 return res 503. 下一个更大元素 II [n]给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。 示例 1: 输入: [1,2,1] 输出: [2,-1,2] 解释: 第一个 1 的下一个更大的数是 2； 数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。 注意: 输入数组的长度不会超过 10000。 123456789101112131415161718class Solution(object): def nextGreaterElements(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[int] &quot;&quot;&quot; n = len(nums) res = [-1 for _ in xrange(n)] stk = [] for idx in xrange(n * 2 - 1, -1, -1): while stk and stk[-1] &lt;= nums[idx % n]: stk.pop(-1) if len(stk) == 0: res[idx % n] = -1 else: res[idx % n] = stk[-1] stk.append(nums[idx % n]) return res 622. 设计循环队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class MyCircularQueue(object): def __init__(self, k): &quot;&quot;&quot; Initialize your data structure here. Set the size of the queue to be k. :type k: int &quot;&quot;&quot; self.queue = [None] * k self.size = k self.real_cnt = 0 self.head = 0 self.tail = 0 # 有效元素尾部的下一个位置 def enQueue(self, value): &quot;&quot;&quot; Insert an element into the circular queue. Return true if the operation is successful. :type value: int :rtype: bool &quot;&quot;&quot; if self.isFull(): return False self.queue[self.tail] = value self.tail = (self.tail + 1) % self.size self.real_cnt += 1 return True def deQueue(self): &quot;&quot;&quot; Delete an element from the circular queue. Return true if the operation is successful. :rtype: bool &quot;&quot;&quot; if self.isEmpty(): return False self.head = (self.head + 1) % self.size self.real_cnt -= 1 return True def Front(self): &quot;&quot;&quot; Get the front item from the queue. :rtype: int &quot;&quot;&quot; if self.isEmpty(): return -1 return self.queue[self.head] def Rear(self): &quot;&quot;&quot; Get the last item from the queue. :rtype: int &quot;&quot;&quot; if self.isEmpty(): return -1 if self.tail == 0: return self.queue[self.size - 1] return self.queue[self.tail - 1] def isEmpty(self): &quot;&quot;&quot; Checks whether the circular queue is empty or not. :rtype: bool &quot;&quot;&quot; return self.real_cnt == 0 def isFull(self): &quot;&quot;&quot; Checks whether the circular queue is full or not. :rtype: bool &quot;&quot;&quot; return self.real_cnt == self.size 641. 设计循环双端队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109class MyCircularDeque(object): def __init__(self, k): &quot;&quot;&quot; Initialize your data structure here. Set the size of the deque to be k. :type k: int &quot;&quot;&quot; self.deque = [None] * k self.size = k self.real_cnt = 0 self.head = 0 self.tail = 0 # 有效元素尾部的下一个位置 def insertFront(self, value): &quot;&quot;&quot; Adds an item at the front of Deque. Return true if the operation is successful. :type value: int :rtype: bool &quot;&quot;&quot; if self.isFull(): return False if self.head == 0: self.head = self.size - 1 else: self.head = self.head - 1 self.deque[self.head] = value self.real_cnt += 1 return True def insertLast(self, value): &quot;&quot;&quot; Adds an item at the rear of Deque. Return true if the operation is successful. :type value: int :rtype: bool &quot;&quot;&quot; if self.isFull(): return False self.deque[self.tail] = value self.tail = (self.tail + 1) % self.size self.real_cnt += 1 return True def deleteFront(self): &quot;&quot;&quot; Deletes an item from the front of Deque. Return true if the operation is successful. :rtype: bool &quot;&quot;&quot; if self.isEmpty(): return False self.head = (self.head + 1) % self.size self.real_cnt -= 1 return True def deleteLast(self): &quot;&quot;&quot; Deletes an item from the rear of Deque. Return true if the operation is successful. :rtype: bool &quot;&quot;&quot; if self.isEmpty(): return False if self.tail == 0: self.tail = self.size - 1 else: self.tail = self.tail - 1 self.real_cnt -= 1 return True def getFront(self): &quot;&quot;&quot; Get the front item from the deque. :rtype: int &quot;&quot;&quot; if self.isEmpty(): return -1 return self.deque[self.head] def getRear(self): &quot;&quot;&quot; Get the last item from the deque. :rtype: int &quot;&quot;&quot; if self.isEmpty(): return -1 if self.tail == 0: return self.deque[self.size - 1] else: return self.deque[self.tail - 1] def isEmpty(self): &quot;&quot;&quot; Checks whether the circular deque is empty or not. :rtype: bool &quot;&quot;&quot; return self.real_cnt == 0 def isFull(self): &quot;&quot;&quot; Checks whether the circular deque is full or not. :rtype: bool &quot;&quot;&quot; return self.real_cnt == self.size 739. 每日温度 [n]根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 1234567891011121314class Solution(object): def dailyTemperatures(self, T): &quot;&quot;&quot; :type T: List[int] :rtype: List[int] &quot;&quot;&quot; res = [0 for _ in xrange(len(T))] stk = [] for i in xrange(len(T) - 1, -1, -1): while stk and T[stk[-1]] &lt;= T[i]: stk.pop(-1) res[i] = 0 if not stk else stk[-1] - i stk.append(i) return res 856. 括号的分数给定一个平衡括号字符串 S，按下述规则计算该字符串的分数： () 得 1 分。AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。(A) 得 2 * A 分，其中 A 是平衡括号字符串。 示例 1： 输入： \"()\" 输出： 1 示例 2： 输入： \"(())\" 输出： 2 示例 3： 输入： \"()()\" 输出： 2 示例 4： 输入： \"(()(()))\" 输出： 6 提示： S 是平衡括号字符串，且只含有 ( 和 ) 。 2 &lt;= S.length &lt;= 50 123456789101112131415161718192021class Solution(object): def scoreOfParentheses(self, S): &quot;&quot;&quot; :type S: str :rtype: int &quot;&quot;&quot; stk = [] for c in S: if c == &#x27;(&#x27;: stk.append(-1) else: cnt = 0 while stk[-1] != -1: cnt += stk[-1] stk.pop(-1) stk.pop(-1) if cnt == 0: stk.append(1) else: stk.append(2 * cnt) return sum(stk) 880. 索引处的解码字符串 [n]给定一个编码字符串 S。为了找出解码字符串并将其写入磁带，从编码字符串中每次读取一个字符，并采取以下步骤： 如果所读的字符是字母，则将该字母写在磁带上。如果所读的字符是数字（例如 d），则整个当前磁带总共会被重复写 d-1 次。现在，对于给定的编码字符串 S 和索引 K，查找并返回解码字符串中的第 K 个字母。 示例 1： 输入：S = \"leet2code3\", K = 10 输出：\"o\" 解释： 解码后的字符串为 \"leetleetcodeleetleetcodeleetleetcode\"。 字符串中的第 10 个字母是 \"o\"。 示例 2： 输入：S = \"ha22\", K = 5 输出：\"h\" 解释： 解码后的字符串为 \"hahahaha\"。第 5 个字母是 \"h\"。 示例 3： 输入：S = \"a2345678999999999999999\", K = 1 输出：\"a\" 解释： 解码后的字符串为 \"a\" 重复 8301530446056247680 次。第 1 个字母是 \"a\"。 提示： 2 &lt;= S.length &lt;= 100 S 只包含小写字母与数字 2 到 9 。 S 以字母开头。 1 &lt;= K &lt;= 10^9 解码后的字符串保证少于 2^63 个字母。 12345678910111213141516171819202122class Solution(object): def decodeAtIndex(self, S, K): &quot;&quot;&quot; :type S: str :type K: int :rtype: str &quot;&quot;&quot; sz = 0 for c in S: if c.isdigit(): sz *= int(c) else: sz += 1 for c in S[::-1]: K %= sz if K == 0 and c.isalpha(): return c if c.isdigit(): sz /= int(c) else: sz -= 1 907. 子数组的最小值之和 [n]给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。 由于答案可能很大，因此返回答案模 10^9 + 7。 示例： 输入：[3,1,2,4] 输出：17 解释： 子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。 提示： 1 &lt;= A &lt;= 30000 1 &lt;= A[i] &lt;= 30000 12345678910111213141516171819202122232425262728class Solution(object): def sumSubarrayMins(self, A): MOD = 10**9 + 7 N = len(A) # prev has i* - 1 in increasing order of A[i* - 1] # where i* is the answer to query j stack = [] prev = [None] * N for i in xrange(N): while stack and A[i] &lt;= A[stack[-1]]: stack.pop() prev[i] = stack[-1] if stack else -1 stack.append(i) # next has k* + 1 in increasing order of A[k* + 1] # where k* is the answer to query j stack = [] next_ = [None] * N for k in xrange(N-1, -1, -1): while stack and A[k] &lt; A[stack[-1]]: stack.pop() next_[k] = stack[-1] if stack else N stack.append(k) # Use prev/next array to count answer return sum((i - prev[i]) * (next_[i] - i) * A[i] for i in xrange(N)) % MOD 946. 验证栈序列给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。 示例 1： 输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1] 输出：true 解释：我们可以按以下顺序执行： push(1), push(2), push(3), push(4), pop() -> 4, push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1 示例 2： 输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2] 输出：false 解释：1 不能在 2 之前弹出。 提示： 0 &lt;= pushed.length == popped.length &lt;= 1000 0 &lt;= pushed[i], popped[i] &lt; 1000 pushed 是 popped 的排列。 1234567891011121314151617181920class Solution(object): def validateStackSequences(self, pushed, popped): &quot;&quot;&quot; :type pushed: List[int] :type popped: List[int] :rtype: bool &quot;&quot;&quot; stk = [] i, j = 0, 0 n = len(pushed) m = len(popped) if m != n : return False while i &lt; n: stk.append(pushed[i]) while stk and stk[-1] == popped[j]: j += 1 stk.pop(-1) i += 1 return len(stk) == 0 and j == n 1019. 链表中的下一个更大节点 [n]给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, … 。 每个节点都可能有下一个更大值（next larger value）：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j &gt; i 且 node_j.val &gt; node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。 返回整数答案数组 answer，其中 answer[i] = next_larger(node_{i+1}) 。 注意：在下面的示例中，诸如 [2,1,5] 这样的输入（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。 示例 1： 输入：[2,1,5] 输出：[5,5,0] 示例 2： 输入：[2,7,4,3,5] 输出：[7,0,5,5,0] 示例 3： 输入：[1,7,5,1,9,2,5,1] 输出：[7,9,9,9,0,5,0,0] 提示： 对于链表中的每个节点，1 &lt;= node.val &lt;= 10^9 给定列表的长度在 [0, 10000] 范围内 1234567891011121314151617class Solution(object): def nextLargerNodes(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: List[int] &quot;&quot;&quot; nums = [] while head: nums.append(head.val) head = head.next res = [0] * len(nums) stk = [] for i, v in enumerate(nums): while stk and nums[stk[-1]] &lt; v: res[stk.pop()] = v stk.append(i) return res 1209. 删除字符串中的所有相邻重复项 II给你一个字符串 s，「k 倍重复项删除操作」将会从 s 中选择 k 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。 你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。 在执行完所有删除操作后，返回最终得到的字符串。 本题答案保证唯一。 示例 1： 输入：s = \"abcd\", k = 2 输出：\"abcd\" 解释：没有要删除的内容。 示例 2： 输入：s = \"deeedbbcccbdaa\", k = 3 输出：\"aa\" 解释： 先删除 \"eee\" 和 \"ccc\"，得到 \"ddbbbdaa\" 再删除 \"bbb\"，得到 \"dddaa\" 最后删除 \"ddd\"，得到 \"aa\" 示例 3： 输入：s = \"pbbcggttciiippooaais\", k = 2 输出：\"ps\" 提示： 1 &lt;= s.length &lt;= 10^5 2 &lt;= k &lt;= 10^4 s 中只含有小写英文字母。 12345678910111213141516171819class Solution(object): def removeDuplicates(self, s, k): &quot;&quot;&quot; :type s: str :type k: int :rtype: str &quot;&quot;&quot; stk = [] for c in s: if stk and stk[-1][0] == c: stk[-1][1] += 1 if stk[-1][1] == k: stk.pop(-1) else: stk.append([c, 1]) res = &#x27;&#x27; for v, i in stk: res += i * v return res 1249. 移除无效的括号 [n]给你一个由 ‘(‘、’)’ 和小写字母组成的字符串 s。 你需要从字符串中删除最少数目的 ‘(‘ 或者 ‘)’ （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。 请返回任意一个合法字符串。 有效「括号字符串」应当符合以下 任意一条 要求： 空字符串或只包含小写字母的字符串 可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」 可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」 示例 1： 输入：s = \"lee(t(c)o)de)\" 输出：\"lee(t(c)o)de\" 解释：\"lee(t(co)de)\" , \"lee(t(c)ode)\" 也是一个可行答案。 示例 2： 输入：s = \"a)b(c)d\" 输出：\"ab(c)d\" 示例 3： 输入：s = \"))((\" 输出：\"\" 解释：空字符串也是有效的 示例 4： 输入：s = \"(a(b(c)d)\" 输出：\"a(b(c)d)\" 提示： 1 &lt;= s.length &lt;= 10^5 s[i] 可能是 ‘(‘、’)’ 或英文小写字母 12345678910111213141516171819202122class Solution(object): def minRemoveToMakeValid(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; stk = [] for i, v in enumerate(s): if v == &#x27;(&#x27;: stk.append((i, v)) elif v == &#x27;)&#x27;: if stk and stk[-1][1] == &#x27;(&#x27;: stk.pop(-1) else: stk.append((i, v)) res, j = &quot;&quot;, 0 for i, v in enumerate(s): if j &lt; len(stk) and i == stk[j][0]: j += 1 else: res += v return res","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode之哈希表","slug":"LeetCode-哈希表","date":"2020-11-27T14:05:54.000Z","updated":"2020-12-26T07:21:49.429Z","comments":false,"path":"posts/2d8b42bd.html","link":"","permalink":"https://leel0330.github.io/posts/2d8b42bd.html","excerpt":"哈希表的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"哈希表的题目汇总在此了，欢迎大家光顾。 来源：力扣（LeetCode） 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 202. 快乐数编写一个算法来判断一个数是不是“快乐数”。 一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 示例: 输入: 19 输出: true 解释: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 1234567891011121314class Solution(object): def isHappy(self, n): &quot;&quot;&quot; :type n: int :rtype: bool &quot;&quot;&quot; m = &#123;&#125; while True: n = str(sum([int(i) ** 2 for i in str(n)])) if n == &#x27;1&#x27;: return True if n in m: return False m[n] = True 290. 单词规律给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。 这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。 示例1: 输入: pattern = \"abba\", str = \"dog cat cat dog\" 输出: true 示例 2: 输入:pattern = \"abba\", str = \"dog cat cat fish\" 输出: false 示例 3: 输入: pattern = \"aaaa\", str = \"dog cat cat dog\" 输出: false 123456789101112131415161718class Solution(object): def wordPattern(self, pattern, str): &quot;&quot;&quot; :type pattern: str :type str: str :rtype: bool &quot;&quot;&quot; return self.helper(pattern) == self.helper(str.split(&#x27; &#x27;)) def helper(self, s_list): m = &#123;&#125; res = [] for s in s_list: if s not in m: m[s] = len(m) + 1 res.append(m[s]) ss = &#x27;&#x27;.join([str(i) for i in res]) return ss 409. 最长回文串给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。 在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。 注意:假设字符串的长度不会超过 1010。 示例 1: 输入: \"abccccdd\" 输出: 7 解释: 我们可以构造的最长的回文串是\"dccaccd\", 它的长度是 7。 1234567891011121314151617181920212223class Solution(object): def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; m = &#123;&#125; for c in s: if c in m: m[c] += 1 else: m[c] = 1 max_odd = 0 res = 0 has_odd = False for k, v in m.iteritems(): if v % 2 == 0: res += v else: res += v - 1 if not has_odd: has_odd = True return res + 1 if has_odd else res 438. 找到字符串中所有字母异位词给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。 字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。 说明： 字母异位词指字母相同，但排列不同的字符串。 不考虑答案输出的顺序。 示例 1: 输入: s: \"cbaebabacd\" p: \"abc\" 输出: [0, 6] 解释: 起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的字母异位词。 起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的字母异位词。 示例 2: 输入: s: \"abab\" p: \"ab\" 输出: [0, 1, 2] 解释: 起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的字母异位词。 起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的字母异位词。 起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的字母异位词。 PythonJava123456789101112131415161718192021222324252627282930313233class Solution(object): def findAnagrams(self, s, p): &quot;&quot;&quot; :type s: str :type p: str :rtype: List[int] &quot;&quot;&quot; ls, lp = len(s), len(p) cp = self.get_counter(p) cs = &#123;&#125; ans = [] for i in range(ls): if s[i] in cs: cs[s[i]] += 1 else: cs[s[i]] = 1 if i &gt;= lp: cs[s[i - lp]] -= 1 # start前一个元素 if cs[s[i - lp]] == 0: del cs[s[i - lp]] if cs == cp: # 因为end - start + 1 = len; 所以 start = end + 1 - len ans.append(i - lp + 1) return ans def get_counter(self, s): m = &#123;&#125; for c in s: if c in m: m[c] += 1 else: m[c] = 1 return m12345678910111213141516171819202122232425262728293031323334class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(s.isEmpty() || p.length() &gt; s.length()) &#123; return res; &#125; int[] hashS = new int[256]; int[] hashP = new int[256]; for (int i = 0; i &lt; p.length(); i++) &#123; hashP[p.charAt(i)]++; hashS[s.charAt(i)]++; &#125; if (isSameDict(hashS, hashP)) &#123; res.add(0); &#125; for (int i = p.length(); i &lt; s.length(); i++) &#123; hashS[s.charAt(i - p.length())]--; hashS[s.charAt(i)]++; if (isSameDict(hashS, hashP)) &#123; res.add(i + 1 - p.length()); &#125; &#125; return res; &#125; private boolean isSameDict(int[] hashS, int[] hashP) &#123; for (int i = 0; i &lt; hashS.length; i++) &#123; if (hashP[i] != hashS[i]) &#123; return false; &#125; &#125; return true; &#125;&#125; 454. 四数相加 II[n]给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。 为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。 例如: 输入: A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2] 输出: 2 解释: 两个元组如下: 1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 PythonJava123456789101112131415161718192021222324class Solution(object): def fourSumCount(self, A, B, C, D): &quot;&quot;&quot; :type A: List[int] :type B: List[int] :type C: List[int] :type D: List[int] :rtype: int &quot;&quot;&quot; m = &#123;&#125; for i in xrange(len(A)): for j in xrange(len(B)): tmp = A[i] + B[j] if tmp in m: m[tmp] += 1 else: m[tmp] = 1 res = 0 for i in xrange(len(C)): for j in xrange(len(D)): tmp = 0 - (C[i] + D[j]) if tmp in m: res += m[tmp] return res123456789101112131415161718192021class Solution &#123; public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123; int res = 0; Map&lt;Integer, Integer&gt; counter = new HashMap&lt;&gt;(); for (int i = 0; i &lt; A.length; i++) &#123; for (int j = 0; j &lt; B.length; j++) &#123; int tmp = A[i] + B[j]; counter.put(tmp, counter.getOrDefault(tmp, 0) + 1); &#125; &#125; for (int i = 0; i &lt; C.length; i++) &#123; for (int j = 0; j &lt; D.length; j++) &#123; int tmp = C[i] + D[j]; if (counter.containsKey(-tmp)) &#123; res += counter.get(-tmp); &#125; &#125; &#125; return res; &#125;&#125; 525. 连续数组给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。 示例 1: 输入: [0,1] 输出: 2 说明: [0, 1] 是具有相同数量0和1的最长连续子数组。 示例 2: 输入: [0,1,0] 输出: 2 说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。 注意: 给定的二进制数组的长度不会超过50000。 123456789101112131415class Solution(object): def findMaxLength(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; m = &#123;0:-1&#125; res, cnt = 0, 0 for i, n in enumerate(nums): cnt = cnt + 1 if n == 1 else cnt - 1 if cnt in m: res = max(res, i - m[cnt]) else: m[cnt] = i return res 560. 和为K的子数组 [n]给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1 : 输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明 : 数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。 1234567891011121314151617class Solution(object): def subarraySum(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; res, cur_sum, pre_sum_map = 0, 0, &#123;0:1&#125; for n in nums: cur_sum += n if cur_sum - k in pre_sum_map: res += pre_sum_map[cur_sum - k] if cur_sum in pre_sum_map: pre_sum_map[cur_sum] += 1 else: pre_sum_map[cur_sum] = 1 return res 594. 最长和谐子序列 [n]和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。 现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。 示例 1: 输入: [1,3,2,2,5,2,3,7] 输出: 5 原因: 最长的和谐数组是：[3,2,2,2,3]. 说明: 输入的数组长度最大不超过20,000. 1234567891011121314151617181920class Solution(object): def findLHS(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; m = &#123;&#125; for n in nums: if n in m: m[n] += 1 else: m[n] = 1 res = 0 for n in set(nums): a, b = n - 1, n + 1 if a in m: res = max(res, m[a] + m[n]) if b in m: res = max(res, m[b] + m[n]) return res 648. 单词替换 [n]在英语中，我们有一个叫做 词根(root)的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。 现在，给定一个由许多词根组成的词典和一个句子。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。 你需要输出替换之后的句子。 示例 1: 输入: dict(词典) = [\"cat\", \"bat\", \"rat\"] sentence(句子) = \"the cattle was rattled by the battery\" 输出: \"the cat was rat by the bat\" 注: 输入只包含小写字母。 1 &lt;= 字典单词数 &lt;=1000 1 &lt;= 句中词语数 &lt;= 1000 1 &lt;= 词根长度 &lt;= 100 1 &lt;= 句中词语长度 &lt;= 1000 12345678910111213141516171819class Solution(object): def replaceWords(self, words, sentence): &quot;&quot;&quot; :type words: List[str] :type sentence: str :rtype: str &quot;&quot;&quot; res = [] wordset = set(words) for word in sentence.split(&#x27; &#x27;): res.append(self.replaceWord(word, wordset)) return &#x27; &#x27;.join(res) def replaceWord(self, word, wordset): for i in xrange(len(word)): if word[:i] in wordset: return word[:i] return word 720. 词典中最长的单词 [n]给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。 若无答案，则返回空字符串。 示例 1: 输入: words = [\"w\",\"wo\",\"wor\",\"worl\", \"world\"] 输出: \"world\" 解释: 单词\"world\"可由\"w\", \"wo\", \"wor\", 和 \"worl\"添加一个字母组成。 示例 2: 输入: words = [\"a\", \"banana\", \"app\", \"appl\", \"ap\", \"apply\", \"apple\"] 输出: \"apple\" 解释: \"apply\"和\"apple\"都能由词典中的单词组成。但是\"apple\"得字典序小于\"apply\"。 注意: 所有输入的字符串都只包含小写字母。 words数组长度范围为[1,1000]。 words[i]的长度范围为[1,30]。 123456789101112131415class Solution(object): def longestWord(self, words): &quot;&quot;&quot; :type words: List[str] :rtype: str &quot;&quot;&quot; words = sorted(words) word_set = set([&#x27;&#x27;])# 巧妙之处 res = &#x27;&#x27; for word in words: if word[:-1] in word_set: word_set.add(word) if len(word) &gt; len(res): res = word return res","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"}],"tags":[]}],"categories":[{"name":"Tech","slug":"Tech","permalink":"https://leel0330.github.io/categories/Tech/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://leel0330.github.io/categories/LeetCode/"},{"name":"Book","slug":"Book","permalink":"https://leel0330.github.io/categories/Book/"}],"tags":[]}