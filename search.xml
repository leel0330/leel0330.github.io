<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker构建包含zsh和vim的Ubuntu</title>
    <url>/posts/2954551561.html</url>
    <content><![CDATA[<p>晚上花了点时间研究了下如何在Docker环境下构建属于自己的Ubuntu。该Ubuntu包含了zsh和Oh-my-zsh插件，也包含了YouCompleteMe插件的Vim编辑器。</p>
<p>含泪说下:<strong>网上的YouCompleteMe很多教程都已经过时了，还是得以官方文档为主来配置该插件，否则你会安装的很痛苦</strong>。</p>
<p>另外，该Ubuntu也包含了C/C++的编译环境，如gcc、g++、gdb和valgrind常用工具。</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="/images/tech/docker_zsh_vim/banner.png" style="width:600px;height:300px;"/></div></div>

<a id="more"></a>

<h2 id="预安装"><a href="#预安装" class="headerlink" title="预安装"></a>预安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line"></span><br><span class="line">apt install systemd</span><br><span class="line"></span><br><span class="line">apt install curl</span><br><span class="line"></span><br><span class="line">apt install wget</span><br><span class="line"></span><br><span class="line">apt install git</span><br></pre></td></tr></table></figure>
<h2 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install zsh</span><br><span class="line"></span><br><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br><span class="line"></span><br><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br><span class="line"></span><br><span class="line">git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>

<p>在.zshrc配置插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">plugins=(git zsh-syntax-highlighting zsh-autosuggestions)</span><br></pre></td></tr></table></figure>
<p>避免复制命令在控制台是一个个字符显示出来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> This speeds up pasting w/ autosuggest</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> https://github.com/zsh-users/zsh-autosuggestions/issues/238</span></span><br><span class="line">pasteinit() &#123;</span><br><span class="line">   OLD_SELF_INSERT=$&#123;$&#123;(s.:.)widgets[self-insert]&#125;[2,3]&#125;</span><br><span class="line">   zle -N self-insert url-quote-magic # I wonder if you&#x27;d need `.url-quote-magic`?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pastefinish() &#123;</span><br><span class="line">   zle -N self-insert $OLD_SELF_INSERT</span><br><span class="line">&#125;</span><br><span class="line">zstyle :bracketed-paste-magic paste-init pasteinit</span><br><span class="line">zstyle :bracketed-paste-magic paste-finish pastefinish</span><br></pre></td></tr></table></figure>

<p>(不一定会碰到这个问题)按tab键shell中重复显示命令的前几个字符问题修复:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install -y locales</span><br><span class="line">rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line">localedef -i en_US -c -f UTF-8 -A /usr/share/locale/locale.alias en_US.UTF-8</span><br><span class="line"></span><br><span class="line">echo &#x27;export LANG=en_US.utf8&#x27; &gt;&gt; ~/.zshrc</span><br><span class="line"></span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>

<p>以上都放置在.zshrc文件就可以，然后重启下就可以了。</p>
<h2 id="安装vim并配置"><a href="#安装vim并配置" class="headerlink" title="安装vim并配置"></a>安装vim并配置</h2><ol>
<li>按照插件管理器Vundle。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim</span><br></pre></td></tr></table></figure></li>
<li>建立默认.vimrc文件在~目录下，内容为:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set nocompatible              &quot; be iMproved, required</span><br><span class="line">filetype off                  &quot; required</span><br><span class="line"></span><br><span class="line">&quot; set the runtime path to include Vundle and initialize</span><br><span class="line">set rtp+=~/.vim/bundle/Vundle.vim</span><br><span class="line">call vundle#begin()</span><br><span class="line">&quot; alternatively, pass a path where Vundle should install plugins</span><br><span class="line">&quot;call vundle#begin(&#x27;~/some/path/here&#x27;)</span><br><span class="line"></span><br><span class="line">&quot; let Vundle manage Vundle, required</span><br><span class="line">Plugin &#x27;VundleVim/Vundle.vim&#x27;</span><br><span class="line"></span><br><span class="line">&quot; plugins here</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot; All of your Plugins must be added before the following line</span><br><span class="line">call vundle#end()            &quot; required</span><br><span class="line">filetype plugin indent on    &quot; required</span><br><span class="line">&quot; To ignore plugin indent changes, instead use:</span><br><span class="line">&quot;filetype plugin on</span><br><span class="line">&quot;</span><br><span class="line">&quot; Brief help</span><br><span class="line">&quot; :PluginList       - lists configured plugins</span><br><span class="line">&quot; :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate</span><br><span class="line">&quot; :PluginSearch foo - searches for foo; append `!` to refresh local cache</span><br><span class="line">&quot; :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal</span><br><span class="line">&quot;</span><br><span class="line">&quot; see :h vundle for more details or wiki for FAQ</span><br><span class="line">&quot; Put your non-Plugin stuff after this line</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="安装YouCompleteMe插件"><a href="#安装YouCompleteMe插件" class="headerlink" title="安装YouCompleteMe插件"></a>安装YouCompleteMe插件</h3><ol>
<li>在.vimrc添加如下内容:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Plugin &#39;Valloric&#x2F;YouCompleteMe&#39;</span><br></pre></td></tr></table></figure></li>
<li>拉取YouCompleteMe插件代码:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/.vim/bundle</span><br><span class="line">git clone https://github.com/Valloric/YouCompleteMe.git</span><br><span class="line"></span><br><span class="line">cd ~/.vim/bundle/YouCompleteMe</span><br><span class="line">git submodule update --init --recursive(注意:这个命令可能花时间比较久)</span><br></pre></td></tr></table></figure></li>
<li>拉取构建YouCompleteMe依赖:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install build-essential cmake vim-nox python3-dev</span><br></pre></td></tr></table></figure></li>
<li>安装代码提示:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/.vim/bundle/YouCompleteMe</span><br><span class="line"></span><br><span class="line">python3 install.py --clangd-completer</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>这4步完成后YouCompleteMe插件就算完成了，网上好多说要配置.ycm_extra_conf.py。其实这个文件已经在这个~/.vim/bundle/YouCompleteMe目录下了，你可以通过ls -a来看到那个文件。</p>
<h2 id="安装C-C-环境"><a href="#安装C-C-环境" class="headerlink" title="安装C/C++环境"></a>安装C/C++环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install gcc</span><br><span class="line"></span><br><span class="line">apt install g++</span><br><span class="line"></span><br><span class="line">apt install valgrind</span><br><span class="line"></span><br><span class="line">apt install gdb</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode之二叉树(简单)</title>
    <url>/posts/94def828.html</url>
    <content><![CDATA[<p>二叉树(简单)的题目汇总在此了，欢迎大家光顾。</p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="/images/leetcode/bst.jpg" style="width:600px;height:300px;"/></div></div>

<a id="more"></a>

<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre>
    1
   / \
  2   2
 / \ / \
3  4 4  3
</pre>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<pre>
    1
   / \
  2   2
   \   \
   3    3
</pre>


<div class="tabs" id="leetcode-101"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-101-1">Python(BFS)</a></li><li class="tab"><a class="#leetcode-101-2">Python(递归)</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-101-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        queue = [root, root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            t1 = queue.pop(<span class="number">0</span>)</span><br><span class="line">            t2 = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> t1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> t2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> t1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> t2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> t1.val != t2.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            queue.append(t1.left)</span><br><span class="line">            queue.append(t2.right)</span><br><span class="line">            queue.append(t1.right)</span><br><span class="line">            queue.append(t2.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-101-2"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.isMirror(root, root)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMirror</span>(<span class="params">self, p, q</span>):</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> q <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> q <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> self.isMirror(p.left, q.right) \</span><br><span class="line">         <span class="keyword">and</span> self.isMirror(p.right, q.left)</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a>110. 平衡二叉树</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
<p>示例 1:</p>
<pre>
给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7
返回 true 。
</pre>
<p>示例 2:</p>
<pre>
给定二叉树 [1,2,2,3,3,null,null,4,4]

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
返回 false 。
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(root) != -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_height = self.helper(root.left)</span><br><span class="line">        <span class="keyword">if</span> left_height == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        right_height = self.helper(root.right)</span><br><span class="line">        <span class="keyword">if</span> right_height == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(left_height - right_height) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(left_height, right_height)</span><br></pre></td></tr></table></figure>

<h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a>111. 二叉树的最小深度</h2><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:</p>
<pre>
给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回它的最小深度  2.
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">            level += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> level</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br></pre></td></tr></table></figure>

<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h2><p>翻转一棵二叉树。</p>
<p>示例：</p>
<pre>
输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9
输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            node.left, node.right = node.right, node.left</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h2><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:</p>
<p>输入:</p>
<pre>
   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        item, res = [], []</span><br><span class="line">        self.dfs(root, item, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, root, item, res</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            tmp = item[:] + [<span class="built_in">str</span>(root.val)]</span><br><span class="line">            res.append(<span class="string">&#x27;-&gt;&#x27;</span>.join(tmp))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dfs(root.left, item + [<span class="built_in">str</span>(root.val)], res)</span><br><span class="line">        self.dfs(root.right, item + [<span class="built_in">str</span>(root.val)], res)</span><br></pre></td></tr></table></figure>

<h2 id="501-二叉搜索树中的众数-n"><a href="#501-二叉搜索树中的众数-n" class="headerlink" title="501. 二叉搜索树中的众数 [n]"></a>501. 二叉搜索树中的众数 [n]</h2><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>
<p>假定 BST 有如下定义：</p>
<ul>
<li>结点左子树中所含结点的值小于等于当前结点的值</li>
<li>结点右子树中所含结点的值大于等于当前结点的值</li>
<li>左子树和右子树都是二叉搜索树</li>
</ul>
<pre>
例如：
给定 BST [1,null,2,2],

   1
    \
     2
    /
   2

返回[2].
</pre>

<p>提示：如果众数超过1个，不需考虑输出顺序</p>
<p>进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMode</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        self.max_count = <span class="number">0</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.helper(root.left)</span><br><span class="line">        <span class="keyword">if</span> self.prev <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> self.prev.val == root.val:</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.count = <span class="number">1</span></span><br><span class="line">        self.prev = root</span><br><span class="line">        <span class="keyword">if</span> self.count == self.max_count:</span><br><span class="line">            self.res.append(self.prev.val)</span><br><span class="line">        <span class="keyword">if</span> self.count &gt; self.max_count:</span><br><span class="line">            self.max_count = self.count</span><br><span class="line">            self.res = [self.prev.val]</span><br><span class="line">        self.helper(root.right)</span><br></pre></td></tr></table></figure>

<h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a>543. 二叉树的直径</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。</p>
<p>示例 :</p>
<pre>
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
</pre>
<p>注意：两结点之间的路径长度是以它们之间边的数目表示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.ans = <span class="number">1</span></span><br><span class="line">        self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.helper(root.left)</span><br><span class="line">        right = self.helper(root.right)</span><br><span class="line">        self.ans = <span class="built_in">max</span>(self.ans, left + right + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="563-二叉树的坡度"><a href="#563-二叉树的坡度" class="headerlink" title="563. 二叉树的坡度"></a>563. 二叉树的坡度</h2><p>给定一个二叉树，计算整个树的坡度。</p>
<p>一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。</p>
<p>整个树的坡度就是其所有节点的坡度之和。</p>
<p>示例:</p>
<pre>
输入: 
         1
       /   \
      2     3
输出: 1
解释: 
结点的坡度 2 : 0
结点的坡度 3 : 0
结点的坡度 1 : |2-3| = 1
树的坡度 : 0 + 0 + 1 = 1
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTilt</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        L = self.helper(root.left)</span><br><span class="line">        R = self.helper(root.right)</span><br><span class="line">        self.res += <span class="built_in">abs</span>(L - R)</span><br><span class="line">        <span class="keyword">return</span> L + R + root.val</span><br></pre></td></tr></table></figure>

<h2 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572. 另一个树的子树"></a>572. 另一个树的子树</h2><p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p>
<p>示例 1:</p>
<pre>
给定的树 s:

     3
    / \
   4   5
  / \
 1   2
给定的树 t：

   4 
  / \
 1   2
返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。
</pre>
<p>示例 2:</p>
<pre>
给定的树 s：

     3
    / \
   4   5
  / \
 1   2
    /
   0
给定的树 t：

   4
  / \
 1   2
返回 false。
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubtree</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: TreeNode</span></span><br><span class="line"><span class="string">        :type t: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        queue = [s]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> self.isSameTree(node, t):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> t <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> t <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> s.val != t.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isSameTree(s.left, t.left) \</span><br><span class="line">            <span class="keyword">and</span> self.isSameTree(s.right, t.right)</span><br></pre></td></tr></table></figure>

<h2 id="606-根据二叉树创建字符串-n"><a href="#606-根据二叉树创建字符串-n" class="headerlink" title="606. 根据二叉树创建字符串 [n]"></a>606. 根据二叉树创建字符串 [n]</h2><p>你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。</p>
<p>空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p>
<p>示例 1:</p>
<pre>
输入: 二叉树: [1,2,3,4]
       1
     /   \
    2     3
   /    
  4     

输出: "1(2(4))(3)"

解释: 原本将是“1(2(4)())(3())”，
在你省略所有不必要的空括号对之后，
它将是“1(2(4))(3)”。
</pre>
<p>示例 2:</p>
<pre>
输入: 二叉树: [1,2,3,null,4]
       1
     /   \
    2     3
     \  
      4 

输出: "1(2()(4))(3)"

解释: 和第一个示例相似，
除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tree2str</span>(<span class="params">self, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type t: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> t <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> t.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> t.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">str</span>(t.val)</span><br><span class="line">        left = <span class="string">&#x27;()&#x27;</span> <span class="keyword">if</span> t.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="string">&#x27;(&#x27;</span> + self.tree2str(t.left) + <span class="string">&#x27;)&#x27;</span></span><br><span class="line">        right = <span class="string">&#x27;&#x27;</span> <span class="keyword">if</span> t.right <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="string">&#x27;(&#x27;</span> + self.tree2str(t.right) + <span class="string">&#x27;)&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(t.val) + left + right</span><br></pre></td></tr></table></figure>

<h2 id="897-递增顺序查找树"><a href="#897-递增顺序查找树" class="headerlink" title="897. 递增顺序查找树"></a>897. 递增顺序查找树</h2><p>给定一个树，按中序遍历重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。</p>
<p>示例 ：</p>
<pre>
输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]

       5
      / \
    3    6
   / \    \
  2   4    8
 /        / \ 
1        7   9

输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]

 1
  \
   2
    \
     3
      \
       4
        \
         5
          \
           6
            \
             7
              \
               8
                \
                 9  
</pre>

<p>提示：</p>
<ul>
<li>给定树中的结点数介于 1 和 100 之间。</li>
<li>每个结点都有一个从 0 到 1000 范围内的唯一整数值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increasingBST</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = self.inorder(root)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(res) - <span class="number">1</span>):</span><br><span class="line">            res[i].right = res[i + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        res = []</span><br><span class="line">        p = root</span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">or</span> stk:</span><br><span class="line">            <span class="keyword">while</span> p:</span><br><span class="line">                stk.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">            node = stk.pop(-<span class="number">1</span>)</span><br><span class="line">            node.left = <span class="literal">None</span></span><br><span class="line">            res.append(node)</span><br><span class="line">            p = node.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="993-二叉树的堂兄弟节点"><a href="#993-二叉树的堂兄弟节点" class="headerlink" title="993. 二叉树的堂兄弟节点"></a>993. 二叉树的堂兄弟节点</h2><p>在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。</p>
<p>如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。</p>
<p>我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。</p>
<p>只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。</p>
<p>示例 1：</p>
<pre>
输入：root = [1,2,3,4], x = 4, y = 3
输出：false
</pre>
<p>示例 2：</p>
<pre>
输入：root = [1,2,3,null,4,null,5], x = 5, y = 4
输出：true
</pre>
<p>示例 3：</p>
<pre>
输入：root = [1,2,3,null,4], x = 2, y = 3
输出：false
</pre>

<p>提示：</p>
<ul>
<li>二叉树的节点数介于 2 到 100 之间。</li>
<li>每个节点的值都是唯一的、范围为 1 到 100 的整数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isCousins</span>(<span class="params">self, root, x, y</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :type y: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        queue = [(root, <span class="literal">None</span>)]</span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            sz = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(sz):</span><br><span class="line">                node, parent = queue.pop(<span class="number">0</span>)</span><br><span class="line">                m[node.val] = (parent, depth)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append((node.left, node))</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append((node.right, node))</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        px, dx = m[x]</span><br><span class="line">        py, dy = m[y]</span><br><span class="line">        <span class="keyword">return</span> px != py <span class="keyword">and</span> dx == dy</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode之哈希表</title>
    <url>/posts/2d8b42bd.html</url>
    <content><![CDATA[<p>哈希表的题目汇总在此了，欢迎大家光顾。</p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="/images/leetcode/hash.jpg" style="width:600px;height:300px;"/></div></div>

<a id="more"></a>

<h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><p>编写一个算法来判断一个数是不是“快乐数”。</p>
<p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p>
<p>示例: </p>
<pre>
输入: 19
输出: true
解释: 
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            n = <span class="built_in">str</span>(<span class="built_in">sum</span>([<span class="built_in">int</span>(i) ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>(n)]))</span><br><span class="line">            <span class="keyword">if</span> n == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> m:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            m[n] = <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290. 单词规律"></a>290. 单词规律</h2><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</p>
<p>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p>
<p>示例1:</p>
<pre>
输入: pattern = "abba", str = "dog cat cat dog"
输出: true
</pre>
<p>示例 2:</p>
<pre>
输入:pattern = "abba", str = "dog cat cat fish"
输出: false
</pre>
<p>示例 3:</p>
<pre>
输入: pattern = "aaaa", str = "dog cat cat dog"
输出: false
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordPattern</span>(<span class="params">self, pattern, <span class="built_in">str</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type pattern: str</span></span><br><span class="line"><span class="string">        :type str: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(pattern) == self.helper(<span class="built_in">str</span>.split(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, s_list</span>):</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> s_list:</span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> m:</span><br><span class="line">                m[s] = <span class="built_in">len</span>(m) + <span class="number">1</span></span><br><span class="line">            res.append(m[s])</span><br><span class="line">        ss = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> res])</span><br><span class="line">        <span class="keyword">return</span> ss</span><br></pre></td></tr></table></figure>

<h2 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a>409. 最长回文串</h2><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p>
<p>在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。</p>
<p>注意:<br>假设字符串的长度不会超过 1010。</p>
<p>示例 1:</p>
<pre>
输入:
"abccccdd"

输出:
7

解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> m:</span><br><span class="line">                m[c] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m[c] = <span class="number">1</span></span><br><span class="line">        max_odd = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        has_odd = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> m.iteritems():</span><br><span class="line">            <span class="keyword">if</span> v % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                res += v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += v - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> has_odd:</span><br><span class="line">                    has_odd = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">1</span> <span class="keyword">if</span> has_odd <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure>

<h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. 找到字符串中所有字母异位词</h2><p>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p>
<p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p>
<p>说明：</p>
<ul>
<li>字母异位词指字母相同，但排列不同的字符串。</li>
<li>不考虑答案输出的顺序。</li>
</ul>
<p>示例 1:</p>
<pre>
输入:
s: "cbaebabacd" p: "abc"

输出:
[0, 6]

解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词。
</pre>
<p>示例 2:</p>
<pre>
输入:
s: "abab" p: "ab"

输出:
[0, 1, 2]

解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的字母异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的字母异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的字母异位词。
</pre>

<div class="tabs" id="leetcode-438"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-438-1">Python</a></li><li class="tab"><a class="#leetcode-438-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-438-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span>(<span class="params">self, s, p</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type p: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ls, lp = <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line">        cp = self.get_counter(p)</span><br><span class="line">        cs = &#123;&#125;</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ls):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> cs:</span><br><span class="line">                cs[s[i]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cs[s[i]] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= lp:</span><br><span class="line">                cs[s[i - lp]] -= <span class="number">1</span> <span class="comment"># start前一个元素</span></span><br><span class="line">                <span class="keyword">if</span> cs[s[i - lp]] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> cs[s[i - lp]]</span><br><span class="line">            <span class="keyword">if</span> cs == cp:</span><br><span class="line">                <span class="comment"># 因为end - start + 1 = len; 所以 start = end + 1 - len</span></span><br><span class="line">                ans.append(i - lp + <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_counter</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> m:</span><br><span class="line">                m[c] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m[c] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-438-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s.isEmpty() || p.length() &gt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">int</span>[] hashS = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span>[] hashP = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">            hashP[p.charAt(i)]++;</span><br><span class="line">            hashS[s.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isSameDict(hashS, hashP)) &#123;</span><br><span class="line">            res.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p.length(); i &lt; s.length(); i++) &#123;</span><br><span class="line">            hashS[s.charAt(i - p.length())]--;</span><br><span class="line">            hashS[s.charAt(i)]++;</span><br><span class="line">            <span class="keyword">if</span> (isSameDict(hashS, hashP)) &#123;</span><br><span class="line">                res.add(i + <span class="number">1</span> - p.length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSameDict</span><span class="params">(<span class="keyword">int</span>[] hashS, <span class="keyword">int</span>[] hashP)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hashS.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashP[i] != hashS[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="454-四数相加-II-n"><a href="#454-四数相加-II-n" class="headerlink" title="454. 四数相加 II[n]"></a>454. 四数相加 II[n]</h2><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</p>
<p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。</p>
<p>例如:</p>
<pre>
输入:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

输出:
2

解释:
两个元组如下:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
</pre>


<div class="tabs" id="leetcode-454"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-454-1">Python</a></li><li class="tab"><a class="#leetcode-454-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-454-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSumCount</span>(<span class="params">self, A, B, C, D</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type B: List[int]</span></span><br><span class="line"><span class="string">        :type C: List[int]</span></span><br><span class="line"><span class="string">        :type D: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="built_in">len</span>(B)):</span><br><span class="line">                tmp = A[i] + B[j]</span><br><span class="line">                <span class="keyword">if</span> tmp <span class="keyword">in</span> m:</span><br><span class="line">                    m[tmp] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    m[tmp] = <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(C)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="built_in">len</span>(D)):</span><br><span class="line">                tmp = <span class="number">0</span> - (C[i] + D[j])</span><br><span class="line">                <span class="keyword">if</span> tmp <span class="keyword">in</span> m:</span><br><span class="line">                    res += m[tmp]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-454-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; counter = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = A[i] + B[j];</span><br><span class="line">                counter.put(tmp, counter.getOrDefault(tmp, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; D.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = C[i] + D[j];</span><br><span class="line">                <span class="keyword">if</span> (counter.containsKey(-tmp)) &#123;</span><br><span class="line">                    res += counter.get(-tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="525-连续数组"><a href="#525-连续数组" class="headerlink" title="525. 连续数组"></a>525. 连续数组</h2><p>给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。</p>
<p>示例 1:</p>
<pre>
输入: [0,1]
输出: 2
说明: [0, 1] 是具有相同数量0和1的最长连续子数组。
</pre>
<p>示例 2:</p>
<pre>
输入: [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。
</pre>
<p>注意: 给定的二进制数组的长度不会超过50000。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxLength</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;<span class="number">0</span>:-<span class="number">1</span>&#125;</span><br><span class="line">        res, cnt = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            cnt = cnt + <span class="number">1</span> <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">else</span> cnt - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt <span class="keyword">in</span> m:</span><br><span class="line">                res = <span class="built_in">max</span>(res, i - m[cnt])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m[cnt] = i</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="560-和为K的子数组-n"><a href="#560-和为K的子数组-n" class="headerlink" title="560. 和为K的子数组 [n]"></a>560. 和为K的子数组 [n]</h2><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p>
<p>示例 1 :</p>
<pre>
输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
</pre>
<p>说明 :</p>
<ul>
<li>数组的长度为 [1, 20,000]。</li>
<li>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res, cur_sum, pre_sum_map = <span class="number">0</span>, <span class="number">0</span>, &#123;<span class="number">0</span>:<span class="number">1</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            cur_sum += n</span><br><span class="line">            <span class="keyword">if</span> cur_sum - k <span class="keyword">in</span> pre_sum_map:</span><br><span class="line">                res += pre_sum_map[cur_sum - k]</span><br><span class="line">            <span class="keyword">if</span> cur_sum <span class="keyword">in</span> pre_sum_map:</span><br><span class="line">                pre_sum_map[cur_sum] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre_sum_map[cur_sum] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="594-最长和谐子序列-n"><a href="#594-最长和谐子序列-n" class="headerlink" title="594. 最长和谐子序列 [n]"></a>594. 最长和谐子序列 [n]</h2><p>和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。</p>
<p>现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。</p>
<p>示例 1:</p>
<pre>
输入: [1,3,2,2,5,2,3,7]
输出: 5
原因: 最长的和谐数组是：[3,2,2,2,3].
</pre>
<p>说明: 输入的数组长度最大不超过20,000.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLHS</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> m:</span><br><span class="line">                m[n] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m[n] = <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">set</span>(nums):</span><br><span class="line">            a, b = n - <span class="number">1</span>, n + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">in</span> m:</span><br><span class="line">                res = <span class="built_in">max</span>(res, m[a] + m[n])</span><br><span class="line">            <span class="keyword">if</span> b <span class="keyword">in</span> m:</span><br><span class="line">                res = <span class="built_in">max</span>(res, m[b] + m[n])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="648-单词替换-n"><a href="#648-单词替换-n" class="headerlink" title="648. 单词替换 [n]"></a>648. 单词替换 [n]</h2><p>在英语中，我们有一个叫做 词根(root)的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。</p>
<p>现在，给定一个由许多词根组成的词典和一个句子。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。</p>
<p>你需要输出替换之后的句子。</p>
<p>示例 1:</p>
<pre>
输入: dict(词典) = ["cat", "bat", "rat"]
sentence(句子) = "the cattle was rattled by the battery"
输出: "the cat was rat by the bat"
</pre>
<p>注:</p>
<ul>
<li>输入只包含小写字母。</li>
<li>1 &lt;= 字典单词数 &lt;=1000</li>
<li>1 &lt;=  句中词语数 &lt;= 1000</li>
<li>1 &lt;= 词根长度 &lt;= 100</li>
<li>1 &lt;= 句中词语长度 &lt;= 1000</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceWords</span>(<span class="params">self, words, sentence</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :type sentence: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        wordset = <span class="built_in">set</span>(words)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> sentence.split(<span class="string">&#x27; &#x27;</span>):</span><br><span class="line">            res.append(self.replaceWord(word, wordset))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(res)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceWord</span>(<span class="params">self, word, wordset</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(word)):</span><br><span class="line">            <span class="keyword">if</span> word[:i] <span class="keyword">in</span> wordset:</span><br><span class="line">                <span class="keyword">return</span> word[:i]</span><br><span class="line">        <span class="keyword">return</span> word</span><br></pre></td></tr></table></figure>

<h2 id="720-词典中最长的单词-n"><a href="#720-词典中最长的单词-n" class="headerlink" title="720. 词典中最长的单词 [n]"></a>720. 词典中最长的单词 [n]</h2><p>给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。</p>
<p>若无答案，则返回空字符串。</p>
<p>示例 1:</p>
<pre>
输入: 
words = ["w","wo","wor","worl", "world"]
输出: "world"
解释: 
单词"world"可由"w", "wo", "wor", 和 "worl"添加一个字母组成。
</pre>
<p>示例 2:</p>
<pre>
输入: 
words = ["a", "banana", "app", "appl", "ap", "apply", "apple"]
输出: "apple"
解释: 
"apply"和"apple"都能由词典中的单词组成。但是"apple"得字典序小于"apply"。
</pre>
<p>注意:</p>
<ul>
<li>所有输入的字符串都只包含小写字母。</li>
<li>words数组长度范围为[1,1000]。</li>
<li>words[i]的长度范围为[1,30]。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestWord</span>(<span class="params">self, words</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        words = <span class="built_in">sorted</span>(words)</span><br><span class="line">        word_set = <span class="built_in">set</span>([<span class="string">&#x27;&#x27;</span>])<span class="comment"># 巧妙之处</span></span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> word[:-<span class="number">1</span>] <span class="keyword">in</span> word_set:</span><br><span class="line">                word_set.add(word)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(word) &gt; <span class="built_in">len</span>(res):</span><br><span class="line">                    res = word</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode之字符串(简单)</title>
    <url>/posts/c026ad95.html</url>
    <content><![CDATA[<p>字符串(简单)的题目汇总在此了，欢迎大家光顾。</p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="/images/leetcode/string.png" style="width:600px;height:300px;"/></div></div>

<a id="more"></a>

<h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 “”。</p>
<p>示例 1:</p>
<pre>
输入: ["flower","flow","flight"]
输出: "fl"
</pre>
<p>示例 2:</p>
<pre>
输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
</pre>
<p>说明:</p>
<ul>
<li>所有输入只包含小写字母 a-z 。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> strs <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(strs) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(strs[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="built_in">len</span>(strs)):</span><br><span class="line">                <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(strs[j]) <span class="keyword">or</span> strs[j][i] != c:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">            res += c</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h2 id="443-压缩字符串"><a href="#443-压缩字符串" class="headerlink" title="443. 压缩字符串"></a>443. 压缩字符串</h2><p>给定一组字符，使用原地算法将其压缩。</p>
<p>压缩后的长度必须始终小于或等于原数组长度。</p>
<p>数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。</p>
<p>在完成原地修改输入数组后，返回数组的新长度。</p>
<p>进阶：</p>
<p>你能否仅使用O(1) 空间解决问题？</p>
<p>示例 1：</p>
<pre>
输入：
["a","a","b","b","c","c","c"]
输出：
返回6，输入数组的前6个字符应该是：["a","2","b","2","c","3"]
说明：
"aa"被"a2"替代。"bb"被"b2"替代。"ccc"被"c3"替代。
</pre>
<p>示例 2：</p>
<pre>
输入：
["a"]
输出：
返回1，输入数组的前1个字符应该是：["a"]
说明：
没有任何字符串被替代。
</pre>
<p>示例 3：</p>
<pre>
输入：
["a","b","b","b","b","b","b","b","b","b","b","b","b"]
输出：
返回4，输入数组的前4个字符应该是：["a","b","1","2"]。
说明：
由于字符"a"不重复，所以不会被压缩。"bbbbbbbbbbbb"被“b12”替代。
</pre>
<p>注意每个数字在数组中都有它自己的位置。</p>
<p>注意：</p>
<ul>
<li>所有字符都有一个ASCII值在[35, 126]区间内。</li>
<li>1 &lt;= len(chars) &lt;= 1000。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compress</span>(<span class="params">self, chars</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type chars: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(chars):</span><br><span class="line">            c, cnt = chars[i], <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(chars) <span class="keyword">and</span> chars[i] == c:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="number">1</span>:</span><br><span class="line">                res.append(c)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(c)</span><br><span class="line">                res.extend([c <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">str</span>(cnt)])</span><br><span class="line">        <span class="keyword">for</span> idx, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(res):</span><br><span class="line">            chars[idx] = c</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(res)</span><br></pre></td></tr></table></figure>

<h2 id="680-验证回文字符串-Ⅱ"><a href="#680-验证回文字符串-Ⅱ" class="headerlink" title="680. 验证回文字符串 Ⅱ"></a>680. 验证回文字符串 Ⅱ</h2><p>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p>
<p>示例 1:</p>
<pre>
输入: "aba"
输出: True
</pre>
<p>示例 2:</p>
<pre>
输入: "abca"
输出: True
解释: 你可以删除c字符。
</pre>
<p>注意:</p>
<ul>
<li>字符串只包含从 a-z 的小写字母。字符串的最大长度是50000</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= j:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> self.isPalindrome(s, i + <span class="number">1</span>, j) <span class="keyword">or</span> self.isPalindrome(s, i, j - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s, i, j</span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; j:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="696-计数二进制子串-n"><a href="#696-计数二进制子串-n" class="headerlink" title="696. 计数二进制子串 [n]"></a>696. 计数二进制子串 [n]</h2><p>给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。</p>
<p>重复出现的子串要计算它们出现的次数。</p>
<p>示例 1 :</p>
<pre>
输入: "00110011"
输出: 6
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。
请注意，一些重复出现的子串要计算它们出现的次数。
另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
</pre>
<p>示例 2 :</p>
<pre>
输入: "10101"
输出: 4
解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
</pre>
<p>注意：</p>
<ul>
<li>s.length 在1到50,000之间。</li>
<li>s 只包含“0”或“1”字符。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBinarySubstrings</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = pre = <span class="number">0</span></span><br><span class="line">        cur = <span class="number">1</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[i - <span class="number">1</span>]:</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pre &gt;= cur:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="788-旋转数字"><a href="#788-旋转数字" class="headerlink" title="788. 旋转数字"></a>788. 旋转数字</h2><p>我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。</p>
<p>如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。</p>
<p>现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？</p>
<p>示例:</p>
<pre>
输入: 10
输出: 4
解释: 
在[1, 10]中有四个好数： 2, 5, 6, 9。
注意 1 和 10 不是好数, 因为他们在旋转之后不变。
</pre>
<p>注意:</p>
<ul>
<li>N 的取值范围是 [1, 10000]。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotatedDigits</span>(<span class="params">self, N</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> self.isGoodNum(i):</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isGoodNum</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">any</span>(x <span class="keyword">in</span> <span class="built_in">str</span>(n) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;7&#x27;</span>]):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">any</span>(x <span class="keyword">in</span> <span class="built_in">str</span>(n) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;9&#x27;</span>]):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="859-亲密字符串"><a href="#859-亲密字符串" class="headerlink" title="859. 亲密字符串"></a>859. 亲密字符串</h2><p>给定两个由小写字母构成的字符串 A 和 B ，只要我们可以通过交换 A 中的两个字母得到与 B 相等的结果，就返回 true ；否则返回 false 。</p>
<p>示例 1：</p>
<pre>
输入： A = "ab", B = "ba"
输出： true
</pre>
<p>示例 2：</p>
<pre>
输入： A = "ab", B = "ab"
输出： false
</pre>
<p>示例 3:</p>
<pre>
输入： A = "aa", B = "aa"
输出： true
</pre>
<p>示例 4：</p>
<pre>
输入： A = "aaaaaaabc", B = "aaaaaaacb"
输出： true
</pre>
<p>示例 5：</p>
<pre>
输入： A = "", B = "aa"
输出： false
</pre>

<p>提示：</p>
<ul>
<li>0 &lt;= A.length &lt;= 20000</li>
<li>0 &lt;= B.length &lt;= 20000</li>
<li>A 和 B 仅由小写字母构成。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buddyStrings</span>(<span class="params">self, A, B</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(A) != <span class="built_in">len</span>(B): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> A == B:</span><br><span class="line">            seen = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> a <span class="keyword">in</span> A:</span><br><span class="line">                <span class="keyword">if</span> a <span class="keyword">in</span> seen:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                seen.add(a)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pairs = []</span><br><span class="line">            <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(A, B):</span><br><span class="line">                <span class="keyword">if</span> a != b:</span><br><span class="line">                    pairs.append((a, b))</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(pairs) &gt; <span class="number">2</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(pairs) == <span class="number">2</span> <span class="keyword">and</span> pairs[<span class="number">0</span>] == pairs[<span class="number">1</span>][::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="925-长按键入"><a href="#925-长按键入" class="headerlink" title="925. 长按键入"></a>925. 长按键入</h2><p>你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。</p>
<p>你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。</p>
<p>示例 1：</p>
<pre>
输入：name = "alex", typed = "aaleex"
输出：true
解释：'alex' 中的 'a' 和 'e' 被长按。
</pre>
<p>示例 2：</p>
<pre>
输入：name = "saeed", typed = "ssaaedd"
输出：false
解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。
</pre>
<p>示例 3：</p>
<pre>
输入：name = "leelee", typed = "lleeelee"
输出：true
</pre>
<p>示例 4：</p>
<pre>
输入：name = "laiden", typed = "laiden"
输出：true
解释：长按名字中的字符并不是必要的。
</pre>

<p>提示：</p>
<ul>
<li>name.length &lt;= 1000</li>
<li>typed.length &lt;= 1000</li>
<li>name 和 typed 的字符都是小写字母。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isLongPressedName</span>(<span class="params">self, name, typed</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type name: str</span></span><br><span class="line"><span class="string">        :type typed: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        a = self.getHelper(name)</span><br><span class="line">        b = self.getHelper(typed)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="built_in">len</span>(b):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="built_in">len</span>(a), <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> a[idx] != b[idx]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> a[idx + <span class="number">1</span>] &gt; b[idx + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHelper</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        res = []</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> idx &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            cur_c, cnt = s[idx], <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> idx &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[idx] == cur_c:</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            res.append(cur_c)</span><br><span class="line">            res.append(cnt)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode之数组(困难)</title>
    <url>/posts/801922082.html</url>
    <content><![CDATA[<p>数组(困难)的题目汇总在此了，欢迎大家光顾。</p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="/images/leetcode/array3.png" style="width:600px;height:300px;"/></div></div>

<a id="more"></a>

<h2 id="4-寻找两个正序数组的中位数-n"><a href="#4-寻找两个正序数组的中位数-n" class="headerlink" title="4. 寻找两个正序数组的中位数 [n]"></a>4. 寻找两个正序数组的中位数 [n]</h2><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。</p>
<p>进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？</p>
<p>示例 1：</p>
<pre>
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
</pre>
<p>示例 2：</p>
<pre>
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
</pre>
<p>示例 3：</p>
<pre>
输入：nums1 = [0,0], nums2 = [0,0]
输出：0.00000
</pre>
<p>示例 4：</p>
<pre>
输入：nums1 = [], nums2 = [1]
输出：1.00000
</pre>
<p>示例 5：</p>
<pre>
输入：nums1 = [2], nums2 = []
输出：2.00000
</pre>

<p>提示：</p>
<ul>
<li>nums1.length == m</li>
<li>nums2.length == n</li>
<li>0 &lt;= m &lt;= 1000</li>
<li>0 &lt;= n &lt;= 1000</li>
<li>1 &lt;= m + n &lt;= 2000</li>
<li>-106 &lt;= nums1[i], nums2[i] &lt;= 106</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, nums1, nums2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        len1, len2 = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        total_len = len1 + len2</span><br><span class="line">        <span class="keyword">if</span> total_len &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">            mid = total_len / <span class="number">2</span></span><br><span class="line">            res = self.findK(nums1, nums2, mid + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mid1 = total_len / <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">            mid2 = mid1 + <span class="number">1</span></span><br><span class="line">            res = (self.findK(nums1, nums2, mid1 + <span class="number">1</span>) + self.findK(nums1, nums2, mid2 + <span class="number">1</span>)) / <span class="number">2.0</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findK</span>(<span class="params">self, nums1, nums2, k</span>):</span></span><br><span class="line">        len1, len2 = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        idx1, idx2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> idx1 == len1:</span><br><span class="line">                <span class="keyword">return</span> nums2[idx2 + k - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> idx2 == len2:</span><br><span class="line">                <span class="keyword">return</span> nums1[idx1 + k - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[idx1], nums2[idx2])</span><br><span class="line">            half = k / <span class="number">2</span></span><br><span class="line">            new_idx1 = <span class="built_in">min</span>(idx1 + half, len1) - <span class="number">1</span></span><br><span class="line">            new_idx2 = <span class="built_in">min</span>(idx2 + half, len2) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums1[new_idx1] &lt;= nums2[new_idx2]:</span><br><span class="line">                k -= (new_idx1 - idx1 + <span class="number">1</span>)</span><br><span class="line">                idx1 = new_idx1 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                k -= (new_idx2 - idx2 + <span class="number">1</span>)</span><br><span class="line">                idx2 = new_idx2 + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a>41. 缺失的第一个正数</h2><p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p>
<p>示例 1:</p>
<pre>
输入: [1,2,0]
输出: 3
</pre>
<p>示例 2:</p>
<pre>
输入: [3,4,-1,1]
输出: 2
</pre>
<p>示例 3:</p>
<pre>
输入: [7,8,9,11,12]
输出: 1
</pre>

<p>提示：</p>
<p>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt;= <span class="number">0</span>:</span><br><span class="line">                nums[i] = n + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            cur_num = <span class="built_in">abs</span>(nums[i])</span><br><span class="line">            <span class="keyword">if</span> cur_num &lt;= n:</span><br><span class="line">                nums[cur_num - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[cur_num - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="42-接雨水-n"><a href="#42-接雨水-n" class="headerlink" title="42. 接雨水 [n]"></a>42. 接雨水 [n]</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p>示例 1：</p>
<pre>
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
</pre>
<p>示例 2：</p>
<pre>
输入：height = [4,2,0,3,2,5]
输出：9
</pre>

<p>提示：</p>
<ul>
<li>n == height.length</li>
<li>0 &lt;= n &lt;= 3 * 104</li>
<li>0 &lt;= height[i] &lt;= 105</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type height: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(height)</span><br><span class="line">        left_max = [<span class="number">0</span>] * n</span><br><span class="line">        right_max = [<span class="number">0</span>] * n</span><br><span class="line">        left_max[<span class="number">0</span>] = height[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            left_max[i] = <span class="built_in">max</span>(height[i], left_max[i - <span class="number">1</span>])</span><br><span class="line">        right_max[n - <span class="number">1</span>] = height[n - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            right_max[i] = <span class="built_in">max</span>(height[i], right_max[i + <span class="number">1</span>])</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">            res += <span class="built_in">min</span>(left_max[i], right_max[i]) - height[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a>45. 跳跃游戏 II</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>示例:</p>
<pre>
输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
</pre>
<p>说明:</p>
<ul>
<li>假设你总是可以到达数组的最后一个位置。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        max_pos = <span class="number">0</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n - <span class="number">1</span>):</span><br><span class="line">            max_pos = <span class="built_in">max</span>(max_pos, i + nums[i])</span><br><span class="line">            <span class="keyword">if</span> i == end:</span><br><span class="line">                end = max_pos</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode之链表</title>
    <url>/posts/fb43e507.html</url>
    <content><![CDATA[<p>链表的题目汇总在此了，欢迎大家光顾。</p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="/images/leetcode/linkedlist.png" style="width:600px;height:300px;"/></div></div>

<a id="more"></a>

<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例:</p>
<pre>
给定 1->2->3->4, 你应该返回 2->1->4->3.
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        r = dummy</span><br><span class="line">        p, q = head, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">and</span> q:</span><br><span class="line">            r.<span class="built_in">next</span> = q</span><br><span class="line">            p.<span class="built_in">next</span> = q.<span class="built_in">next</span></span><br><span class="line">            q.<span class="built_in">next</span> = p</span><br><span class="line">            r = p</span><br><span class="line">            p = r.<span class="built_in">next</span></span><br><span class="line">            q = p.<span class="built_in">next</span> <span class="keyword">if</span> p <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        r = dummy.<span class="built_in">next</span></span><br><span class="line">        dummy.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>

<h2 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a>82. 删除排序链表中的重复元素 II</h2><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p>
<p>示例 1:</p>
<pre>
输入: 1->2->3->3->4->4->5
输出: 1->2->5
</pre>
<p>示例 2:</p>
<pre>
输入: 1->1->1->2->3
输出: 2->3
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        p, cur = dummy, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            cnt = <span class="number">1</span></span><br><span class="line">            v = cur.val</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.val == v:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="number">1</span>:</span><br><span class="line">                p.<span class="built_in">next</span> = cur</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        p = dummy.<span class="built_in">next</span></span><br><span class="line">        dummy.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>

<h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h2><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<p>说明:</p>
<ul>
<li>1 ≤ m ≤ n ≤ 链表长度。</li>
</ul>
<p>示例:</p>
<pre>
输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
</pre>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode prev = dummy, cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (step &lt; m - <span class="number">1</span>) &#123;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            step += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - m; i++) &#123;</span><br><span class="line">            ListNode removed = cur.next;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line"></span><br><span class="line">            removed.next = prev.next;</span><br><span class="line">            prev.next = removed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode newHead = dummy.next;</span><br><span class="line">        dummy.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a>109. 有序链表转换二叉搜索树</h2><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<p>示例:</p>
<pre>
给定的有序链表： [-10, -3, 0, 5, 9],

一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
</pre>

<div class="tabs" id="leetcode-109"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-109-1">Python</a></li><li class="tab"><a class="#leetcode-109-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-109-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.buildTree(head, <span class="literal">None</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, head, tail</span>):</span></span><br><span class="line">        <span class="keyword">if</span> head == tail:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fast = slow = head</span><br><span class="line">        <span class="keyword">while</span> fast != tail <span class="keyword">and</span> fast.<span class="built_in">next</span> != tail:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        root = TreeNode(slow.val)</span><br><span class="line">        root.left = self.buildTree(head, slow)</span><br><span class="line">        root.right = self.buildTree(slow.<span class="built_in">next</span>, tail)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-109-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(head, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(ListNode head, ListNode tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != tail &amp;&amp; fast.next != tail) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">        root.left = buildTree(head, slow);</span><br><span class="line">        root.right = buildTree(slow.next, tail);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>说明：不允许修改给定的链表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        fast, slow = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> fast <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fast = head</span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>

<h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a>143. 重排链表</h2><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例 1:</p>
<pre>
给定链表 1->2->3->4, 重新排列为 1->4->2->3.
</pre>
<p>示例 2:</p>
<pre>
给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify head in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        fast, slow = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            prev = slow</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        prev.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        slow = self.reverseList(slow)</span><br><span class="line"></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> slow <span class="keyword">and</span> head:</span><br><span class="line">            ts, th = slow.<span class="built_in">next</span>, head.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = head</span><br><span class="line">            p.<span class="built_in">next</span>.<span class="built_in">next</span> = slow</span><br><span class="line">            slow = ts</span><br><span class="line">            head = th</span><br><span class="line">            p = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = slow <span class="keyword">if</span> slow <span class="keyword">else</span> head</span><br><span class="line"></span><br><span class="line">        p = dummy.<span class="built_in">next</span></span><br><span class="line">        dummy.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        p, q = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            r = q.<span class="built_in">next</span></span><br><span class="line">            q.<span class="built_in">next</span> = p</span><br><span class="line">            p = q</span><br><span class="line">            q = r</span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>

<h2 id="147-对链表进行插入排序-n"><a href="#147-对链表进行插入排序-n" class="headerlink" title="147. 对链表进行插入排序 [n]"></a>147. 对链表进行插入排序 [n]</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSortList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="keyword">while</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> head.val &lt;= head.<span class="built_in">next</span>.val:</span><br><span class="line">                head = head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = head.<span class="built_in">next</span></span><br><span class="line">                head.<span class="built_in">next</span> = tmp.<span class="built_in">next</span></span><br><span class="line">                q = dummy</span><br><span class="line">                <span class="keyword">while</span> q.<span class="built_in">next</span> <span class="keyword">and</span> q.<span class="built_in">next</span>.val &lt;= tmp.val:</span><br><span class="line">                    q = q.<span class="built_in">next</span></span><br><span class="line">                tmp.<span class="built_in">next</span> = q.<span class="built_in">next</span></span><br><span class="line">                q.<span class="built_in">next</span> = tmp</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a>148. 排序链表</h2><p>merge sort</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        prev, fast, slow = <span class="literal">None</span>, head, head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            prev = slow</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        prev.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        head = self.sortList(head)</span><br><span class="line">        slow = self.sortList(slow)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.merge(head, slow)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, l1, l2</span>):</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                p.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">        p = dummy.<span class="built_in">next</span></span><br><span class="line">        dummy.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>

<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a>234. 回文链表</h2><p>请判断一个链表是否为回文链表。</p>
<p>示例 1:</p>
<pre>
输入: 1->2
输出: false
</pre>
<p>示例 2:</p>
<pre>
输入: 1->2->2->1
输出: true
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        mid = self.get_mid_node(head)</span><br><span class="line">        mid = self.reverse_list(mid)</span><br><span class="line">        <span class="keyword">while</span> mid:</span><br><span class="line">            <span class="keyword">if</span> mid.val != head.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            mid = mid.<span class="built_in">next</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_mid_node</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_list</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        p, q = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            r = q.<span class="built_in">next</span></span><br><span class="line">            q.<span class="built_in">next</span> = p</span><br><span class="line">            p = q</span><br><span class="line">            q = r</span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>

<h2 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a>328. 奇偶链表</h2><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<p>示例 1:</p>
<pre>
输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
</pre>
<p>示例 2:</p>
<pre>
输入: 2->1->3->5->6->4->7->NULL 
输出: 2->3->6->7->1->5->4->NULL
</pre>
<p>说明:</p>
<ul>
<li>应当保持奇数节点和偶数节点的相对顺序。</li>
<li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        new_head_p, new_head_q = head, head.<span class="built_in">next</span></span><br><span class="line">        p, q = head, head.<span class="built_in">next</span></span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            next_p = q.<span class="built_in">next</span> <span class="keyword">if</span> q <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            next_q = next_p.<span class="built_in">next</span> <span class="keyword">if</span> next_p <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            p.<span class="built_in">next</span> = next_p</span><br><span class="line">            <span class="keyword">if</span> q:</span><br><span class="line">                q.<span class="built_in">next</span> = next_q</span><br><span class="line">            prev = p</span><br><span class="line">            p = next_p</span><br><span class="line">            q = next_q</span><br><span class="line"></span><br><span class="line">        prev.<span class="built_in">next</span> = new_head_q</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> new_head_p</span><br></pre></td></tr></table></figure>


<h2 id="430-扁平化多级双向链表-n"><a href="#430-扁平化多级双向链表-n" class="headerlink" title="430. 扁平化多级双向链表 [n]"></a>430. 扁平化多级双向链表 [n]</h2><p>您将获得一个双向链表，除了下一个和前一个指针之外，它还有一个子指针，可能指向单独的双向链表。这些子列表可能有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p>
<p>扁平化列表，使所有结点出现在单级双链表中。您将获得列表第一级的头部。</p>
<p>示例:</p>
<pre>
输入:
 1---2---3---4---5---6--NULL
         |
         7---8---9---10--NULL
             |
             11--12--NULL

输出:
1-2-3-7-8-11-12-9-10-4-5-6-NULL
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.dfs(head)</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.child:</span><br><span class="line">                <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = cur.child</span><br><span class="line">                cur.<span class="built_in">next</span>.prev = cur</span><br><span class="line">                child_last = self.dfs(cur.child)</span><br><span class="line">                child_last.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">next</span>:</span><br><span class="line">                    <span class="built_in">next</span>.prev = child_last</span><br><span class="line">                cur.child = <span class="literal">None</span></span><br><span class="line">            head = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

<h2 id="1019-链表中的下一个更大节点"><a href="#1019-链表中的下一个更大节点" class="headerlink" title="1019. 链表中的下一个更大节点"></a>1019. 链表中的下一个更大节点</h2><p>给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, … 。</p>
<p>每个节点都可能有下一个更大值（next larger value）：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j &gt; i 且  node_j.val &gt; node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。</p>
<p>返回整数答案数组 answer，其中 answer[i] = next_larger(node_{i+1}) 。</p>
<p>注意：在下面的示例中，诸如 [2,1,5] 这样的输入（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。</p>
<p>示例 1：</p>
<pre>
输入：[2,1,5]
输出：[5,5,0]
</pre>
<p>示例 2：</p>
<pre>
输入：[2,7,4,3,5]
输出：[7,0,5,5,0]
</pre>
<p>示例 3：</p>
<pre>
输入：[1,7,5,1,9,2,5,1]
输出：[7,9,9,9,0,5,0,0]
</pre>

<p>提示：</p>
<ul>
<li>对于链表中的每个节点，1 &lt;= node.val &lt;= 10^9</li>
<li>给定列表的长度在 [0, 10000] 范围内</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextLargerNodes</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            nums.append(head.val)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        res = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> nums[stk[-<span class="number">1</span>]] &lt; v:</span><br><span class="line">                res[stk.pop()] = v</span><br><span class="line">            stk.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="1171-从链表中删去总和值为零的连续节点-n"><a href="#1171-从链表中删去总和值为零的连续节点-n" class="headerlink" title="1171. 从链表中删去总和值为零的连续节点 [n]"></a>1171. 从链表中删去总和值为零的连续节点 [n]</h2><p>给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。</p>
<p>删除完毕后，请你返回最终结果链表的头节点。</p>
<p>你可以返回任何满足题目要求的答案。</p>
<p>（注意，下面示例中的所有序列，都是对 ListNode 对象序列化的表示。）</p>
<p>示例 1：</p>
<pre>
输入：head = [1,2,-3,3,1]
输出：[3,1]
提示：答案 [1,2,1] 也是正确的。
</pre>
<p>示例 2：</p>
<pre>
输入：head = [1,2,3,-3,4]
输出：[1,2,4]
</pre>
<p>示例 3：</p>
<pre>
输入：head = [1,2,3,-3,-2]
输出：[1]
</pre>

<p>提示：</p>
<ul>
<li>给你的链表中可能有 1 到 1000 个节点。</li>
<li>对于链表中的每个节点，节点的值：-1000 &lt;= node.val &lt;= 1000.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeZeroSumSublists</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line"></span><br><span class="line">        p = dummy</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            total += p.val</span><br><span class="line">            m[total] = p</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            total += p.val</span><br><span class="line">            p.<span class="built_in">next</span> = m[total].<span class="built_in">next</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        p = dummy.<span class="built_in">next</span> </span><br><span class="line">        dummy.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode刷题指南(持续更新中)</title>
    <url>/posts/af9ea9dd.html</url>
    <content><![CDATA[<p>这个LeetCode分类是我刷题过程中整理出来的值得刷的题目。</p>
<p>因为我对Python比较熟练，所以大部分代码是用Python实现的😬。</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="/images/leetcode/leetcode_note.jpg" style="width:600px;height:300px;"/></div></div>

<a id="more"></a>

<p>首先需要说明的是，本人不做大而全的刷题目录，题目现在实在太多了，而且网上已经有一些人这么做了，对于刚开始刷题的你其实并不是十分友好。如果需要我可以在结尾给出一些链接，基本涵盖了所有题目，而且也有一些详细的解释。本人也不做题解，因为代码能看懂的话基本上不需要再阐释了，如果你需要，可以参考我给出的链接，我在刷题过程中也参考了别人的解法。(打算等根据tag刷完后，将标记出<code>[n]</code>的题目给出一份详细的解题指南)总之三人行，必有我师。希望你的刷题之路顺利。</p>
<p>本人刷题一开始是按照官方上Tag来刷了，因为自己的算法基础比较薄弱，就采取了相对比较容易的路子。同时按照Tag刷，暗示了题目可能会用到的算法和数据结构，本人又只选取了简单和中等的题目，所以刷起来相对轻松一点。为了方便，这里列出了一些本人认为非常重要的Tag(✅表示已完成)：</p>
<table>
<th>Tag类别</th><th>完成状态</th><th>防迷路链接</th>
<tr><td>动态规划(中等)</td><td>✅</td><td><a href="/posts/903350571.html" title="LeetCode之动态规划(中等)">LeetCode之动态规划(中等)</a></td></tr>
<tr><td>数组(简单)</td><td>✅</td><td><a href="/posts/3027083408.html" title="LeetCode之数组(简单)">LeetCode之数组(简单)</a></td></tr>
<tr><td>数组(中等)</td><td>✅</td><td><a href="/posts/3239008047.html" title="LeetCode之数组(中等)">LeetCode之数组(中等)</a></td></tr>
<tr><td>数组(困难)</td><td>✅</td><td><a href="/posts/801922082.html" title="LeetCode之数组(困难)">LeetCode之数组(困难)</a></td></tr>
<tr><td>字符串(简单)</td><td>✅</td><td><a href="/posts/c026ad95.html" title="LeetCode之字符串(简单)">LeetCode之字符串(简单)</a></td></tr>
<tr><td>字符串(中等)</td><td>✅</td><td><a href="/posts/723701661.html" title="LeetCode之字符串(中等)">LeetCode之字符串(中等)</a></td></tr>
<tr><td>二叉树(简单)</td><td>✅</td><td><a href="/posts/94def828.html" title="LeetCode之二叉树(简单)">LeetCode之二叉树(简单)</a></td></tr>
<tr><td>二叉树(中等)</td><td>✅</td><td><a href="/posts/3ddb3bb0.html" title="LeetCode之二叉树(中等)">LeetCode之二叉树(中等)</a></td></tr>
<tr><td>链表</td><td>✅</td><td><a href="/posts/fb43e507.html" title="LeetCode之链表">LeetCode之链表</a></td></tr>
<tr><td>哈希表</td><td>✅</td><td><a href="/posts/2d8b42bd.html" title="LeetCode之哈希表">LeetCode之哈希表</a></td></tr>
<tr><td>栈和队列</td><td>✅</td><td><a href="/posts/1ccb8d85.html" title="LeetCode之栈和队列">LeetCode之栈和队列</a></td></tr>
</table>

<ul>
<li>堆</li>
<li>图</li>
<li>二分查找</li>
<li>深度优先遍历</li>
<li>广度优先遍历</li>
<li>双指针</li>
<li>回溯</li>
</ul>
<p>如果按照这些Tag来刷，并选择简单和中等的题目，大概可以刷400-500的题目，基础和经典的题目基本都能覆盖到，对于首次刷题的你还是很友好的。</p>
<p>另一种刷的方式就是按照公司来刷，比如你心意的FLAG(Facebook,Linkedin,Amazon,Google)和Microsoft。可以小试牛刀，看下各家面试题的风格。这里罗列几个比较出名的公司：</p>
<ul>
<li>Google [✅]</li>
<li>Microsoft [✅]</li>
<li>Linkedin [✅]</li>
<li>Facebook [✅]</li>
<li>Amazon [✅]</li>
</ul>
<p>最后的最后，给出本人认为比较好的几个人的刷题链接，在刷题的过程中可以看下别人的解法，对自己写代码的能力提升会很有帮助，废话不多讲，传送门如下：</p>
<ol>
<li>首推花花酱：<a href="https://zxi.mytechroad.com/blog/">https://zxi.mytechroad.com/blog/</a></li>
<li>grandyang的博客： <a href="https://www.cnblogs.com/grandyang/p/4606334.html">https://www.cnblogs.com/grandyang/p/4606334.html</a></li>
<li><a href="https://github.com/luliyucoordinate/Leetcode">https://github.com/luliyucoordinate/Leetcode</a></li>
<li><a href="https://github.com/WuLC/LeetCode/tree/master/Algorithm/Python">https://github.com/WuLC/LeetCode/tree/master/Algorithm/Python</a></li>
<li><a href="http://bookshadow.com/leetcode/">http://bookshadow.com/leetcode/</a></li>
<li><a href="https://blog.csdn.net/fuxuemingzhu">https://blog.csdn.net/fuxuemingzhu</a></li>
</ol>
<p>如果你需要的话，可以联系我，把你的刷题链接附上来，方便大家你我他😁。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>那些我认为不错的计算机专业书(仅面向后台开发)</title>
    <url>/posts/4f424561.html</url>
    <content><![CDATA[<p>如果你是程序员新人，那么这篇文章对你很有用，能让你少走一些弯路，多看一些经典书籍，打下扎实的计算机基础。</p>
<p>如果你是职场老鸟，那么这篇文章可能适合选读。有些书还是不错的，值得多读几遍。</p>
<p>友情提示：点击图书可以跳转到豆瓣，查看相应图书的目录内容和用户评价。</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="/images/book/cs_book_rec/cs_banner.png" style="width:600px;height:300px;"/></div></div>

<a id="more"></a>

<h2 id="前言，那些我想对你说的话"><a href="#前言，那些我想对你说的话" class="headerlink" title="前言，那些我想对你说的话"></a>前言，那些我想对你说的话</h2><p>作为一名程序员，猿龄有四五年了。断断续续看了不少专业书，有些书还是让我成长了不少的，所以安耐不住内心的冲动，非常想分享一波，正好借本人的博客与大家交流一下☺️。</p>
<p>可以这么说，每个分类都是本人精心挑选过的，本人也有看过才会推荐。不过一千个读者眼里有一千个哈姆雷特，每个人的经历和认知差异比较大，很难满足每个人的口味。所以这里只是挑选出每个分类下个人认为不错的top3。</p>
<p>再次提示：<strong>点击图书可以跳转到豆瓣，查看相应图书的目录内容和用户评价哦~</strong></p>
<h2 id="慢着，看XX语言之前你可能需要先看这里，嘿嘿"><a href="#慢着，看XX语言之前你可能需要先看这里，嘿嘿" class="headerlink" title="慢着，看XX语言之前你可能需要先看这里，嘿嘿"></a>慢着，看XX语言之前你可能需要先看这里，嘿嘿</h2><p>我想你的脑子里肯定蹦出来一句话:”你给我推荐这么多语言的书看虾米，我看不过来啊!“。是的，你看不过来的，我也看不过来，但是我为了推荐的完整性，就都罗列出来了。</p>
<p>不瞒你说，你需要从上述基本语言挑出你自己喜欢的主力语言和辅助语言了，因为不同语言可以满足不同的需求，有它自身的一些特点。选择的话你可以考虑以下几点:</p>
<ul>
<li>不会就选C。所以说它是必修课!(是的，你没看错就是C语言！你没得选，因为计算机软件专业课，第一门要学的语言就是它！这里强调一点，Linux操作系统就是C语言实现的哦！)</li>
<li>这门语言好学吗？我现在很想快点上手写一些代码呢？！(这条我推Python，只此一家，别无分店)</li>
<li>简单的我不想学，我想先学有难度的，因为难得东西好哈哈！(这条不说了，大家都明白，选C++吧，你会爱上它的o(<em>￣︶￣</em>)o)</li>
<li>我只想学一门语言，而且我想在这门语言深耕。(嗯不错，专一挺好的，那我推荐C++或者Java)</li>
<li>我已经会了C，也学了一门面向对象的语言(C++或者Java)，我想扩展一下，那可以学下Go看看。</li>
</ul>
<p>时间是有限的，你不可能上来就什么都学，那样的话你什么都没有学会，还有可能因为学太多而走火入魔。早点做选择也没有坏处，需要做选择的时候就要果断点。当然你可以先大概了解一下每一门语言然后再深入学你喜欢的，这样也没问题的。</p>
<p>废话少说，快开始你的表演吧~，那我就开始咯，show time!</p>
<h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><table>
    <tr>
        <td>
            <a href="https://book.douban.com/subject/1139336/"><img src="/images/book/cs_book_rec/c1.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/20432061/"><img src="/images/book/cs_book_rec/c2.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/2377310/"><img src="/images/book/cs_book_rec/c3.jpg" width = 240px height = 320px/></a>
        </td>
    </tr>
</table>

<h2 id="C-语言"><a href="#C-语言" class="headerlink" title="C++语言"></a>C++语言</h2><p>因为C++很难，所以这里多推荐一些书，哈哈，可能这里就劝退了一波人啦，坚持下来的人加油哦！高精尖技术等着你开发呢😀~</p>
<table>
    <tr>
        <td>
            <a href="https://book.douban.com/subject/25708312/"><img src="/images/book/cs_book_rec/cpp1.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/10789789/"><img src="/images/book/cs_book_rec/cpp2.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/5387403/"><img src="/images/book/cs_book_rec/cpp3.jpg" width = 240px height = 320px/></a>
        </td>
    </tr>
        <tr>
        <td>
            <a href="https://book.douban.com/subject/1110934/"><img src="/images/book/cs_book_rec/cpp4.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/1792179/"><img src="/images/book/cs_book_rec/cpp5.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/10427315/"><img src="/images/book/cs_book_rec/cpp6.jpg" width = 240px height = 320px/></a>
        </td>
    </tr>
</table>

<h2 id="Java语言"><a href="#Java语言" class="headerlink" title="Java语言"></a>Java语言</h2><p>老实说，Java要推荐的书也不少。</p>
<table>
    <tr>
        <td>
            <a href="https://book.douban.com/subject/2130190/"><img src="/images/book/cs_book_rec/java1.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/26880667/"><img src="/images/book/cs_book_rec/java2.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/30412517/"><img src="/images/book/cs_book_rec/java3.jpg" width = 240px height = 320px/></a>
        </td>
    </tr>
        <tr>
        <td>
            <a href="https://book.douban.com/subject/34907497/"><img src="/images/book/cs_book_rec/java4.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/10484692/"><img src="/images/book/cs_book_rec/java5.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/26740520/"><img src="/images/book/cs_book_rec/java6.jpg" width = 240px height = 320px/></a>
        </td>
    </tr>
</table>

<h2 id="Python语言"><a href="#Python语言" class="headerlink" title="Python语言"></a>Python语言</h2><p>Python版本有2和3之分，2的话官方好像已经停止维护了，所以推荐直接学Python3吧。</p>
<table>
    <tr>
        <td>
            <a href="https://book.douban.com/subject/3112503/"><img src="/images/book/cs_book_rec/python1.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/26381341/"><img src="/images/book/cs_book_rec/python2.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/27028517/"><img src="/images/book/cs_book_rec/python3.jpg" width = 240px height = 320px/></a>
        </td>
    </tr>
</table>

<h2 id="Go语言"><a href="#Go语言" class="headerlink" title="Go语言"></a>Go语言</h2><table>
    <tr>
        <td>
            <a href="https://book.douban.com/subject/27044219/"><img src="/images/book/cs_book_rec/go1.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/30424330/"><img src="/images/book/cs_book_rec/go2.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/27016236/"><img src="/images/book/cs_book_rec/go3.jpg" width = 240px height = 320px/></a>
        </td>
    </tr>
</table>

<h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><table>
    <tr>
        <td>
            <a href="https://book.douban.com/subject/19952400/"><img src="/images/book/cs_book_rec/algorithm1.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/20432061/"><img src="/images/book/cs_book_rec/algorithm2.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/26337727/"><img src="/images/book/cs_book_rec/algorithm3.jpg" width = 240px height = 320px/></a>
        </td>
    </tr>
</table>

<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>这几本操作系统书内容比较全面，对本科生来说深度也可以。需要重点关注的章节是进程、内存和IO。</p>
<table>
    <tr>
        <td>
            <a href="https://book.douban.com/subject/30297919/"><img src="/images/book/cs_book_rec/os1.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/5064311/"><img src="/images/book/cs_book_rec/os2.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/5064311/"><img src="/images/book/cs_book_rec/os3.jpg" width = 240px height = 320px/></a>
        </td>
    </tr>
</table>


<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>现在的应用程序可以说都离不开网络，无论什么客户端，都需要和server进行交互去拿相应的数据。因此掌握计算机网络相关知识就显得尤为重要。</p>
<p>对与《TCP/IP详解 卷1：协议》和《计算机网络》这两本书，需要重点关注的是运输层和应用层。也就是TCP/UDP和HTTP这几个协议。毕竟和程序员打交道最多的就是这两层了。希望同学能认真读完并掌握哦~</p>
<p>对于《UNIX网络编程 卷1》。最需要掌握的是C/S编程范式(主要是tcp的socket编程，包括多进程、多线程和I/O复用)。</p>
<table>
    <tr>
        <td>
            <a href="https://book.douban.com/subject/26825411/"><img src="/images/book/cs_book_rec/network2.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/26960678/"><img src="/images/book/cs_book_rec/network1.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/4859464/"><img src="/images/book/cs_book_rec/network3.jpg" width = 240px height = 320px/></a>
        </td>
    </tr>
</table>

<h2 id="Linux编程"><a href="#Linux编程" class="headerlink" title="Linux编程"></a>Linux编程</h2><table>
    <tr>
        <td>
            <a href="https://book.douban.com/subject/25900403/"><img src="/images/book/cs_book_rec/linux1.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/1219329/"><img src="/images/book/cs_book_rec/linux2.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/24722611/"><img src="/images/book/cs_book_rec/linux3.jpg" width = 240px height = 320px/></a>
        </td>
    </tr>
</table>

<h2 id="后记，既然看到这里了，再听我唠叨几句又何妨-手动狗头"><a href="#后记，既然看到这里了，再听我唠叨几句又何妨-手动狗头" class="headerlink" title="后记，既然看到这里了，再听我唠叨几句又何妨(手动狗头)"></a>后记，既然看到这里了，再听我唠叨几句又何妨(手动狗头)</h2><p>如果你认真看完了上面所列的书籍，除了运气成分外，面大厂你的基础应该是很扎实了，但是有句话还是要讲一下就是”纸上得来终觉浅，绝知此事要躬行”，这句话对看这篇文章的人讲，也是对我自己讲。实践是1，看书是0，有了实践再看书相当于往1后面添加0，如果不实践看再多的书也是0。希望和大家一起共勉把！</p>
]]></content>
      <categories>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>谈一谈你对进程和线程的认识(未完待续...)</title>
    <url>/posts/3970838420.html</url>
    <content><![CDATA[<p>这是自己看完几本操作系统书和网上一些博客后，为了加深自己对进程和线程的认识，写的总结性的文章，也希望这篇文章能让你耳目一新^_^。</p>
<p>这篇文章只谈概念，不谈代码。如果你理解了概念，写代码的时候思路就会变得很清晰，不会陷入我也不知道自己在写神马的困境。</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="/images/tech/process_and_thread/process_and_thread_preivew.png" style="width:600px;height:300px;"/></div></div>

<a id="more"></a>

<h2 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h2><ol>
<li><p>进程是执行中的程序，是<strong>操作系统分配资源的基本单位</strong>。</p>
</li>
<li><p>内存中的进程结构如图所示:</p>
<img src="/images/tech/process_and_thread/process1.png" width = 240px height = 360px/></li>
<li><p>进程在执行时会改变状态，每个进程可能处于下列状态中的某一个，如图所示:</p>
 <img src="/images/tech/process_and_thread/process2.png" width = 600px height = 300px/></li>
<li><p>每个进程在操作系统内用程序控制块(PCB)来表示。PCB通常包含了以下几类信息:</p>
<ul>
<li><p>程序状态:包括新的、就绪、运行、等待、停止等。</p>
</li>
<li><p>程序计数器:计数器表示进程要执行的下个指令的地址。</p>
</li>
<li><p>CPU寄存器:与程序计数器一起，寄存器的状态信息在出现中断时也需要保存，以便进程以后能正确地继续执行。</p>
</li>
<li><p>CPU调度信息:包括进程优先级、调度队列的指针和其他调度参数。</p>
</li>
<li><p>内存管理信息:包括基址和界限寄存器的值、页表或段表。</p>
</li>
<li><p>记账信息:包括CPU时间、实际使用时间、时间界限、记账数据、作业或进程数量等。</p>
</li>
<li><p>I/O状态信息:包括分配给进程的I/O设备列表、打开的文件列表等。</p>
<img src="/images/tech/process_and_thread/process3.png" width = 500px height = 500px/>
</li>
</ul>
</li>
<li><p>驻留在内存中就绪的、等待运行的进程保存在就绪队列中，该队列通常用双向链表来实现。等待特定I/O设备的进程列表称为设备队列，每个设备都有自己的设备队列。</p>
 <img src="/images/tech/process_and_thread/process4.png" width = 540px height = 500px/>
</li>
<li><p>绝大多数进程可以分为I/O密集型或CPU密集型。I/O密集型的进程在执行I/O方面比执行计算要花费更多的时间。CPU密集型的进程将更多的时间用在计算上。</p>
</li>
<li><p>将CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态，这一任务被称为<strong>上下文切换</strong>。上下文切换时间是额外开销，因为切换时系统并不能做什么有用的工作。</p>
</li>
<li><p>进程在执行过程中，能够通过创建进程系统调用创建多个新进程。大多数操作系统根据一个唯一的进程标识符来识别进程，pid(process identifier)通常是一个整数值。</p>
</li>
<li><p>进程间通信有两种基本模式:共享内存和消息传递。在共享内存模式中，建立起一块共进程共享的内存区域，进程通过向此共享区域读或写入数据来交换信息。在消息传递模式中，通过在进程间交换消息来实现通信。</p>
 <img src="/images/tech/process_and_thread/process5.png" width = 580px height = 440px/>

</li>
</ol>
<p>消息传递对于交换较少数量的数据很有用，因为不需要避免冲突。对于计算机间的通信，消息传递也比共享内存更易于实现。共享内存允许以最快的速度进行方便的通信，在计算机中它可以达到内存的速度。共享内存比消息传递快，消息传递系统通常用系统调用来实现，因此需要更多的内核介入的时间消耗。共享内存系统中仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有的访问都被处理为常规的内存访问，不需要内核的帮助。(<strong>共享内存和消息传递的比较</strong>)</p>
<h2 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h2><ol>
<li><p>线程是<strong>操作系统调度的基本单位</strong>，由线程ID、程序计数器、寄存器集合和栈组成。它与属于同一进程的其他线程共享代码段、数据段和其他操作系统资源，如打开文件和信号。</p>
 <img src="/images/tech/process_and_thread/thread1.png" width = 580px height = 400px/>
</li>
<li><p>多线程编程有4个优点:</p>
<ul>
<li>响应度高:如果对一个交互程序采用多线程，那么即使其他部分阻塞或执行较冗长的操作，该程序仍能继续执行，从而增加了对用户的响应程度。</li>
<li>资源共享:线程默认共享它们所属进程的内存和资源。</li>
<li>经济:进程创建所需要的内存和资源的分配比较昂贵。由于线程共享它们所属进程的资源，所以创建和切换线程会更为经济。</li>
<li>多处理器体系结构的利用:能充分利用多处理器体系结构，以便每个进程能并行运行在不同的处理器上。<strong>在多CPU上使用多线程加强了并发功能</strong>。</li>
</ul>
</li>
<li><p><strong>线程池</strong>的主要思想是在进程开始时创建一定数量的线程，并放入到池中以等待工作。当服务器收到请求时，它会唤醒池中的一个线程，并将要处理的请求传递给它。一旦线程完成了服务，它会返回池中再等待工作。如果池中没有可用的线程，那么服务器会一直等到有空线程为止。<strong>线程池有如下几个优点</strong>:</p>
<ul>
<li>通常用现有线程处理请求要比等待创建新的线程要快。</li>
<li>线程池限制了在任何时候可用线程的数量。这对那些不能支持大量并发线程的系统非常重要。</li>
</ul>
</li>
</ol>
<p>线程池中的线程数量由系统CPU的数量、物理内存的大小和并发客户请求的期望值等因素决定。</p>
<h2 id="进程和线程有哪些联系和区别？"><a href="#进程和线程有哪些联系和区别？" class="headerlink" title="进程和线程有哪些联系和区别？"></a>进程和线程有哪些联系和区别？</h2><h2 id="多进程还是多线程？我该怎么选择呢？"><a href="#多进程还是多线程？我该怎么选择呢？" class="headerlink" title="多进程还是多线程？我该怎么选择呢？"></a>多进程还是多线程？我该怎么选择呢？</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《操作系统概念》</li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode之动态规划(中等)</title>
    <url>/posts/903350571.html</url>
    <content><![CDATA[<p>动态规划(中等)的题目汇总在此了，欢迎大家光顾。</p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="/images/leetcode/dp.png" style="width:600px;height:300px;"/></div></div>

<a id="more"></a>

<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p>示例 1：</p>
<pre>
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
</pre>
<p>示例 2：</p>
<pre>
输入: "cbbd"
输出: "bb"
</pre>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">private</span> String res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            helper(s, i, i);</span><br><span class="line">            helper(s, i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left, j = right;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">while</span> (i &gt; -<span class="number">1</span> &amp;&amp; j &lt; n &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">            i -= <span class="number">1</span>;</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j - i - <span class="number">1</span> &gt; len) &#123;</span><br><span class="line">            len = j - i - <span class="number">1</span>;</span><br><span class="line">            res = s.substring(i + <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a>91. 解码方法</h2><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p>
<pre>
'A' -> 1
'B' -> 2
...
'Z' -> 26
给定一个只包含数字的非空字符串，请计算解码方法的总数。
</pre>
<p>示例 1:</p>
<pre>
输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
</pre>
<p>示例 2:</p>
<pre>
输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
</pre>

<div class="tabs" id="leetcode-91"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-91-1">Python</a></li><li class="tab"><a class="#leetcode-91-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-91-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span> <span class="keyword">if</span> s[<span class="number">0</span>] != <span class="string">&#x27;0&#x27;</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            one_c = <span class="built_in">int</span>(s[i - <span class="number">1</span>: i])</span><br><span class="line">            two_c = <span class="built_in">int</span>(s[i - <span class="number">2</span>: i])</span><br><span class="line">            <span class="keyword">if</span> <span class="number">1</span> &lt;= one_c &lt;= <span class="number">9</span>:</span><br><span class="line">                dp[i] += dp[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="number">10</span> &lt;= two_c &lt;= <span class="number">26</span>:</span><br><span class="line">                dp[i] += dp[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-91-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            String one_s = s.substring(i - <span class="number">1</span>, i);</span><br><span class="line">            String two_s = s.substring(i - <span class="number">2</span>, i);</span><br><span class="line">            <span class="keyword">int</span> one = Integer.parseInt(one_s);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;= one &amp;&amp; one &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">                dp[i] += dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> two = Integer.parseInt(two_s);</span><br><span class="line">            <span class="keyword">if</span> (two &gt;= <span class="number">10</span> &amp;&amp; two &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">                dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="120-三角形最小路径和-n"><a href="#120-三角形最小路径和-n" class="headerlink" title="120. 三角形最小路径和 [n]"></a>120. 三角形最小路径和 [n]</h2><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<pre>
例如，给定三角形：

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
</pre>

<div class="tabs" id="leetcode-120"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-120-1">Python</a></li><li class="tab"><a class="#leetcode-120-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-120-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span>(<span class="params">self, triangle</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type triangle: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        rows = <span class="built_in">len</span>(triangle)</span><br><span class="line">        cols = <span class="built_in">len</span>(triangle[rows - <span class="number">1</span>])</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(cols)] <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(rows)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">0</span>, i + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + triangle[i][j]</span><br><span class="line">                <span class="keyword">elif</span> i == j:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + triangle[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + triangle[i][j]</span><br><span class="line">        res = dp[rows - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, cols):</span><br><span class="line">            res = <span class="built_in">min</span>(res, dp[rows - <span class="number">1</span>][i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-120-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = triangle.size();</span><br><span class="line">        <span class="keyword">int</span> cols = triangle.get(rows - <span class="number">1</span>).size();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = triangle.get(i).get(j);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = triangle.get(i).get(j) + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == i) &#123;</span><br><span class="line">                    dp[i][j] = triangle.get(i).get(j) + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = dp[rows - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cols; i++) &#123;</span><br><span class="line">            res = Math.min(res, dp[rows - <span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="139-单词拆分-n"><a href="#139-单词拆分-n" class="headerlink" title="139. 单词拆分 [n]"></a>139. 单词拆分 [n]</h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<ul>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<p>示例 1：</p>
<pre>
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
</pre>
<p>示例 2：</p>
<pre>
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
     注意你可以重复使用字典中的单词。
</pre>
<p>示例 3：</p>
<pre>
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
</pre>

<div class="tabs" id="leetcode-139"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-139-1">Python</a></li><li class="tab"><a class="#leetcode-139-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-139-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span>(<span class="params">self, s, wordDict</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type wordDict: List[str]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        word_set = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordDict:</span><br><span class="line">            word_set.add(word)</span><br><span class="line">        dp = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="built_in">len</span>(s) + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="built_in">len</span>(s) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i):</span><br><span class="line">                <span class="keyword">if</span> dp[j] <span class="keyword">and</span> s[j: i] <span class="keyword">in</span> word_set:</span><br><span class="line">                    dp[i] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">len</span>(s)] </span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-139-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a>152. 乘积最大子数组</h2><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）。</p>
<p>示例 1:</p>
<pre>
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
</pre>
<p>示例 2:</p>
<pre>
输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        max_n, min_n, res = nums[<span class="number">0</span>], nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            tmp = max_n</span><br><span class="line">            max_n = <span class="built_in">max</span>(max_n * nums[i], min_n * nums[i], nums[i])</span><br><span class="line">            min_n = <span class="built_in">min</span>(tmp * nums[i], min_n * nums[i], nums[i])</span><br><span class="line">            <span class="keyword">if</span> max_n &gt; res:</span><br><span class="line">                res = max_n</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="221-最大正方形-n"><a href="#221-最大正方形-n" class="headerlink" title="221. 最大正方形 [n]"></a>221. 最大正方形 [n]</h2><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
<p>示例:</p>
<pre>
输入: 

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

输出: 4
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span>(<span class="params">self, matrix</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type matrix: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> matrix <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        rows, cols = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(cols + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(rows + <span class="number">1</span>)]</span><br><span class="line">        max_edge = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, rows + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, cols + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">                    max_edge = <span class="built_in">max</span>(max_edge, dp[i][j])</span><br><span class="line">        <span class="keyword">return</span> max_edge * max_edge</span><br></pre></td></tr></table></figure>

<h2 id="264-丑数-II"><a href="#264-丑数-II" class="headerlink" title="264. 丑数 II"></a>264. 丑数 II</h2><p>编写一个程序，找出第 n 个丑数。</p>
<p>丑数就是只包含质因数 2, 3, 5 的正整数。</p>
<p>示例:</p>
<pre>
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
</pre>
<p>说明:  </p>
<ul>
<li>1 是丑数。</li>
<li>n 不超过1690。</li>
</ul>
<div class="tabs" id="leetcode-264"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-264-1">Python</a></li><li class="tab"><a class="#leetcode-264-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-264-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        i2, i3, i5 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            min_v = <span class="built_in">min</span>(dp[i2] * <span class="number">2</span>, dp[i3] * <span class="number">3</span>, dp[i5] * <span class="number">5</span>)</span><br><span class="line">            dp[i] = min_v</span><br><span class="line">            <span class="keyword">if</span> min_v == dp[i2] * <span class="number">2</span>:</span><br><span class="line">                i2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> min_v == dp[i3] * <span class="number">3</span>:</span><br><span class="line">                i3 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> min_v == dp[i5] * <span class="number">5</span>:</span><br><span class="line">                i5+= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-264-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx2 = <span class="number">0</span>, idx3 = <span class="number">0</span>, idx5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minV = Math.min(dp[idx2] * <span class="number">2</span>, Math.min(dp[idx3] * <span class="number">3</span>, dp[idx5] * <span class="number">5</span>));</span><br><span class="line">            dp[i] = minV;</span><br><span class="line">            <span class="keyword">if</span> (minV == dp[idx2] * <span class="number">2</span>) &#123;</span><br><span class="line">                idx2 += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minV == dp[idx3] * <span class="number">3</span>) &#123;</span><br><span class="line">                idx3 += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minV == dp[idx5] * <span class="number">5</span>) &#123;</span><br><span class="line">                idx5 += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="279-完全平方数-n"><a href="#279-完全平方数-n" class="headerlink" title="279. 完全平方数 [n]"></a>279. 完全平方数 [n]</h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>示例 1:</p>
<pre>
输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.
</pre>
<p>示例 2:</p>
<pre>
输入: n = 13
输出: 2
解释: 13 = 4 + 9.
</pre>

<div class="tabs" id="leetcode-279"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-279-1">Python</a></li><li class="tab"><a class="#leetcode-279-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-279-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            j = <span class="number">1</span></span><br><span class="line">            dp[i] = i</span><br><span class="line">            <span class="keyword">while</span> i - j * j &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i - j * j] + <span class="number">1</span>)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-279-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = i;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i - j * j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a>300. 最长上升子序列</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:</p>
<pre>
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
</pre>
<p>说明:</p>
<ul>
<li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li>
<li>你算法的时间复杂度应该为 O(n2) 。</li>
</ul>
<div class="tabs" id="leetcode-300"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-300-1">Python</a></li><li class="tab"><a class="#leetcode-300-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-300-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> nums <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="built_in">len</span>(nums))]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(nums)):</span><br><span class="line">            dp[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">            res = <span class="built_in">max</span>(dp[i], res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-300-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(dp[i], res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="309-最佳买卖股票时机含冷冻期-n"><a href="#309-最佳买卖股票时机含冷冻期-n" class="headerlink" title="309. 最佳买卖股票时机含冷冻期 [n]"></a>309. 最佳买卖股票时机含冷冻期 [n]</h2><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p>
<p>示例:</p>
<pre>
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        hold, sold, rest = -<span class="number">1</span> &lt;&lt; <span class="number">32</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            prev_sold = sold</span><br><span class="line">            sold = hold + price</span><br><span class="line">            hold = <span class="built_in">max</span>(hold, rest - price)</span><br><span class="line">            rest = <span class="built_in">max</span>(rest, prev_sold)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(rest, sold)</span><br></pre></td></tr></table></figure>

<h2 id="322-零钱兑换-n"><a href="#322-零钱兑换-n" class="headerlink" title="322. 零钱兑换 [n]"></a>322. 零钱兑换 [n]</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>示例 1:</p>
<pre>
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
</pre>
<p>示例 2:</p>
<pre>
输入: coins = [2], amount = 3
输出: -1
</pre>
<p>说明:</p>
<ul>
<li>你可以认为每种硬币的数量是无限的。</li>
</ul>
<div class="tabs" id="leetcode-322"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-322-1">Python</a></li><li class="tab"><a class="#leetcode-322-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-322-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins, amount</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        INT_MAX = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span></span><br><span class="line">        dp = [INT_MAX <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(amount + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, amount + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> coins:</span><br><span class="line">                <span class="keyword">if</span> i &gt;= j:</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[i - j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> dp[amount] == INT_MAX:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> dp[amount]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-322-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> max = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            dp[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; amount + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= coin) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == max ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="343-整数拆分-n"><a href="#343-整数拆分-n" class="headerlink" title="343. 整数拆分 [n]"></a>343. 整数拆分 [n]</h2><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>
<p>示例 1:</p>
<pre>
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
</pre>
<p>示例 2:</p>
<pre>
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
说明: 你可以假设 n 不小于 2 且不大于 58。
</pre>


<div class="tabs" id="leetcode-343"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-343-1">Python</a></li><li class="tab"><a class="#leetcode-343-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-343-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            cur_max = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, i):</span><br><span class="line">                cur_max = <span class="built_in">max</span>(cur_max, j * (i - j), j * dp[i - j])</span><br><span class="line">            dp[i] = cur_max</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-343-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                curMax = Math.max(curMax, Math.max(j * (i - j), j * dp[i - j]));</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = curMax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="357-计算各个位数不同的数字个数"><a href="#357-计算各个位数不同的数字个数" class="headerlink" title="357. 计算各个位数不同的数字个数"></a>357. 计算各个位数不同的数字个数</h2><p>给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x &lt; 10^n 。</p>
<p>示例:</p>
<pre>
输入: 2
输出: 91 
解释: 答案应为除去 11,22,33,44,55,66,77,88,99 外，在 [0,100) 区间内的所有数字。
</pre>

<div class="tabs" id="leetcode-357"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-357-1">Python</a></li><li class="tab"><a class="#leetcode-357-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-357-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNumbersWithUniqueDigits</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">11</span>)]</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">9</span> * <span class="number">9</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">3</span>, <span class="number">11</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] * (<span class="number">10</span> - i + <span class="number">1</span>)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">min</span>(n, <span class="number">10</span>) + <span class="number">1</span>):</span><br><span class="line">            res += dp[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-357-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">9</span> * <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] * (<span class="number">10</span> - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Math.min(<span class="number">10</span>, n); i++) &#123;</span><br><span class="line">            res += dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="377-组合总和-Ⅳ-n"><a href="#377-组合总和-Ⅳ-n" class="headerlink" title="377. 组合总和 Ⅳ [n]"></a>377. 组合总和 Ⅳ [n]</h2><p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p>
<p>示例:</p>
<pre>
nums = [1, 2, 3]
target = 4

所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

请注意，顺序不同的序列被视作不同的组合。

因此输出为 7。
</pre>

<div class="tabs" id="leetcode-377"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-377-1">Python</a></li><li class="tab"><a class="#leetcode-377-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-377-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(target + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, target + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> i &gt;= n:</span><br><span class="line">                    dp[i] += dp[i - n]</span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-377-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= n) &#123;</span><br><span class="line">                    dp[i] += dp[i - n];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="416-分割等和子集-n"><a href="#416-分割等和子集-n" class="headerlink" title="416. 分割等和子集 [n]"></a>416. 分割等和子集 [n]</h2><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>注意:</p>
<ul>
<li>每个数组中的元素不会超过 100</li>
<li>数组的大小不会超过 200</li>
</ul>
<p>示例 1:</p>
<pre>
输入: [1, 5, 11, 5]

输出: true

解释: 数组可以分割成 [1, 5, 5] 和 [11].
</pre>

<p>示例 2:</p>
<pre>
输入: [1, 2, 3, 5]

输出: false

解释: 数组不能分割成两个元素和相等的子集.
</pre>

<div class="tabs" id="leetcode-416"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-416-1">Python</a></li><li class="tab"><a class="#leetcode-416-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-416-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        total = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        total = total / <span class="number">2</span></span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(total + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, total + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - nums[i - <span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]] <span class="keyword">or</span> dp[i - <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[n][total]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-416-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            total += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (total % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = total / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length + <span class="number">1</span>][target + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= target; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - nums[i - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="494-目标和-n"><a href="#494-目标和-n" class="headerlink" title="494. 目标和 [n]"></a>494. 目标和 [n]</h2><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p>示例 1:</p>
<pre>
输入: nums: [1, 1, 1, 1, 1], S: 3
输出: 5
解释: 

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。
</pre>
<p>注意:</p>
<ul>
<li>数组非空，且长度不会超过20。</li>
<li>初始的数组的和不会超过1000。</li>
<li>保证返回的最终结果能被32位整数存下。</li>
</ul>
<div class="tabs" id="leetcode-494"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-494-1">Python</a></li><li class="tab"><a class="#leetcode-494-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-494-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span>(<span class="params">self, nums, S</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type S: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        total = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> S &gt; total <span class="keyword">or</span> (S + total) % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        P = (S + total) / <span class="number">2</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(P + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(P, n - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                dp[i] += dp[i - n]</span><br><span class="line">        <span class="keyword">return</span> dp[P]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-494-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            total += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (S &gt; total || (S + total) % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> P = (S + total) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[P + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = P; i &gt;= n; i--) &#123;</span><br><span class="line">                dp[i] += dp[i - n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[P];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a>516. 最长回文子序列</h2><p>给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。</p>
<p>示例 1:</p>
<pre>
输入:

"bbbab"
输出:

4
一个可能的最长回文子序列为 "bbbb"。
</pre>
<p>示例 2:</p>
<pre>
输入:

"cbbd"
输出:

2
一个可能的最长回文子序列为 "bb"。
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[i][i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="650-只有两个键的键盘"><a href="#650-只有两个键的键盘" class="headerlink" title="650. 只有两个键的键盘"></a>650. 只有两个键的键盘</h2><p>最初在一个记事本上只有一个字符 ‘A’。你每次可以对这个记事本进行两种操作：</p>
<p>Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。<br>Paste (粘贴) : 你可以粘贴你上一次复制的字符。<br>给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 ‘A’。输出能够打印出 n 个 ‘A’ 的最少操作次数。</p>
<p>示例 1:</p>
<pre>
输入: 3
输出: 3
解释:
最初, 我们只有一个字符 'A'。
第 1 步, 我们使用 Copy All 操作。
第 2 步, 我们使用 Paste 操作来获得 'AA'。
第 3 步, 我们使用 Paste 操作来获得 'AAA'。
</pre>
<p>说明:</p>
<ul>
<li>n 的取值范围是 [1, 1000] 。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSteps</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [n] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, i):</span><br><span class="line">                <span class="keyword">if</span> i % j == <span class="number">0</span>:</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[j] + i / j)</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<h2 id="673-最长递增子序列的个数"><a href="#673-最长递增子序列的个数" class="headerlink" title="673. 最长递增子序列的个数"></a>673. 最长递增子序列的个数</h2><p>给定一个未排序的整数数组，找到最长递增子序列的个数。</p>
<p>示例 1:</p>
<pre>
输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
</pre>
<p>示例 2:</p>
<pre>
输入: [2,2,2,2,2]
输出: 5
解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。
注意: 给定的数组长度不超过 2000 并且结果一定是32位有符号整数。
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberOfLIS</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> nums <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        counter = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    <span class="keyword">if</span> dp[j] + <span class="number">1</span> &gt; dp[i]:</span><br><span class="line">                        dp[i] = dp[j] + <span class="number">1</span></span><br><span class="line">                        counter[i] = counter[j]</span><br><span class="line">                    <span class="keyword">elif</span> dp[j] + <span class="number">1</span> == dp[i]:</span><br><span class="line">                        counter[i] += counter[j]</span><br><span class="line">        max_len = <span class="built_in">max</span>(dp)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">if</span> dp[i] == max_len:</span><br><span class="line">                res += counter[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode之字符串(中等)</title>
    <url>/posts/723701661.html</url>
    <content><![CDATA[<p>字符串(中等)的题目汇总在此了，欢迎大家光顾。</p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="/images/leetcode/string2.png" style="width:600px;height:300px;"/></div></div>

<a id="more"></a>

<h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h2><p>给定一个字符串，请你找出其中不含有重复字符的<code>最长子串</code>的长度。</p>
<p>示例 1:</p>
<pre>
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
</pre>
<p>示例 2:</p>
<pre>
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
</pre>
<p>示例 3:</p>
<pre>
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
</pre>


<div class="tabs" id="leetcode-3"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-3-1">Python</a></li><li class="tab"><a class="#leetcode-3-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-3-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        cset = <span class="built_in">set</span>()</span><br><span class="line">        i, j, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; n:</span><br><span class="line">            <span class="keyword">if</span> s[j] <span class="keyword">not</span> <span class="keyword">in</span> cset:</span><br><span class="line">                cset.add(s[j])</span><br><span class="line">                res = <span class="built_in">max</span>(res, j - i + <span class="number">1</span>)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cset.remove(s[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-3-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Character&gt; hashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashSet.contains(s.charAt(i))) &#123;</span><br><span class="line">                hashSet.remove(s.charAt(j));</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hashSet.add(s.charAt(i));</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, i - j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p>示例 1：</p>
<pre>
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
</pre>
<p>示例 2：</p>
<pre>
输入: "cbbd"
输出: "bb"
</pre>


<div class="tabs" id="leetcode-5"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-5-1">Python</a></li><li class="tab"><a class="#leetcode-5-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-5-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        res_left, res_right, res_len = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            l1, r1, len1 = self.helper(s, i, i)</span><br><span class="line">            l2, r2, len2 = self.helper(s, i, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> len1 &gt; len2:</span><br><span class="line">                <span class="keyword">if</span> len1 &gt; res_len:</span><br><span class="line">                    res_left, res_right, res_len = l1, r1, len1</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> len2 &gt; res_len:</span><br><span class="line">                    res_left, res_right, res_len = l2, r2, len2</span><br><span class="line">        res_str = s[res_left:res_right + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res_str</span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, s, left, right</span>):</span></span><br><span class="line">        L, R = left, right</span><br><span class="line">        <span class="keyword">while</span> L &gt;= <span class="number">0</span> <span class="keyword">and</span> R &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[L] == s[R]:</span><br><span class="line">            L -= <span class="number">1</span></span><br><span class="line">            R += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> L + <span class="number">1</span>, R - <span class="number">1</span>, R - L - <span class="number">1</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-5-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">private</span> String res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            helper(s, i, i);</span><br><span class="line">            helper(s, i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left, j = right;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">while</span> (i &gt; -<span class="number">1</span> &amp;&amp; j &lt; n &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">            i -= <span class="number">1</span>;</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j - i - <span class="number">1</span> &gt; len) &#123;</span><br><span class="line">            len = j - i - <span class="number">1</span>;</span><br><span class="line">            res = s.substring(i + <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="6-ZZ-字形变换"><a href="#6-ZZ-字形变换" class="headerlink" title="6. ZZ 字形变换"></a>6. ZZ 字形变换</h2><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>
<pre>
L   C   I   R
E T O E S I I G
E   D   H   N
</pre>
<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<pre>
string convert(string s, int numRows);
</pre>
<p>示例 1:</p>
<pre>
输入: s = "LEETCODEISHIRING", numRows = 3
输出: "LCIRETOESIIGEDHN"
</pre>
<p>示例 2:</p>
<pre>
输入: s = "LEETCODEISHIRING", numRows = 4
输出: "LDREOEIIECIHNTSG"
解释:

L     D     R
E   O E   I I
E C   I H   N
T     S     G
</pre>


<div class="tabs" id="leetcode-6"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-6-1">Python</a></li><li class="tab"><a class="#leetcode-6-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-6-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span>(<span class="params">self, s, numRows</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type numRows: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        s_list = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(numRows)]</span><br><span class="line">        i, n = <span class="number">0</span>, <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">0</span>, numRows):</span><br><span class="line">                <span class="keyword">if</span> i &lt; n:</span><br><span class="line">                    s_list[j].append(s[i])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(numRows - <span class="number">2</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i &lt; n:</span><br><span class="line">                    s_list[j].append(s[i])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(numRows):</span><br><span class="line">            res.extend(s_list[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(res)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-6-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        List&lt;StringBuilder&gt; sbs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numRows; j++) &#123;</span><br><span class="line">            sbs.add(<span class="keyword">new</span> StringBuilder());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sbs.size());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, n = s.length();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numRows; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">                    sbs.get(j).append(s.charAt(i));</span><br><span class="line">                    i += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = numRows - <span class="number">2</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">                    sbs.get(j).append(s.charAt(i));</span><br><span class="line">                    i += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (StringBuilder sb : sbs) &#123;</span><br><span class="line">            res.append(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h2><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
<p>例如，给出 n = 3，生成结果为：</p>
<pre>
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
</pre>


<div class="tabs" id="leetcode-22"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-22-1">Python</a></li><li class="tab"><a class="#leetcode-22-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-22-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        item, res = <span class="string">&#x27;&#x27;</span>, []</span><br><span class="line">        self.helper(res, item, <span class="number">0</span>, <span class="number">0</span>, n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, res, item, left, right, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left == n <span class="keyword">and</span> right == n:</span><br><span class="line">            res.append(item)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; n:</span><br><span class="line">            self.helper(res, item + <span class="string">&#x27;(&#x27;</span>, left + <span class="number">1</span>, right, n)</span><br><span class="line">        <span class="keyword">if</span> right &lt; left:</span><br><span class="line">            self.helper(res, item + <span class="string">&#x27;)&#x27;</span>, left, right + <span class="number">1</span>, n)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-22-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(n, n, <span class="string">&quot;&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, String cur, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            helper(left - <span class="number">1</span>, right, cur + <span class="string">&quot;(&quot;</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">            helper(left, right - <span class="number">1</span>, cur + <span class="string">&quot;)&quot;</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a>91. 解码方法</h2><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p>
<pre>
'A' -> 1
'B' -> 2
...
'Z' -> 26
</pre>
<p>给定一个只包含数字的非空字符串，请计算解码方法的总数。</p>
<p>示例 1:</p>
<pre>
输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
</pre>
<p>示例 2:</p>
<pre>
输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
</pre>


<div class="tabs" id="leetcode-91"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-91-1">Python</a></li><li class="tab"><a class="#leetcode-91-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-91-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span> <span class="keyword">if</span> s[<span class="number">0</span>] != <span class="string">&#x27;0&#x27;</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            one_c = <span class="built_in">int</span>(s[i - <span class="number">1</span>:i])</span><br><span class="line">            two_c = <span class="built_in">int</span>(s[i - <span class="number">2</span>:i])</span><br><span class="line">            <span class="keyword">if</span> <span class="number">1</span> &lt;= one_c &lt;= <span class="number">9</span>:</span><br><span class="line">                dp[i] += dp[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="number">10</span> &lt;= two_c &lt;= <span class="number">26</span>:</span><br><span class="line">                dp[i] += dp[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-91-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            String one_s = s.substring(i - <span class="number">1</span>, i);</span><br><span class="line">            String two_s = s.substring(i - <span class="number">2</span>, i);</span><br><span class="line">            <span class="keyword">int</span> one = Integer.parseInt(one_s);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;= one &amp;&amp; one &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">                dp[i] += dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> two = Integer.parseInt(two_s);</span><br><span class="line">            <span class="keyword">if</span> (two &gt;= <span class="number">10</span> &amp;&amp; two &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">                dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93. 复原IP地址"></a>93. 复原IP地址</h2><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p>示例:</p>
<pre>
输入: "25525511135"
输出: ["255.255.11.135", "255.255.111.35"]
</pre>


<div class="tabs" id="leetcode-93"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-93-1">Python</a></li><li class="tab"><a class="#leetcode-93-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-93-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        item, res = [], []</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(s) &lt; <span class="number">4</span> <span class="keyword">or</span> <span class="built_in">len</span>(s) &gt; <span class="number">12</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        self.helper(s, item, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, s, item, res</span>):</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> <span class="built_in">len</span>(item) == <span class="number">4</span>:</span><br><span class="line">            res.append(<span class="string">&#x27;.&#x27;</span>.join(item[:]))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">            sub_s = s[:i]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(sub_s) == i <span class="keyword">and</span> self.ok(sub_s):</span><br><span class="line">                item.append(sub_s)</span><br><span class="line">                self.helper(s[i:], item, res)</span><br><span class="line">                item.pop(-<span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ok</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">1</span> <span class="keyword">and</span> s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        n = <span class="built_in">int</span>(s)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= n &lt;= <span class="number">255</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-93-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span> || n &gt; <span class="number">12</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; item = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(s, <span class="number">0</span>, item, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span> idx, List&lt;String&gt; item, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;String&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            tmp.addAll(item);</span><br><span class="line">            res.add(String.join(<span class="string">&quot;.&quot;</span>, tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.length() &lt; i) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String substr = s.substring(<span class="number">0</span>, i);</span><br><span class="line">            <span class="keyword">if</span> (isOK(substr)) &#123;</span><br><span class="line">                item.add(substr);</span><br><span class="line">                helper(s.substring(i), idx + <span class="number">1</span>, item, res);</span><br><span class="line">                item.remove(item.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOK</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span> || s.length() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &gt; <span class="number">1</span> &amp;&amp; s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(s);</span><br><span class="line">        <span class="keyword">return</span> n &gt;= <span class="number">0</span> &amp;&amp; n &lt;= <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="316-去除重复字母-n"><a href="#316-去除重复字母-n" class="headerlink" title="316. 去除重复字母 [n]"></a>316. 去除重复字母 [n]</h2><p>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p>
<p>示例 1：</p>
<pre>
输入：s = "bcabc"
输出："abc"
</pre>
<p>示例 2：</p>
<pre>
输入：s = "cbacdcbc"
输出："acdb"
</pre>

<p>提示：</p>
<ul>
<li>1 &lt;= s.length &lt;= 10^4</li>
<li>s 由小写英文字母组成</li>
</ul>
<div class="tabs" id="leetcode-316"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-316-1">Python</a></li><li class="tab"><a class="#leetcode-316-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-316-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicateLetters</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stk = []</span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        m = &#123;c: i <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s)&#125;</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">while</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>] &gt; c <span class="keyword">and</span> m[stk[-<span class="number">1</span>]] &gt; i:</span><br><span class="line">                    rm_c = stk.pop(-<span class="number">1</span>)</span><br><span class="line">                    seen.discard(rm_c)</span><br><span class="line">                seen.add(c)</span><br><span class="line">                stk.append(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stk)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-316-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stk = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Set&lt;Character&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            m.put(s.charAt(i), i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!seen.contains(c)) &#123;</span><br><span class="line">                <span class="keyword">while</span> (stk.size() &gt; <span class="number">0</span> &amp;&amp; stk.peek() &gt; c &amp;&amp; m.get(stk.peek()) &gt; i) &#123;</span><br><span class="line">                    <span class="keyword">char</span> rm_c = stk.pop().charValue();</span><br><span class="line">                    seen.remove(rm_c);</span><br><span class="line">                &#125;</span><br><span class="line">                seen.add(c);</span><br><span class="line">                stk.add(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(stk.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stk.size(); i++) &#123;</span><br><span class="line">            res.append(stk.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="402-移掉K位数字"><a href="#402-移掉K位数字" class="headerlink" title="402. 移掉K位数字"></a>402. 移掉K位数字</h2><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p>
<p>注意:</p>
<ul>
<li>num 的长度小于 10002 且 ≥ k。</li>
<li>num 不会包含任何前导零。</li>
</ul>
<p>示例 1 :</p>
<pre>
输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
</pre>
<p>示例 2 :</p>
<pre>
输入: num = "10200", k = 1
输出: "200"
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
</pre>
<p>示例 3 :</p>
<pre>
输入: num = "10", k = 2
输出: "0"
解释: 从原数字移除所有的数字，剩余为空就是0。
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeKdigits</span>(<span class="params">self, num, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num: str</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> num:</span><br><span class="line">            <span class="keyword">while</span> k <span class="keyword">and</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>] &gt; c:</span><br><span class="line">                stk.pop(-<span class="number">1</span>)</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            stk.append(c)</span><br><span class="line">        <span class="keyword">while</span> k:</span><br><span class="line">            stk.pop(-<span class="number">1</span>)</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stk:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(stk)))</span><br></pre></td></tr></table></figure>

<h2 id="424-替换后的最长重复字符-n"><a href="#424-替换后的最长重复字符-n" class="headerlink" title="424. 替换后的最长重复字符[n]"></a>424. 替换后的最长重复字符[n]</h2><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p>
<p>注意:</p>
<ul>
<li>字符串长度 和 k 不会超过 104。</li>
</ul>
<p>示例 1:</p>
<pre>
输入:
s = "ABAB", k = 2
输出:
4
解释:
用两个'A'替换为两个'B',反之亦然。
</pre>
<p>示例 2:</p>
<pre>
输入:
s = "AABABBA", k = 1
输出:
4
解释:
将中间的一个'A'替换为'B',字符串变为 "AABBBBA"。
子串 "BBBB" 有最长重复字母, 答案为 4。
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">characterReplacement</span>(<span class="params">self, s, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        start, end, max_freq, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> end &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            m[s[end]] = <span class="number">1</span> <span class="keyword">if</span> s[end] <span class="keyword">not</span> <span class="keyword">in</span> m <span class="keyword">else</span> m[s[end]] + <span class="number">1</span></span><br><span class="line">            max_freq = <span class="built_in">max</span>(max_freq, m[s[end]])</span><br><span class="line">            <span class="keyword">if</span> end - start + <span class="number">1</span> - max_freq &gt; k:</span><br><span class="line">                m[s[start]] -= <span class="number">1</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, end - start + <span class="number">1</span>)</span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h2 id="556-Next-Greater-Element-III-n"><a href="#556-Next-Greater-Element-III-n" class="headerlink" title="556. Next Greater Element III [n]"></a>556. Next Greater Element III [n]</h2><p>给定一个32位正整数 n，你需要找到最小的32位整数，其与 n 中存在的位数完全相同，并且其值大于n。如果不存在这样的32位整数，则返回-1。</p>
<p>示例 1:</p>
<pre>
输入: 12
输出: 21
</pre>
<p>示例 2:</p>
<pre>
输入: 21
输出: -1
</pre>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        max_val = (<span class="number">1</span> &lt;&lt; <span class="number">32</span>) - <span class="number">1</span></span><br><span class="line">        nums = [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>(n)]</span><br><span class="line">        i = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[i - <span class="number">1</span>] &lt; nums[i]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        x = nums[i - <span class="number">1</span>]</span><br><span class="line">        smallest = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i + <span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; x <span class="keyword">and</span> nums[j] &lt; nums[smallest]:</span><br><span class="line">                smallest = j</span><br><span class="line">        nums[i - <span class="number">1</span>], nums[smallest] = nums[smallest], nums[i - <span class="number">1</span>]</span><br><span class="line">        left = nums[:i]</span><br><span class="line">        right = <span class="built_in">sorted</span>(nums[i:])</span><br><span class="line">        nums = left + right</span><br><span class="line">        v = <span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> nums]))</span><br><span class="line">        <span class="keyword">return</span> v <span class="keyword">if</span> v &lt; max_val <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="583-两个字符串的删除操作-n"><a href="#583-两个字符串的删除操作-n" class="headerlink" title="583. 两个字符串的删除操作 [n]"></a>583. 两个字符串的删除操作 [n]</h2><p>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p>
<p>示例 1:</p>
<pre>
输入: "sea", "eat"
输出: 2
解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"
</pre>
<p>说明:</p>
<ul>
<li>给定单词的长度不超过500。</li>
<li>给定单词中的字符只含有小写字母。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, word1, word2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type word1: str</span></span><br><span class="line"><span class="string">        :type word2: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        len1, len2 = <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(len2 + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(len1 + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len1 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(len2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">        lcs = dp[len1][len2]</span><br><span class="line">        <span class="keyword">return</span> len1 + len2 - <span class="number">2</span> * lcs</span><br></pre></td></tr></table></figure>

<h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a>647. 回文子串</h2><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。</p>
<p>示例 1:</p>
<pre>
输入: "abc"
输出: 3
解释: 三个回文子串: "a", "b", "c".
</pre>
<p>示例 2:</p>
<pre>
输入: "aaa"
输出: 6
说明: 6个回文子串: "a", "a", "a", "aa", "aa", "aaa".
</pre>
<p>注意:</p>
<ul>
<li>输入的字符串长度不会超过1000。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            self.helper(s, i, i)</span><br><span class="line">            self.helper(s, i, i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, s, left, right</span>):</span></span><br><span class="line">        <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">            self.res += <span class="number">1</span></span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="678-有效的括号字符串-n"><a href="#678-有效的括号字符串-n" class="headerlink" title="678. 有效的括号字符串 [n]"></a>678. 有效的括号字符串 [n]</h2><p>给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p>
<ul>
<li>任何左括号 ( 必须有相应的右括号 )。</li>
<li>任何右括号 ) 必须有相应的左括号 ( 。</li>
<li>左括号 ( 必须在对应的右括号之前 )。</li>
<li>* 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。</li>
<li>一个空字符串也被视为有效字符串。</li>
</ul>
<p>示例 1:</p>
<pre>
输入: "()"
输出: True
</pre>
<p>示例 2:</p>
<pre>
输入: "(*)"
输出: True
</pre>
<p>示例 3:</p>
<pre>
输入: "(*))"
输出: True
</pre>
<p>注意:</p>
<ul>
<li>字符串大小将在 [1，100] 范围内。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkValidString</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        low, high = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                low, high = low +<span class="number">1</span>, high + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> low &gt; <span class="number">0</span>:</span><br><span class="line">                    low -= <span class="number">1</span></span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> low &gt; <span class="number">0</span>:</span><br><span class="line">                    low -= <span class="number">1</span></span><br><span class="line">                high += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> high &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> low == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="767-重构字符串"><a href="#767-重构字符串" class="headerlink" title="767. 重构字符串"></a>767. 重构字符串</h2><p>给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。</p>
<p>若可行，输出任意可行的结果。若不可行，返回空字符串。</p>
<p>示例 1:</p>
<pre>
输入: S = "aab"
输出: "aba"
</pre>
<p>示例 2:</p>
<pre>
输入: S = "aaab"
输出: ""
</pre>
<p>注意:</p>
<ul>
<li>S 只包含小写字母并且长度在[1, 500]区间内。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorganizeString</span>(<span class="params">self, S</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        char_cnt = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">26</span>)]</span><br><span class="line">        max_char = <span class="literal">None</span></span><br><span class="line">        i_a = <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">            i = <span class="built_in">ord</span>(c) - i_a</span><br><span class="line">            char_cnt[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> max_char <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                max_char = c</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = <span class="built_in">ord</span>(max_char) - i_a</span><br><span class="line">                <span class="keyword">if</span> char_cnt[i] &gt; char_cnt[j]:</span><br><span class="line">                    max_char = c</span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span> * char_cnt[<span class="built_in">ord</span>(max_char) - i_a] -<span class="number">1</span> &gt; <span class="built_in">len</span>(S):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        res = [<span class="string">&#x27;&#x27;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="built_in">len</span>(S))]</span><br><span class="line">        i_max_char = <span class="built_in">ord</span>(max_char) - i_a</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange (char_cnt[i_max_char]):</span><br><span class="line">            res[i] = max_char</span><br><span class="line">            i += <span class="number">2</span></span><br><span class="line">        char_cnt[i_max_char] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">26</span>):</span><br><span class="line">            <span class="keyword">if</span> char_cnt[j] &gt; <span class="number">0</span>:</span><br><span class="line">                c = <span class="built_in">chr</span>(j + i_a)</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> xrange(char_cnt[j]):</span><br><span class="line">                    <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(S):</span><br><span class="line">                        i = <span class="number">1</span></span><br><span class="line">                    res[i] = c</span><br><span class="line">                    i += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(res)</span><br></pre></td></tr></table></figure>

<h2 id="856-括号的分数"><a href="#856-括号的分数" class="headerlink" title="856. 括号的分数"></a>856. 括号的分数</h2><p>给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：</p>
<p>() 得 1 分。<br>AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。<br>(A) 得 2 * A 分，其中 A 是平衡括号字符串。</p>
<p>示例 1：</p>
<pre>
输入： "()"
输出： 1
</pre>
<p>示例 2：</p>
<pre>
输入： "(())"
输出： 2
</pre>
<p>示例 3：</p>
<pre>
输入： "()()"
输出： 2
</pre>
<p>示例 4：</p>
<pre>
输入： "(()(()))"
输出： 6
</pre>
<p>提示：</p>
<ul>
<li>S 是平衡括号字符串，且只含有 ( 和 ) 。</li>
<li>2 &lt;= S.length &lt;= 50</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scoreOfParentheses</span>(<span class="params">self, S</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stk.append(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> stk[-<span class="number">1</span>] != -<span class="number">1</span>:</span><br><span class="line">                    cnt += stk[-<span class="number">1</span>]</span><br><span class="line">                    stk.pop(-<span class="number">1</span>)</span><br><span class="line">                stk.pop(-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">                    stk.append(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stk.append(<span class="number">2</span> * cnt)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(stk)</span><br></pre></td></tr></table></figure>

<h2 id="890-查找和替换模式"><a href="#890-查找和替换模式" class="headerlink" title="890. 查找和替换模式"></a>890. 查找和替换模式</h2><p>你有一个单词列表 words 和一个模式  pattern，你想知道 words 中的哪些单词与模式匹配。</p>
<p>如果存在字母的排列 p ，使得将模式中的每个字母 x 替换为 p(x) 之后，我们就得到了所需的单词，那么单词与模式是匹配的。</p>
<p>（回想一下，字母的排列是从字母到字母的双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母。）</p>
<p>返回 words 中与给定模式匹配的单词列表。</p>
<p>你可以按任何顺序返回答案。</p>
<p>示例：</p>
<pre>
输入：words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb"
输出：["mee","aqq"]
解释：
"mee" 与模式匹配，因为存在排列 {a -> m, b -> e, ...}。
"ccc" 与模式不匹配，因为 {a -> c, b -> c, ...} 不是排列。
因为 a 和 b 映射到同一个字母。
</pre>
<p>提示：</p>
<ul>
<li>1 &lt;= words.length &lt;= 50</li>
<li>1 &lt;= pattern.length = words[i].length &lt;= 20</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAndReplacePattern</span>(<span class="params">self, words, pattern</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :type pattern: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        p = self.helper(pattern)</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            pw = self.helper(w)</span><br><span class="line">            <span class="keyword">if</span> pw == p:</span><br><span class="line">                res.append(w)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, pattern</span>):</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> pattern:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> m:</span><br><span class="line">                res.append(m[c])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m[c] = <span class="built_in">len</span>(m) + <span class="number">1</span></span><br><span class="line">                res.append(m[c])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> res])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode之数组(中等)</title>
    <url>/posts/3239008047.html</url>
    <content><![CDATA[<p>数组(中等)的题目汇总在此了，欢迎大家光顾。</p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="/images/leetcode/array2.png" style="width:600px;height:300px;"/></div></div>

<a id="more"></a>

<h2 id="31-下一个排列-n"><a href="#31-下一个排列-n" class="headerlink" title="31. 下一个排列 [n]"></a>31. 下一个排列 [n]</h2><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须原地修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p>
<pre>
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        i = n - <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i + <span class="number">1</span>] &lt;= nums[i]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            j = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> nums[j] &lt;= nums[i]:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            nums[i], nums[j] =  nums[j], nums[i]</span><br><span class="line">        self.helper(nums, i + <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, nums, i, j</span>):</span></span><br><span class="line">        s, e = i, j</span><br><span class="line">        <span class="keyword">while</span> s &lt; e:</span><br><span class="line">            nums[s], nums[e] = nums[e], nums[s]</span><br><span class="line">            s += <span class="number">1</span></span><br><span class="line">            e -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a>40. 组合总和 II</h2><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>说明：</p>
<ul>
<li>所有数字（包括目标数）都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
<p>示例 1:</p>
<pre>
输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
</pre>
<p>示例 2:</p>
<pre>
输入: candidates = [2,5,2,1,2], target = 5,
所求解集为:
[
  [1,2,2],
  [5]
]
</pre>

<div class="tabs" id="leetcode-40"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-40-1">Python</a></li><li class="tab"><a class="#leetcode-40-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-40-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span>(<span class="params">self, candidates, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        candidates = <span class="built_in">sorted</span>(candidates)</span><br><span class="line">        item, res = [], []</span><br><span class="line">        self.helper(candidates, target, <span class="number">0</span>, item, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, candidates, target, idx, item, res</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(item) == target:</span><br><span class="line">            res.append(item[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(idx, <span class="built_in">len</span>(candidates)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; idx <span class="keyword">and</span> candidates[i] == candidates[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(item) + candidates[i] &gt; target:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            item.append(candidates[i])</span><br><span class="line">            self.helper(candidates, target, i + <span class="number">1</span>, item, res)</span><br><span class="line">            item.pop(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-40-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; item = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(candidates, <span class="number">0</span>, target, item, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> idx, <span class="keyword">int</span> target, List&lt;Integer&gt; item, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            tmp.addAll(item);</span><br><span class="line">            res.add(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; idx &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            item.add(candidates[i]);</span><br><span class="line">            helper(candidates, i + <span class="number">1</span>, target - candidates[i], item, res);</span><br><span class="line">            item.remove(item.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="55-跳跃游戏-n"><a href="#55-跳跃游戏-n" class="headerlink" title="55. 跳跃游戏 [n]"></a>55. 跳跃游戏 [n]</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<p>示例 1:</p>
<pre>
输入: [2,3,1,1,4]
输出: true
解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。
</pre>
<p>示例 2:</p>
<pre>
输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        last_pos = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(nums) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i + nums[i] &gt;= last_pos:</span><br><span class="line">                last_pos = i</span><br><span class="line">        <span class="keyword">return</span> last_pos == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a>73. 矩阵置零</h2><p>给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</p>
<p>示例 1:</p>
<pre>
输入: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
</pre>
<p>示例 2:</p>
<pre>
输入: 
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
输出: 
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
</pre>
<p>进阶:</p>
<ul>
<li>一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。</li>
<li>一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。</li>
<li>你能想出一个常数空间的解决方案吗？</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span>(<span class="params">self, matrix</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        rows = <span class="built_in">len</span>(matrix)</span><br><span class="line">        cols = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        row0_flag = <span class="literal">False</span></span><br><span class="line">        col0_flag = <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 找第一行是否有0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                row0_flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 第一列是否有0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                col0_flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 把第一行或者第一列作为 标志位</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cols):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 置0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cols):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">or</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> row0_flag:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> col0_flag:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a>81. 搜索旋转排序数组 II</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p>
<p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p>
<p>示例 1:</p>
<pre>
输入: nums = [2,5,6,0,0,1,2], target = 0
输出: true
</pre>
<p>示例 2:</p>
<pre>
输入: nums = [2,5,6,0,0,1,2], target = 3
输出: false
</pre>
<p>进阶:</p>
<ul>
<li>这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。</li>
<li>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</li>
</ul>
<div class="tabs" id="leetcode-81"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-81-1">Python</a></li><li class="tab"><a class="#leetcode-81-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-81-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[left]:</span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; nums[left]:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-81-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[left]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[left]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a>90. 子集 II</h2><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例:</p>
<pre>
输入: [1,2,2]
输出:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
</pre>

<div class="tabs" id="leetcode-90"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-90-1">Python</a></li><li class="tab"><a class="#leetcode-90-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-90-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        item, res = [], []</span><br><span class="line">        self.helper(nums, <span class="number">0</span>, item, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, nums, idx, item, res</span>):</span></span><br><span class="line">        res.append(item[:])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(idx, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; idx <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            item.append(nums[i])</span><br><span class="line">            self.helper(nums, i + <span class="number">1</span>, item, res)</span><br><span class="line">            item.pop(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-90-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;Integer&gt; item = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(nums, <span class="number">0</span>, item, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> idx, List&lt;Integer&gt; item, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tmp.addAll(item);</span><br><span class="line">        res.add(tmp);</span><br><span class="line">        <span class="keyword">if</span> (idx == nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; idx &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            item.add(nums[i]);</span><br><span class="line">            helper(nums, i + <span class="number">1</span>, item, res);</span><br><span class="line">            item.remove(item.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a>153. 寻找旋转排序数组中的最小值</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>请找出其中最小的元素。</p>
<p>你可以假设数组中不存在重复元素。</p>
<p>示例 1:</p>
<pre>
输入: [3,4,5,1,2]
输出: 1
</pre>
<p>示例 2:</p>
<pre>
输入: [4,5,6,7,0,1,2]
输出: 0
</pre>

<div class="tabs" id="leetcode-153"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-153-1">Python</a></li><li class="tab"><a class="#leetcode-153-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-153-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-153-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="287-寻找重复数-n"><a href="#287-寻找重复数-n" class="headerlink" title="287. 寻找重复数 [n]"></a>287. 寻找重复数 [n]</h2><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<p>示例 1:</p>
<pre>
输入: [1,3,4,2,2]
输出: 2
</pre>
<p>示例 2:</p>
<pre>
输入: [3,1,3,4,2]
输出: 3
</pre>
<p>说明：</p>
<ul>
<li>不能更改原数组（假设数组是只读的）。</li>
<li>只能使用额外的 O(1) 的空间。</li>
<li>时间复杂度小于 O(n2) 。</li>
<li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li>
</ul>
<div class="tabs" id="leetcode-287"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-287-1">Python</a></li><li class="tab"><a class="#leetcode-287-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-287-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        fast, slow = nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            fast = nums[nums[fast]]</span><br><span class="line">            slow = nums[slow]</span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        slow = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            slow = nums[slow]</span><br><span class="line">            fast = nums[fast]</span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-287-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = nums[<span class="number">0</span>], fast = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="560-和为K的子数组-n"><a href="#560-和为K的子数组-n" class="headerlink" title="560. 和为K的子数组 [n]"></a>560. 和为K的子数组 [n]</h2><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p>
<p>示例 1 :</p>
<pre>
输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
</pre>
<p>说明 :</p>
<ul>
<li>数组的长度为 [1, 20,000]。</li>
<li>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res, cur_sum, m = <span class="number">0</span>, <span class="number">0</span>, &#123;<span class="number">0</span>:<span class="number">1</span>&#125;</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            cur_sum += nums[i]</span><br><span class="line">            <span class="keyword">if</span> cur_sum - k <span class="keyword">in</span> m:</span><br><span class="line">                res += m[cur_sum - k]</span><br><span class="line">            <span class="keyword">if</span> cur_sum <span class="keyword">in</span> m:</span><br><span class="line">                m[cur_sum] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m[cur_sum] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="670-最大交换"><a href="#670-最大交换" class="headerlink" title="670. 最大交换"></a>670. 最大交换</h2><p>给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。</p>
<p>示例 1 :</p>
<pre>
输入: 2736
输出: 7236
解释: 交换数字2和数字7。
</pre>
<p>示例 2 :</p>
<pre>
输入: 9973
输出: 9973
解释: 不需要交换。
</pre>
<p>注意:</p>
<ul>
<li>给定数字的范围是 [0, 108]</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumSwap</span>(<span class="params">self, num</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums = [<span class="built_in">int</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">str</span>(num)]</span><br><span class="line">        sorted_nums = <span class="built_in">sorted</span>(nums[:], reverse=<span class="literal">True</span>)</span><br><span class="line">        i, n = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="keyword">if</span> nums[i] != sorted_nums[i]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i == n:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        j = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt; i <span class="keyword">and</span> nums[j] != sorted_nums[i]:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join([<span class="built_in">str</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> nums]))</span><br></pre></td></tr></table></figure>

<h2 id="713-乘积小于K的子数组"><a href="#713-乘积小于K的子数组" class="headerlink" title="713. 乘积小于K的子数组"></a>713. 乘积小于K的子数组</h2><p>给定一个正整数数组 nums。</p>
<p>找出该数组内乘积小于 k 的连续的子数组的个数。</p>
<p>示例 1:</p>
<pre>
输入: nums = [10,5,2,6], k = 100
输出: 8
解释: 8个乘积小于100的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于100的子数组。
</pre>
<p>说明:</p>
<ul>
<li>0 &lt; nums.length &lt;= 50000</li>
<li>0 &lt; nums[i] &lt; 1000</li>
<li>0 &lt;= k &lt; 10^6</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubarrayProductLessThanK</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        left, right, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        cur_val = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; n:</span><br><span class="line">            cur_val *= nums[right]</span><br><span class="line">            <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> cur_val &gt;= k:</span><br><span class="line">                cur_val /= nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            res += (right - left + <span class="number">1</span>)</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="714-买卖股票的最佳时机含手续费-n"><a href="#714-买卖股票的最佳时机含手续费-n" class="headerlink" title="714. 买卖股票的最佳时机含手续费 [n]"></a>714. 买卖股票的最佳时机含手续费 [n]</h2><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>示例 1:</p>
<pre>
输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
</pre>
<p>注意:</p>
<ul>
<li>0 &lt; prices.length &lt;= 50000.</li>
<li>0 &lt; prices[i] &lt; 50000.</li>
<li>0 &lt;= fee &lt; 50000.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices, fee</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :type fee: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cash, hold = <span class="number">0</span>, -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            cash = <span class="built_in">max</span>(cash, hold + prices[i] - fee)</span><br><span class="line">            hold = <span class="built_in">max</span>(hold, cash - prices[i])</span><br><span class="line">        <span class="keyword">return</span> cash</span><br></pre></td></tr></table></figure>


<h2 id="718-最长重复子数组-n"><a href="#718-最长重复子数组-n" class="headerlink" title="718. 最长重复子数组 [n]"></a>718. 最长重复子数组 [n]</h2><p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p>
<p>示例 1:</p>
<pre>
输入:
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出: 3
解释: 
长度最长的公共子数组是 [3, 2, 1]。
</pre>
<p>说明:</p>
<ul>
<li>1 &lt;= len(A), len(B) &lt;= 1000</li>
<li>0 &lt;= A[i], B[i] &lt; 100</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLength</span>(<span class="params">self, A, B</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type B: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(A), <span class="built_in">len</span>(B)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(m + <span class="number">1</span>)]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]:</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = <span class="number">0</span></span><br><span class="line">                res = <span class="built_in">max</span>(res, dp[i][j])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="795-区间子数组个数"><a href="#795-区间子数组个数" class="headerlink" title="795. 区间子数组个数"></a>795. 区间子数组个数</h2><p>给定一个元素都是正整数的数组A ，正整数 L 以及 R (L &lt;= R)。</p>
<p>求连续、非空且其中最大元素满足大于等于L 小于等于R的子数组个数。</p>
<p>例如 :</p>
<pre>
输入: 
A = [2, 1, 4, 3]
L = 2
R = 3
输出: 3
解释: 满足条件的子数组: [2], [2, 1], [3].
</pre>
<p>注意:</p>
<ul>
<li>L, R  和 A[i] 都是整数，范围在 [0, 10^9]。</li>
<li>数组 A 的长度范围在[1, 50000]。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubarrayBoundedMax</span>(<span class="params">self, A, L, R</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type L: int</span></span><br><span class="line"><span class="string">        :type R: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i, j, n = <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(A)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; n:</span><br><span class="line">            <span class="keyword">if</span> L &lt;= A[j] &lt;= R:</span><br><span class="line">                ans += j - i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> A[j] &lt; L:</span><br><span class="line">                t = j - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> t &gt;= i <span class="keyword">and</span> A[t] &lt; L:</span><br><span class="line">                    t -= <span class="number">1</span></span><br><span class="line">                ans += t - i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i = j + <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="907-子数组的最小值之和-n"><a href="#907-子数组的最小值之和-n" class="headerlink" title="907. 子数组的最小值之和 [n]"></a>907. 子数组的最小值之和 [n]</h2><p>给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。</p>
<p>由于答案可能很大，因此返回答案模 10^9 + 7。</p>
<p>示例：</p>
<pre>
输入：[3,1,2,4]
输出：17
解释：
子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 
最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。
</pre>
<p>提示：</p>
<ul>
<li>1 &lt;= A &lt;= 30000</li>
<li>1 &lt;= A[i] &lt;= 30000</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumSubarrayMins</span>(<span class="params">self, A</span>):</span></span><br><span class="line">        MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        N = <span class="built_in">len</span>(A)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># prev has i* - 1 in increasing order of A[i* - 1]</span></span><br><span class="line">        <span class="comment"># where i* is the answer to query j</span></span><br><span class="line">        stack = []</span><br><span class="line">        prev = [<span class="literal">None</span>] * N</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(N):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> A[i] &lt;= A[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            prev[i] = stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># next has k* + 1 in increasing order of A[k* + 1]</span></span><br><span class="line">        <span class="comment"># where k* is the answer to query j</span></span><br><span class="line">        stack = []</span><br><span class="line">        next_ = [<span class="literal">None</span>] * N</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> xrange(N-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> A[k] &lt; A[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            next_[k] = stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> N</span><br><span class="line">            stack.append(k)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Use prev/next array to count answer</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>((i - prev[i]) * (next_[i] - i) * A[i]</span><br><span class="line">                   <span class="keyword">for</span> i <span class="keyword">in</span> xrange(N)) % MOD</span><br></pre></td></tr></table></figure>


<h2 id="915-分割数组-n"><a href="#915-分割数组-n" class="headerlink" title="915. 分割数组 [n]"></a>915. 分割数组 [n]</h2><p>给定一个数组 A，将其划分为两个不相交（没有公共元素）的连续子数组 left 和 right， 使得：</p>
<ul>
<li>left 中的每个元素都小于或等于 right 中的每个元素。</li>
<li>left 和 right 都是非空的。</li>
<li>left 要尽可能小。</li>
</ul>
<p>在完成这样的分组后返回 left 的长度。可以保证存在这样的划分方法。</p>
<p>示例 1：</p>
<pre>
输入：[5,0,3,8,6]
输出：3
解释：left = [5,0,3]，right = [8,6]
</pre>
<p>示例 2：</p>
<pre>
输入：[1,1,1,0,6,12]
输出：4
解释：left = [1,1,1,0]，right = [6,12]
</pre>

<p>提示：</p>
<ul>
<li>2 &lt;= A.length &lt;= 30000</li>
<li>0 &lt;= A[i] &lt;= 10^6</li>
<li>可以保证至少有一种方法能够按题目所描述的那样对 A 进行划分。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionDisjoint</span>(<span class="params">self, A</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(A)</span><br><span class="line">        max_left, min_right = [<span class="number">0</span>] * n, [<span class="number">0</span>] * n</span><br><span class="line">        </span><br><span class="line">        m = A[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            m = <span class="built_in">max</span>(m, A[i])</span><br><span class="line">            max_left[i] = m</span><br><span class="line">        </span><br><span class="line">        m = A[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            m = <span class="built_in">min</span>(m, A[i])</span><br><span class="line">            min_right[i] = m</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> max_left[i - <span class="number">1</span>] &lt;= min_right[i]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>

<h2 id="926-将字符串翻转到单调递增-n"><a href="#926-将字符串翻转到单调递增-n" class="headerlink" title="926. 将字符串翻转到单调递增 [n]"></a>926. 将字符串翻转到单调递增 [n]</h2><p>如果一个由 ‘0’ 和 ‘1’ 组成的字符串，是以一些 ‘0’（可能没有 ‘0’）后面跟着一些 ‘1’（也可能没有 ‘1’）的形式组成的，那么该字符串是单调递增的。</p>
<p>我们给出一个由字符 ‘0’ 和 ‘1’ 组成的字符串 S，我们可以将任何 ‘0’ 翻转为 ‘1’ 或者将 ‘1’ 翻转为 ‘0’。</p>
<p>返回使 S 单调递增的最小翻转次数。</p>
<p>示例 1：</p>
<pre>
输入："00110"
输出：1
解释：我们翻转最后一位得到 00111.
</pre>
<p>示例 2：</p>
<pre>
输入："010110"
输出：2
解释：我们翻转得到 011111，或者是 000111。
</pre>
<p>示例 3：</p>
<pre>
输入："00011000"
输出：2
解释：我们翻转得到 00000000。
</pre>

<p>提示：</p>
<ul>
<li>1 &lt;= S.length &lt;= 20000</li>
<li>S 中只包含字符 ‘0’ 和 ‘1’</li>
</ul>
<div class="tabs" id="leetcode-926"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-926-1">Python优化前</a></li><li class="tab"><a class="#leetcode-926-2">Python优化后</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-926-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minFlipsMonoIncr</span>(<span class="params">self, S</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(S)</span><br><span class="line">        zeros = [n <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        ones = [n <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                zeros[i] = <span class="built_in">int</span>(S[i] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                ones[i] = <span class="built_in">int</span>(S[i] != <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            zeros[i] = zeros[i - <span class="number">1</span>] + <span class="built_in">int</span>(S[i] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            ones[i] = <span class="built_in">min</span>(ones[i - <span class="number">1</span>], zeros[i - <span class="number">1</span>]) + <span class="built_in">int</span>(S[i] != <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(zeros[n - <span class="number">1</span>], ones[n - <span class="number">1</span>])</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-926-2"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minFlipsMonoIncr</span>(<span class="params">self, S</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        zero, one = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">            last_zero = zero</span><br><span class="line">            zero = last_zero + <span class="built_in">int</span>(c != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            one = <span class="built_in">min</span>(last_zero, one) + <span class="built_in">int</span>(c != <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(zero, one)</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="945-使数组唯一的最小增量"><a href="#945-使数组唯一的最小增量" class="headerlink" title="945. 使数组唯一的最小增量"></a>945. 使数组唯一的最小增量</h2><p>给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。</p>
<p>返回使 A 中的每个值都是唯一的最少操作次数。</p>
<p>示例 1:</p>
<pre>
输入：[1,2,2]
输出：1
解释：经过一次 move 操作，数组将变为 [1, 2, 3]。
</pre>
<p>示例 2:</p>
<pre>
输入：[3,2,1,2,1,7]
输出：6
解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。
可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。
</pre>
<p>提示：</p>
<ul>
<li>0 &lt;= A.length &lt;= 40000</li>
<li>0 &lt;= A[i] &lt; 40000</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minIncrementForUnique</span>(<span class="params">self, A</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        A = <span class="built_in">sorted</span>(A)</span><br><span class="line">        res, step = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> A:</span><br><span class="line">            res += <span class="built_in">max</span>(n, step) - n</span><br><span class="line">            step = <span class="built_in">max</span>(n, step) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="962-最大宽度坡-n"><a href="#962-最大宽度坡-n" class="headerlink" title="962. 最大宽度坡 [n]"></a>962. 最大宽度坡 [n]</h2><p>给定一个整数数组 A，坡是元组 (i, j)，其中  i &lt; j 且 A[i] &lt;= A[j]。这样的坡的宽度为 j - i。</p>
<p>找出 A 中的坡的最大宽度，如果不存在，返回 0 。</p>
<p>示例 1：</p>
<pre>
输入：[6,0,8,2,1,5]
输出：4
解释：
最大宽度的坡为 (i, j) = (1, 5): A[1] = 0 且 A[5] = 5.
</pre>
<p>示例 2：</p>
<pre>
输入：[9,8,1,0,1,9,4,0,4,1]
输出：7
解释：
最大宽度的坡为 (i, j) = (2, 9): A[2] = 1 且 A[9] = 1.
</pre>

<p>提示：</p>
<ul>
<li>2 &lt;= A.length &lt;= 50000</li>
<li>0 &lt;= A[i] &lt;= 50000</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxWidthRamp</span>(<span class="params">self, A</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        stk = []</span><br><span class="line">        n = <span class="built_in">len</span>(A)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stk <span class="keyword">or</span> A[stk[-<span class="number">1</span>]] &gt; A[i]:</span><br><span class="line">                stk.append(i)</span><br><span class="line">        i = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; res:</span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> A[stk[-<span class="number">1</span>]] &lt;= A[i]:</span><br><span class="line">                j = stk[-<span class="number">1</span>]</span><br><span class="line">                res = <span class="built_in">max</span>(res, i - j)</span><br><span class="line">                stk.pop(-<span class="number">1</span>)</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode之数组(简单)</title>
    <url>/posts/3027083408.html</url>
    <content><![CDATA[<p>数组(简单)的题目汇总在此了，欢迎大家光顾。</p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="/images/leetcode/array1.png" style="width:600px;height:300px;"/></div></div>

<a id="more"></a>

<h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<pre>
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
</pre>

<div class="tabs" id="leetcode-53"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-53-1">Python</a></li><li class="tab"><a class="#leetcode-53-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-53-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="built_in">len</span>(nums))]</span><br><span class="line">        res = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>] + nums[i], nums[i])</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-53-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            res = max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="118-杨辉三角-n"><a href="#118-杨辉三角-n" class="headerlink" title="118. 杨辉三角 [n]"></a>118. 杨辉三角 [n]</h2><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p>
<p>示例:</p>
<pre>
输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
</pre>

<div class="tabs" id="leetcode-118"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-118-1">Python</a></li><li class="tab"><a class="#leetcode-118-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-118-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span>(<span class="params">self, numRows</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type numRows: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        item = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(numRows):</span><br><span class="line">            item.insert(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="built_in">len</span>(item) - <span class="number">1</span>):</span><br><span class="line">                item[j] = item[j] + item[j + <span class="number">1</span>]</span><br><span class="line">            res.append(item[:])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-118-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            tmp.insert(tmp.begin(), <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; tmp.size() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                tmp[j] = tmp[j] + tmp[j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; row = tmp;</span><br><span class="line">            res.push_back(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="119-杨辉三角-II"><a href="#119-杨辉三角-II" class="headerlink" title="119. 杨辉三角 II"></a>119. 杨辉三角 II</h2><p>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。</p>
<p>示例:</p>
<pre>
输入: 3
输出: [1,3,3,1]
</pre>

<div class="tabs" id="leetcode-119"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-119-1">Python</a></li><li class="tab"><a class="#leetcode-119-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-119-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span>(<span class="params">self, rowIndex</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type rowIndex: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        item = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(rowIndex + <span class="number">1</span>):</span><br><span class="line">            item.insert(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="built_in">len</span>(item) - <span class="number">1</span>):</span><br><span class="line">                item[j] = item[j] + item[j + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-119-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowIndex + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            res.insert(res.begin(), <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; res.size() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                res[j] = res[j] + res[j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<pre>
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</pre>
<p>示例 2:</p>
<pre>
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为0。
</pre>

<div class="tabs" id="leetcode-121"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-121-1">Python</a></li><li class="tab"><a class="#leetcode-121-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-121-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        min_v, max_v = <span class="number">1</span> &lt;&lt; <span class="number">32</span> -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            min_v = <span class="built_in">min</span>(min_v, price)</span><br><span class="line">            max_v = <span class="built_in">max</span>(max_v, price - min_v)</span><br><span class="line">        <span class="keyword">return</span> max_v</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-121-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_v = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = prices.cbegin(); iter != prices.cend(); iter++) &#123;</span><br><span class="line">            min_v = min(min_v, *iter);</span><br><span class="line">            max_v = max(max_v, *iter - min_v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a>122. 买卖股票的最佳时机 II</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<pre>
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
</pre>
<p>示例 2:</p>
<pre>
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
</pre>
<p>示例 3:</p>
<pre>
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</pre>

<div class="tabs" id="leetcode-122"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-122-1">Python</a></li><li class="tab"><a class="#leetcode-122-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-122-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res, i, n = <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(prices) </span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="keyword">while</span> i &lt; n - <span class="number">1</span> <span class="keyword">and</span> prices[i + <span class="number">1</span>] &lt;= prices[i]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            min_v = prices[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; n - <span class="number">1</span> <span class="keyword">and</span> prices[i + <span class="number">1</span>] &gt;= prices[i]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; n:</span><br><span class="line">                res += prices[i] - min_v</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-122-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n - <span class="number">1</span> &amp;&amp; prices[i + <span class="number">1</span>] &lt;= prices[i]) &#123;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            min_v = prices[i];</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n - <span class="number">1</span> &amp;&amp; prices[i + <span class="number">1</span>] &gt;= prices[i]) &#123;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">                res += (prices[i] - min_v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a>448. 找到所有数组中消失的数字</h2><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p>
<p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p>
<p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
<p>示例:</p>
<pre>
输入:
[4,3,2,7,8,2,3,1]

输出:
[5,6]
</pre>

<div class="tabs" id="leetcode-448"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-448-1">Python</a></li><li class="tab"><a class="#leetcode-448-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-448-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDisappearedNumbers</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> nums:</span><br><span class="line">            idx = <span class="built_in">abs</span>(v) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[idx] &gt; <span class="number">0</span>:</span><br><span class="line">                nums[idx] = -nums[idx]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                res.append(i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-448-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = <span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[idx] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[idx] = -nums[idx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res.push_back(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="532-数组中的K-diff数对"><a href="#532-数组中的K-diff数对" class="headerlink" title="532. 数组中的K-diff数对"></a>532. 数组中的K-diff数对</h2><p>给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k.</p>
<p>示例 1:</p>
<pre>
输入: [3, 1, 4, 1, 5], k = 2
输出: 2
解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。
尽管数组中有两个1，但我们只应返回不同的数对的数量。
</pre>
<p>示例 2:</p>
<pre>
输入:[1, 2, 3, 4, 5], k = 1
输出: 4
解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。
</pre>
<p>示例 3:</p>
<pre>
输入: [1, 3, 1, 5, 4], k = 0
输出: 1
解释: 数组中只有一个 0-diff 数对，(1, 1)。
</pre>
<p>注意:</p>
<ul>
<li>数对 (i, j) 和数对 (j, i) 被算作同一数对。</li>
<li>数组的长度不超过10,000。</li>
<li>所有输入的整数的范围在 [-1e7, 1e7]。</li>
</ul>
<div class="tabs" id="leetcode-532"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-532-1">Python</a></li><li class="tab"><a class="#leetcode-532-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-532-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPairs</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> nums <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> <span class="keyword">or</span> k &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> m:</span><br><span class="line">                m[v] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m[v] += <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> key, val <span class="keyword">in</span> m.iteritems():</span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> val &gt;= <span class="number">2</span>:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> key + k <span class="keyword">in</span> m:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-532-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">            m[n]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> item : m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (item.second &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    res += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m.find(item.first + k) != m.end()) &#123;</span><br><span class="line">                    res += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a>581. 最短无序连续子数组</h2><p>给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>
<p>你找到的子数组应是最短的，请输出它的长度。</p>
<p>示例 1:</p>
<pre>
输入: [2, 6, 4, 8, 10, 9, 15]
输出: 5
解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
</pre>
<p>说明 :</p>
<ul>
<li>输入的数组长度范围在 [1, 10,000]。</li>
<li>输入的数组可能包含重复元素 ，所以升序的意思是&lt;=</li>
</ul>
<div class="tabs" id="leetcode-581"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-581-1">Python</a></li><li class="tab"><a class="#leetcode-581-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-581-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findUnsortedSubarray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        sorted_nums = <span class="built_in">sorted</span>(nums[:])</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> sorted_nums[left] == nums[left]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">while</span> right &gt; left:</span><br><span class="line">            <span class="keyword">if</span> sorted_nums[right] == nums[right]:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; right:</span><br><span class="line">            <span class="keyword">return</span> right - left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-581-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sorted_nums = nums;</span><br><span class="line">        sort(sorted_nums.begin(), sorted_nums.end());</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == sorted_nums[left]) &#123;</span><br><span class="line">            left += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == sorted_nums[right]) &#123;</span><br><span class="line">            right -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="605-种花问题"><a href="#605-种花问题" class="headerlink" title="605. 种花问题"></a>605. 种花问题</h2><p>假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。</p>
<p>示例 1:</p>
<pre>
输入: flowerbed = [1,0,0,0,1], n = 1
输出: True
</pre>
<p>示例 2:</p>
<pre>
输入: flowerbed = [1,0,0,0,1], n = 2
输出: False
</pre>
<p>注意:</p>
<ul>
<li>数组内已种好的花不会违反种植规则。</li>
<li>输入的数组长度范围为 [1, 20000]。</li>
<li>n 是非负整数，且不会超过输入数组的大小。</li>
</ul>
<div class="tabs" id="leetcode-605"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-605-1">Python</a></li><li class="tab"><a class="#leetcode-605-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-605-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPlaceFlowers</span>(<span class="params">self, flowerbed, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type flowerbed: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums = [<span class="number">0</span>] + flowerbed + [<span class="number">0</span>]</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(flowerbed) + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[i - <span class="number">1</span>] == <span class="number">0</span> <span class="keyword">and</span> nums[i] == <span class="number">0</span> <span class="keyword">and</span> nums[i + <span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                i += <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt &gt;= n</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-605-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = flowerbed;</span><br><span class="line">        nums.insert(nums.begin(), <span class="number">0</span>);</span><br><span class="line">        nums.insert(nums.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; nums[i] == <span class="number">0</span> &amp;&amp; nums[i + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt += <span class="number">1</span>;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt;= n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="643-子数组最大平均数-I"><a href="#643-子数组最大平均数-I" class="headerlink" title="643. 子数组最大平均数 I"></a>643. 子数组最大平均数 I</h2><p>给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。</p>
<p>示例 1:</p>
<pre>
输入: [1,12,-5,-6,50,3], k = 4
输出: 12.75
解释: 最大平均数 (12-5-6+50)/4 = 51/4 = 12.75
</pre>
<p>注意:</p>
<ul>
<li>1 &lt;= k &lt;= n &lt;= 30,000。</li>
<li>所给数据范围 [-10,000，10,000]。</li>
</ul>
<div class="tabs" id="leetcode-643"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-643-1">Python</a></li><li class="tab"><a class="#leetcode-643-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-643-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxAverage</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="built_in">sum</span>(nums[:k])</span><br><span class="line">        sub_sum = res</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(k, <span class="built_in">len</span>(nums)):</span><br><span class="line">            sub_sum = sub_sum + nums[i] - nums[i - k]</span><br><span class="line">            res = <span class="built_in">max</span>(res, sub_sum)</span><br><span class="line">        <span class="keyword">return</span> res / (k * <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-643-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp_sum = <span class="number">0</span>, res_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            tmp_sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        res_sum = tmp_sum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            tmp_sum = tmp_sum - nums[i - k] + nums[i];</span><br><span class="line">            res_sum = max(res_sum, tmp_sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res_sum * <span class="number">1.0</span> / k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="665-非递减数列-n"><a href="#665-非递减数列-n" class="headerlink" title="665. 非递减数列 [n]"></a>665. 非递减数列 [n]</h2><p>给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。</p>
<p>我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 &lt;= i &lt; n)，满足 array[i] &lt;= array[i + 1]。</p>
<p>示例 1:</p>
<pre>
输入: [4,2,3]
输出: True
解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。
</pre>
<p>示例 2:</p>
<pre>
输入: [4,2,1]
输出: False
解释: 你不能在只改变一个元素的情况下将其变为非递减数列。
</pre>
<p>说明:  n 的范围为 [1, 10,000]。</p>
<div class="tabs" id="leetcode-665"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-665-1">Python</a></li><li class="tab"><a class="#leetcode-665-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-665-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i - <span class="number">1</span>] &gt; nums[i]:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i - <span class="number">2</span> &lt; <span class="number">0</span> <span class="keyword">or</span> nums[i - <span class="number">2</span>] &lt;= nums[i]:</span><br><span class="line">                    nums[i - <span class="number">1</span>] = nums[i]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nums[i] = nums[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= <span class="number">1</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-665-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPossibility</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &gt; nums[i]) &#123;</span><br><span class="line">                cnt += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">2</span> &lt; <span class="number">0</span> || nums[i - <span class="number">2</span>] &lt;= nums[i]) &#123;</span><br><span class="line">                    nums[i - <span class="number">1</span>] = nums[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a>674. 最长连续递增序列</h2><p>给定一个未经排序的整数数组，找到最长且连续的的递增序列。</p>
<p>示例 1:</p>
<pre>
输入: [1,3,5,4,7]
输出: 3
解释: 最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。
</pre>
<p>示例 2:</p>
<pre>
输入: [2,2,2,2,2]
输出: 1
解释: 最长连续递增序列是 [2], 长度为1。
</pre>
<p>注意：数组长度不会超过10000。</p>
<div class="tabs" id="leetcode-674"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-674-1">Python</a></li><li class="tab"><a class="#leetcode-674-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-674-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLengthOfLCIS</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        max_cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                cnt, max_cnt = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[i - <span class="number">1</span>] &lt; v:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                    max_cnt = <span class="built_in">max</span>(max_cnt, cnt)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max_cnt</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-674-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>, max_cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &lt; nums[i]) &#123;</span><br><span class="line">                cnt += <span class="number">1</span>;</span><br><span class="line">                max_cnt = max(max_cnt, cnt);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="697-数组的度-n"><a href="#697-数组的度-n" class="headerlink" title="697. 数组的度 [n]"></a>697. 数组的度 [n]</h2><p>给定一个非空且只包含非负数的整数数组nums, 数组的度的定义是指数组里任一元素出现频数的最大值。</p>
<p>你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。</p>
<p>示例 1:</p>
<pre>
输入: [1, 2, 2, 3, 1]
输出: 2
解释: 
输入数组的度是2，因为元素1和2的出现频数最大，均为2.
连续子数组里面拥有相同度的有如下所示:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
最短连续子数组[2, 2]的长度为2，所以返回2.
</pre>
<p>示例 2:</p>
<pre>
输入: [1,2,2,3,1,4,2]
输出: 6
</pre>
<p>注意:</p>
<ul>
<li>nums.length 在1到50,000区间范围内。</li>
<li>nums[i] 是一个在0到49,999范围内的整数。</li>
</ul>
<div class="tabs" id="leetcode-697"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-697-1">Python</a></li><li class="tab"><a class="#leetcode-697-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-697-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findShortestSubArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> m:</span><br><span class="line">                m[v] = [<span class="number">1</span>, i, i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m[v][<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">                m[v][<span class="number">2</span>] = i</span><br><span class="line">        res = <span class="built_in">len</span>(nums)</span><br><span class="line">        max_cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> key, item <span class="keyword">in</span> m.iteritems():</span><br><span class="line">            <span class="keyword">if</span> item[<span class="number">0</span>] &gt; max_cnt:</span><br><span class="line">                max_cnt = item[<span class="number">0</span>]</span><br><span class="line">                res = item[<span class="number">2</span>] - item[<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> item[<span class="number">0</span>] == max_cnt:</span><br><span class="line">                cur_len = item[<span class="number">2</span>] - item[<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> res &gt; cur_len:</span><br><span class="line">                    res = cur_len</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-697-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> res = n;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            m[nums[i]]++;</span><br><span class="line">            <span class="keyword">if</span> (m[nums[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">                index[nums[i]] = <span class="built_in">make_pair</span>(i, i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index[nums[i]].second = i;</span><br><span class="line">            &#125;</span><br><span class="line">            max_cnt = max(max_cnt, m[nums[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> item : m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.second == max_cnt) &#123;</span><br><span class="line">                res = min(res, index[item.first].second -</span><br><span class="line">                                   index[item.first].first + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="746-使用最小花费爬楼梯-n"><a href="#746-使用最小花费爬楼梯-n" class="headerlink" title="746. 使用最小花费爬楼梯 [n]"></a>746. 使用最小花费爬楼梯 [n]</h2><p>数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost<a href="%E7%B4%A2%E5%BC%95%E4%BB%8E0%E5%BC%80%E5%A7%8B">i</a>。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p>
<p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p>
<p>示例 1:</p>
<pre>
输入: cost = [10, 15, 20]
输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
</pre>
<p>示例 2:</p>
<pre>
输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
</pre>
<p>注意：</p>
<ul>
<li>cost 的长度将会在 [2, 1000]。</li>
<li>每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。</li>
</ul>
<div class="tabs" id="leetcode-746"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-746-1">Python</a></li><li class="tab"><a class="#leetcode-746-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-746-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span>(<span class="params">self, cost</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(cost)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            cost_v = cost[i] <span class="keyword">if</span> i != n <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost_v</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-746-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur_cost = i == n ? <span class="number">0</span> : cost[i];</span><br><span class="line">            dp[i] = min(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cur_cost;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="849-到最近的人的最大距离-n"><a href="#849-到最近的人的最大距离-n" class="headerlink" title="849. 到最近的人的最大距离 [n]"></a>849. 到最近的人的最大距离 [n]</h2><p>在一排座位（ seats）中，1 代表有人坐在座位上，0 代表座位上是空的。</p>
<p>至少有一个空座位，且至少有一人坐在座位上。</p>
<p>亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。</p>
<p>返回他到离他最近的人的最大距离。</p>
<p>示例 1：</p>
<pre>
输入：[1,0,0,0,1,0,1]
输出：2
解释：
如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为 2 。
如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为 1 。
因此，他到离他最近的人的最大距离是 2 。
</pre>
<p>示例 2：</p>
<pre>
输入：[1,0,0,0]
输出：3
解释： 
如果亚历克斯坐在最后一个座位上，他离最近的人有 3 个座位远。
这是可能的最大距离，所以答案是 3 。
</pre>
<p>提示：</p>
<ul>
<li>1 &lt;= seats.length &lt;= 20000</li>
<li>seats 中只含有 0 和 1，至少有一个 0，且至少有一个 1。</li>
</ul>
<div class="tabs" id="leetcode-849"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-849-1">Python</a></li><li class="tab"><a class="#leetcode-849-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-849-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDistToClosest</span>(<span class="params">self, seats</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type seats: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left = -<span class="number">1</span></span><br><span class="line">        max_dis = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(seats):</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> left == -<span class="number">1</span>:</span><br><span class="line">                max_dis = <span class="built_in">max</span>(max_dis, i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                max_dis = <span class="built_in">max</span>(max_dis, (i - left) / <span class="number">2</span>)</span><br><span class="line">            left = i</span><br><span class="line">        <span class="keyword">if</span> seats[-<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">            max_dis = <span class="built_in">max</span>(max_dis, <span class="built_in">len</span>(seats) - <span class="number">1</span> - left)</span><br><span class="line">        <span class="keyword">return</span> max_dis</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-849-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistToClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; seats)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; persons;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; seats.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seats[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                persons.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = persons.size(), m = seats.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                res = max(res, persons[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = max(res, (persons[i] - persons[i - <span class="number">1</span>]) / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res = max(res, m - <span class="number">1</span> - persons.back());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="941-有效的山脉数组"><a href="#941-有效的山脉数组" class="headerlink" title="941. 有效的山脉数组"></a>941. 有效的山脉数组</h2><p>给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。</p>
<p>让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：</p>
<ul>
<li>A.length &gt;= 3</li>
<li>在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得：<ul>
<li>A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i]</li>
<li>A[i] &gt; A[i+1] &gt; … &gt; A[B.length - 1]</li>
</ul>
</li>
</ul>
<p>示例 1：</p>
<pre>
输入：[2,1]
输出：false
</pre>
<p>示例 2：</p>
<pre>
输入：[3,5,5]
输出：false
</pre>
<p>示例 3：</p>
<pre>
输入：[0,3,2,1]
输出：true
</pre>

<p>提示：</p>
<ul>
<li>0 &lt;= A.length &lt;= 10000</li>
<li>0 &lt;= A[i] &lt;= 10000 </li>
</ul>
<div class="tabs" id="leetcode-941"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-941-1">Python</a></li><li class="tab"><a class="#leetcode-941-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-941-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validMountainArray</span>(<span class="params">self, A</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left + <span class="number">1</span> &lt; <span class="built_in">len</span>(A) <span class="keyword">and</span> A[left] &lt; A[left + <span class="number">1</span>]:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> A[right] &lt; A[right - <span class="number">1</span>]:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left != <span class="number">0</span> <span class="keyword">and</span> right != <span class="built_in">len</span>(A) - <span class="number">1</span> <span class="keyword">and</span> left == right</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-941-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validMountainArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; n - <span class="number">1</span> &amp;&amp; A[left] &lt; A[left + <span class="number">1</span>]) &#123;</span><br><span class="line">            left += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right &gt; <span class="number">0</span> &amp;&amp; A[right] &lt; A[right - <span class="number">1</span>]) &#123;</span><br><span class="line">            right -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left != <span class="number">0</span> &amp;&amp; right != n - <span class="number">1</span> &amp;&amp; left == right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode之栈和队列</title>
    <url>/posts/1ccb8d85.html</url>
    <content><![CDATA[<p>栈与队列的题目汇总在此了，欢迎大家光顾。</p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="/images/leetcode/queue_and_stack.png" style="width:600px;height:300px;"/></div></div>

<a id="more"></a>

<h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a>394. 字符串解码</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<p>示例:</p>
<pre>
s = "3[a]2[bc]", 返回 "aaabcbc".
s = "3[a2[c]]", 返回 "accaccacc".
s = "2[abc]3[cd]ef", 返回 "abcabccdcdcdef".
</pre>

<div class="tabs" id="leetcode-394"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-394-1">Python</a></li><li class="tab"><a class="#leetcode-394-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-394-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>   </span><br><span class="line">        stack, res, multi = [], <span class="string">&quot;&quot;</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                stack.append([multi, res])</span><br><span class="line">                res, multi = <span class="string">&quot;&quot;</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                cur_multi, last_res = stack.pop()</span><br><span class="line">                res = last_res + cur_multi * res</span><br><span class="line">            <span class="keyword">elif</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">                multi = multi * <span class="number">10</span> + <span class="built_in">int</span>(c)            </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += c</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-394-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">public</span> String str;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Item</span><span class="params">(<span class="keyword">int</span> n, String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = n;</span><br><span class="line">            <span class="keyword">this</span>.str = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> multi = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Item&gt; stk = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                stk.add(<span class="keyword">new</span> Item(multi, res));</span><br><span class="line">                res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                multi = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                Item item = stk.pop();</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; item.num; k++) &#123;</span><br><span class="line">                    sb.append(res);</span><br><span class="line">                &#125;</span><br><span class="line">                res = item.str + sb.toString();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                multi = multi * <span class="number">10</span> + Integer.parseInt(c + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="402-移掉K位数字"><a href="#402-移掉K位数字" class="headerlink" title="402. 移掉K位数字"></a>402. 移掉K位数字</h2><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p>
<p>注意:</p>
<ul>
<li>num 的长度小于 10002 且 ≥ k。</li>
<li>num 不会包含任何前导零。</li>
</ul>
<p>示例 1 :</p>
<pre>
输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
</pre>
<p>示例 2 :</p>
<pre>
输入: num = "10200", k = 1
输出: "200"
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
</pre>
<p>示例 3 :</p>
<pre>
输入: num = "10", k = 2
输出: "0"
解释: 从原数字移除所有的数字，剩余为空就是0。
</pre>


<div class="tabs" id="leetcode-402"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-402-1">Python</a></li><li class="tab"><a class="#leetcode-402-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-402-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeKdigits</span>(<span class="params">self, num, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num: str</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> num:</span><br><span class="line">            <span class="keyword">while</span> k <span class="keyword">and</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>] &gt; c:</span><br><span class="line">                stk.pop(-<span class="number">1</span>)</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            stk.append(c)</span><br><span class="line">        <span class="keyword">while</span> k:</span><br><span class="line">            stk.pop(-<span class="number">1</span>)</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stk:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(stk)))</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-402-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stk = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = num.charAt(i);</span><br><span class="line">            <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; !stk.empty() &amp;&amp; stk.peek() &gt; c) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">                k -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            stk.pop();</span><br><span class="line">            k -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.get(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            stk.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stk.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stk.size(); i++) &#123;</span><br><span class="line">            sb.append(stk.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="456-132模式"><a href="#456-132模式" class="headerlink" title="456. 132模式"></a>456. 132模式</h2><p>给定一个整数序列：a1, a2, …, an，一个132模式的子序列 ai, aj, ak 被定义为：当 i &lt; j &lt; k 时，ai &lt; ak &lt; aj。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。</p>
<p>注意：n 的值小于15000。</p>
<p>示例1:</p>
<pre>
输入: [1, 2, 3, 4]
输出: False
解释: 序列中不存在132模式的子序列。
</pre>
<p>示例 2:</p>
<pre>
输入: [3, 1, 4, 2]
输出: True
解释: 序列中有 1 个132模式的子序列： [1, 4, 2].
</pre>
<p>示例 3:</p>
<pre>
输入: [-1, 3, 2, 0]
输出: True
解释: 序列中有 3 个132模式的的子序列: [-1, 3, 2], [-1, 3, 0] 和 [-1, 2, 0].
</pre>


<div class="tabs" id="leetcode-456"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-456-1">Python</a></li><li class="tab"><a class="#leetcode-456-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-456-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find132pattern</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stk = []</span><br><span class="line">        INT_MIN = -(<span class="number">1</span> &lt;&lt; <span class="number">31</span>)</span><br><span class="line">        third = INT_MIN</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> xrange(<span class="built_in">len</span>(nums) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[idx] &lt; third:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>] &lt; nums[idx]:</span><br><span class="line">                third = stk.pop(-<span class="number">1</span>)</span><br><span class="line">            stk.append(nums[idx])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-456-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> INT_MIN = -(<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">        <span class="keyword">int</span> third = INT_MIN;</span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; third) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.peek() &lt; nums[i]) &#123;</span><br><span class="line">                third = stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a>496. 下一个更大元素 I</h2><p>给定两个没有重复元素的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。</p>
<p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。</p>
<p>示例 1:</p>
<pre>
输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:
    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。
    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。
    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。
</pre>
<p>示例 2:</p>
<pre>
输入: nums1 = [2,4], nums2 = [1,2,3,4].
输出: [3,-1]
解释:
    对于num1中的数字2，第二个数组中的下一个较大数字是3。
    对于num1中的数字4，第二个数组中没有下一个更大的数字，因此输出 -1。
</pre>

<p>注意:</p>
<ul>
<li>nums1和nums2中所有元素是唯一的。</li>
<li>nums1和nums2 的数组大小都不超过1000。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span>(<span class="params">self, nums1, nums2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        stk = []</span><br><span class="line">        res = [-<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="built_in">len</span>(nums1))]</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(stk) &gt; <span class="number">0</span> <span class="keyword">and</span> stk[-<span class="number">1</span>] &lt; n:</span><br><span class="line">                m[stk[-<span class="number">1</span>]] = n</span><br><span class="line">                stk.pop(-<span class="number">1</span>)</span><br><span class="line">            stk.append(n)</span><br><span class="line">        <span class="keyword">for</span> idx, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums1):</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> m:</span><br><span class="line">                res[idx] = m[n]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[idx] = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="503-下一个更大元素-II-n"><a href="#503-下一个更大元素-II-n" class="headerlink" title="503. 下一个更大元素 II [n]"></a>503. 下一个更大元素 II [n]</h2><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
<p>示例 1:</p>
<pre>
输入: [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
</pre>
<p>注意: 输入数组的长度不会超过 10000。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElements</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [-<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> xrange(n * <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>] &lt;= nums[idx % n]:</span><br><span class="line">                stk.pop(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stk) == <span class="number">0</span>:</span><br><span class="line">                res[idx % n] = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[idx % n] = stk[-<span class="number">1</span>]</span><br><span class="line">            stk.append(nums[idx % n])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="622-设计循环队列"><a href="#622-设计循环队列" class="headerlink" title="622. 设计循环队列"></a>622. 设计循环队列</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here. Set the size of the queue to be k.</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.queue = [<span class="literal">None</span>] * k</span><br><span class="line">        self.size = k</span><br><span class="line">        self.real_cnt = <span class="number">0</span></span><br><span class="line">        self.head = <span class="number">0</span></span><br><span class="line">        self.tail = <span class="number">0</span> <span class="comment"># 有效元素尾部的下一个位置</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enQueue</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Insert an element into the circular queue. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.queue[self.tail] = value</span><br><span class="line">        self.tail = (self.tail + <span class="number">1</span>) % self.size</span><br><span class="line">        self.real_cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deQueue</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Delete an element from the circular queue. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.head = (self.head + <span class="number">1</span>) % self.size</span><br><span class="line">        self.real_cnt -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Front</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the front item from the queue.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.queue[self.head]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Rear</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the last item from the queue.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.tail == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.queue[self.size - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> self.queue[self.tail - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Checks whether the circular queue is empty or not.</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.real_cnt == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFull</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Checks whether the circular queue is full or not.</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.real_cnt == self.size</span><br></pre></td></tr></table></figure>

<h2 id="641-设计循环双端队列"><a href="#641-设计循环双端队列" class="headerlink" title="641. 设计循环双端队列"></a>641. 设计循环双端队列</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularDeque</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here. Set the size of the deque to be k.</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.deque = [<span class="literal">None</span>] * k</span><br><span class="line">        self.size = k</span><br><span class="line">        self.real_cnt = <span class="number">0</span></span><br><span class="line">        self.head = <span class="number">0</span></span><br><span class="line">        self.tail = <span class="number">0</span> <span class="comment"># 有效元素尾部的下一个位置</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertFront</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Adds an item at the front of Deque. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> self.head == <span class="number">0</span>:</span><br><span class="line">            self.head = self.size - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.head = self.head - <span class="number">1</span></span><br><span class="line">        self.deque[self.head] = value</span><br><span class="line">        self.real_cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertLast</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Adds an item at the rear of Deque. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.deque[self.tail] = value</span><br><span class="line">        self.tail = (self.tail + <span class="number">1</span>) % self.size</span><br><span class="line">        self.real_cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteFront</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Deletes an item from the front of Deque. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.head = (self.head + <span class="number">1</span>) % self.size</span><br><span class="line">        self.real_cnt -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteLast</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Deletes an item from the rear of Deque. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> self.tail == <span class="number">0</span>:</span><br><span class="line">            self.tail = self.size - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.tail = self.tail - <span class="number">1</span></span><br><span class="line">        self.real_cnt -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getFront</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the front item from the deque.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.deque[self.head]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRear</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the last item from the deque.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.tail == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.deque[self.size - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.deque[self.tail - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Checks whether the circular deque is empty or not.</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.real_cnt == <span class="number">0</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFull</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Checks whether the circular deque is full or not.</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.real_cnt == self.size</span><br></pre></td></tr></table></figure>

<h2 id="739-每日温度-n"><a href="#739-每日温度-n" class="headerlink" title="739. 每日温度 [n]"></a>739. 每日温度 [n]</h2><p>根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, T</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type T: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="built_in">len</span>(T))]</span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(T) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> T[stk[-<span class="number">1</span>]] &lt;= T[i]:</span><br><span class="line">                stk.pop(-<span class="number">1</span>)</span><br><span class="line">            res[i] = <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> stk <span class="keyword">else</span> stk[-<span class="number">1</span>] - i</span><br><span class="line">            stk.append(i)</span><br><span class="line">        <span class="keyword">return</span> res        </span><br></pre></td></tr></table></figure>

<h2 id="856-括号的分数"><a href="#856-括号的分数" class="headerlink" title="856. 括号的分数"></a>856. 括号的分数</h2><p>给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：</p>
<p>() 得 1 分。<br>AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。<br>(A) 得 2 * A 分，其中 A 是平衡括号字符串。
 </p>
<p>示例 1：</p>
<pre>
输入： "()"
输出： 1
</pre>
<p>示例 2：</p>
<pre>
输入： "(())"
输出： 2
</pre>
<p>示例 3：</p>
<pre>
输入： "()()"
输出： 2
</pre>
<p>示例 4：</p>
<pre>
输入： "(()(()))"
输出： 6
</pre>

<p>提示：</p>
<ul>
<li>S 是平衡括号字符串，且只含有 ( 和 ) 。</li>
<li>2 &lt;= S.length &lt;= 50</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scoreOfParentheses</span>(<span class="params">self, S</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stk.append(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> stk[-<span class="number">1</span>] != -<span class="number">1</span>:</span><br><span class="line">                    cnt += stk[-<span class="number">1</span>]</span><br><span class="line">                    stk.pop(-<span class="number">1</span>)</span><br><span class="line">                stk.pop(-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">                    stk.append(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stk.append(<span class="number">2</span> * cnt)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(stk)</span><br></pre></td></tr></table></figure>

<h2 id="880-索引处的解码字符串-n"><a href="#880-索引处的解码字符串-n" class="headerlink" title="880. 索引处的解码字符串 [n]"></a>880. 索引处的解码字符串 [n]</h2><p>给定一个编码字符串 S。为了找出解码字符串并将其写入磁带，从编码字符串中每次读取一个字符，并采取以下步骤：</p>
<p>如果所读的字符是字母，则将该字母写在磁带上。<br>如果所读的字符是数字（例如 d），则整个当前磁带总共会被重复写 d-1 次。<br>现在，对于给定的编码字符串 S 和索引 K，查找并返回解码字符串中的第 K 个字母。</p>
<p>示例 1：</p>
<pre>
输入：S = "leet2code3", K = 10
输出："o"
解释：
解码后的字符串为 "leetleetcodeleetleetcodeleetleetcode"。
字符串中的第 10 个字母是 "o"。
</pre>
<p>示例 2：</p>
<pre>
输入：S = "ha22", K = 5
输出："h"
解释：
解码后的字符串为 "hahahaha"。第 5 个字母是 "h"。
</pre>
<p>示例 3：</p>
<pre>
输入：S = "a2345678999999999999999", K = 1
输出："a"
解释：
解码后的字符串为 "a" 重复 8301530446056247680 次。第 1 个字母是 "a"。
</pre>

<p>提示：</p>
<ul>
<li>2 &lt;= S.length &lt;= 100</li>
<li>S 只包含小写字母与数字 2 到 9 。</li>
<li>S 以字母开头。</li>
<li>1 &lt;= K &lt;= 10^9</li>
<li>解码后的字符串保证少于 2^63 个字母。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeAtIndex</span>(<span class="params">self, S, K</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        sz = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                sz *= <span class="built_in">int</span>(c)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sz += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S[::-<span class="number">1</span>]:</span><br><span class="line">            K %= sz</span><br><span class="line">            <span class="keyword">if</span> K == <span class="number">0</span> <span class="keyword">and</span> c.isalpha():</span><br><span class="line">                <span class="keyword">return</span> c</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                sz /= <span class="built_in">int</span>(c)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sz -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="907-子数组的最小值之和-n"><a href="#907-子数组的最小值之和-n" class="headerlink" title="907. 子数组的最小值之和 [n]"></a>907. 子数组的最小值之和 [n]</h2><p>给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。</p>
<p>由于答案可能很大，因此返回答案模 10^9 + 7。</p>
<p>示例：</p>
<pre>
输入：[3,1,2,4]
输出：17
解释：
子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 
最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。
</pre>

<p>提示：</p>
<ul>
<li>1 &lt;= A &lt;= 30000</li>
<li>1 &lt;= A[i] &lt;= 30000</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumSubarrayMins</span>(<span class="params">self, A</span>):</span></span><br><span class="line">        MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        N = <span class="built_in">len</span>(A)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># prev has i* - 1 in increasing order of A[i* - 1]</span></span><br><span class="line">        <span class="comment"># where i* is the answer to query j</span></span><br><span class="line">        stack = []</span><br><span class="line">        prev = [<span class="literal">None</span>] * N</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(N):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> A[i] &lt;= A[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            prev[i] = stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># next has k* + 1 in increasing order of A[k* + 1]</span></span><br><span class="line">        <span class="comment"># where k* is the answer to query j</span></span><br><span class="line">        stack = []</span><br><span class="line">        next_ = [<span class="literal">None</span>] * N</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> xrange(N-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> A[k] &lt; A[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            next_[k] = stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> N</span><br><span class="line">            stack.append(k)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Use prev/next array to count answer</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>((i - prev[i]) * (next_[i] - i) * A[i]</span><br><span class="line">                   <span class="keyword">for</span> i <span class="keyword">in</span> xrange(N)) % MOD</span><br></pre></td></tr></table></figure>

<h2 id="946-验证栈序列"><a href="#946-验证栈序列" class="headerlink" title="946. 验证栈序列"></a>946. 验证栈序列</h2><p>给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。</p>
<p>示例 1：</p>
<pre>
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
</pre>
<p>示例 2：</p>
<pre>
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
</pre>

<p>提示：</p>
<ul>
<li>0 &lt;= pushed.length == popped.length &lt;= 1000</li>
<li>0 &lt;= pushed[i], popped[i] &lt; 1000</li>
<li>pushed 是 popped 的排列。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span>(<span class="params">self, pushed, popped</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type pushed: List[int]</span></span><br><span class="line"><span class="string">        :type popped: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stk = []</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(pushed)</span><br><span class="line">        m = <span class="built_in">len</span>(popped)</span><br><span class="line">        <span class="keyword">if</span> m != n :</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            stk.append(pushed[i])</span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>] == popped[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                stk.pop(-<span class="number">1</span>)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stk) == <span class="number">0</span> <span class="keyword">and</span> j == n</span><br></pre></td></tr></table></figure>


<h2 id="1019-链表中的下一个更大节点-n"><a href="#1019-链表中的下一个更大节点-n" class="headerlink" title="1019. 链表中的下一个更大节点 [n]"></a>1019. 链表中的下一个更大节点 [n]</h2><p>给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, … 。</p>
<p>每个节点都可能有下一个更大值（next larger value）：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j &gt; i 且  node_j.val &gt; node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。</p>
<p>返回整数答案数组 answer，其中 answer[i] = next_larger(node_{i+1}) 。</p>
<p>注意：在下面的示例中，诸如 [2,1,5] 这样的输入（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。</p>
<p>示例 1：</p>
<pre>
输入：[2,1,5]
输出：[5,5,0]
</pre>
<p>示例 2：</p>
<pre>
输入：[2,7,4,3,5]
输出：[7,0,5,5,0]
</pre>
<p>示例 3：</p>
<pre>
输入：[1,7,5,1,9,2,5,1]
输出：[7,9,9,9,0,5,0,0]
</pre>

<p>提示：</p>
<ul>
<li>对于链表中的每个节点，1 &lt;= node.val &lt;= 10^9</li>
<li>给定列表的长度在 [0, 10000] 范围内</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextLargerNodes</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            nums.append(head.val)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        res = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> nums[stk[-<span class="number">1</span>]] &lt; v:</span><br><span class="line">                res[stk.pop()] = v</span><br><span class="line">            stk.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="1209-删除字符串中的所有相邻重复项-II"><a href="#1209-删除字符串中的所有相邻重复项-II" class="headerlink" title="1209. 删除字符串中的所有相邻重复项 II"></a>1209. 删除字符串中的所有相邻重复项 II</h2><p>给你一个字符串 s，「k 倍重复项删除操作」将会从 s 中选择 k 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。</p>
<p>你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。</p>
<p>在执行完所有删除操作后，返回最终得到的字符串。</p>
<p>本题答案保证唯一。</p>
<p>示例 1：</p>
<pre>
输入：s = "abcd", k = 2
输出："abcd"
解释：没有要删除的内容。
</pre>
<p>示例 2：</p>
<pre>
输入：s = "deeedbbcccbdaa", k = 3
输出："aa"
解释： 
先删除 "eee" 和 "ccc"，得到 "ddbbbdaa"
再删除 "bbb"，得到 "dddaa"
最后删除 "ddd"，得到 "aa"
</pre>
<p>示例 3：</p>
<pre>
输入：s = "pbbcggttciiippooaais", k = 2
输出："ps"
</pre>

<p>提示：</p>
<ul>
<li>1 &lt;= s.length &lt;= 10^5</li>
<li>2 &lt;= k &lt;= 10^4</li>
<li>s 中只含有小写英文字母。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, s, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>][<span class="number">0</span>] == c:</span><br><span class="line">                stk[-<span class="number">1</span>][<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> stk[-<span class="number">1</span>][<span class="number">1</span>] == k:</span><br><span class="line">                    stk.pop(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stk.append([c, <span class="number">1</span>])</span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> v, i <span class="keyword">in</span> stk:</span><br><span class="line">            res += i * v</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="1249-移除无效的括号-n"><a href="#1249-移除无效的括号-n" class="headerlink" title="1249. 移除无效的括号 [n]"></a>1249. 移除无效的括号 [n]</h2><p>给你一个由 ‘(‘、’)’ 和小写字母组成的字符串 s。</p>
<p>你需要从字符串中删除最少数目的 ‘(‘ 或者 ‘)’ （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。</p>
<p>请返回任意一个合法字符串。</p>
<p>有效「括号字符串」应当符合以下 任意一条 要求：</p>
<ul>
<li>空字符串或只包含小写字母的字符串</li>
<li>可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」</li>
<li>可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」</li>
</ul>
<p>示例 1：</p>
<pre>
输入：s = "lee(t(c)o)de)"
输出："lee(t(c)o)de"
解释："lee(t(co)de)" , "lee(t(c)ode)" 也是一个可行答案。
</pre>
<p>示例 2：</p>
<pre>
输入：s = "a)b(c)d"
输出："ab(c)d"
</pre>
<p>示例 3：</p>
<pre>
输入：s = "))(("
输出：""
解释：空字符串也是有效的
</pre>
<p>示例 4：</p>
<pre>
输入：s = "(a(b(c)d)"
输出："a(b(c)d)"
</pre>

<p>提示：</p>
<ul>
<li>1 &lt;= s.length &lt;= 10^5</li>
<li>s[i] 可能是 ‘(‘、’)’ 或英文小写字母</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minRemoveToMakeValid</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> v == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stk.append((i, v))</span><br><span class="line">            <span class="keyword">elif</span> v == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    stk.pop(-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stk.append((i, v))</span><br><span class="line">        res, j = <span class="string">&quot;&quot;</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> j &lt; <span class="built_in">len</span>(stk) <span class="keyword">and</span> i == stk[j][<span class="number">0</span>]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += v</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>牛客题霸-名企高频面试题</title>
    <url>/posts/1369037266.html</url>
    <content><![CDATA[<p>终于把牛客题霸-名企高频面试题刷完了，在这里汇总一下。</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="/images/tech/niuke/banner.png" style="width:600px;height:300px;"/></div></div>

<a id="more"></a>

<h2 id="NC21-链表内指定区间反转"><a href="#NC21-链表内指定区间反转" class="headerlink" title="NC21. 链表内指定区间反转"></a>NC21. 链表内指定区间反转</h2><p>将一个链表 m 位置到 n 位置之间的区间反转，要求时间复杂度，空间复杂度。</p>
<p>示例1</p>
<pre>
输入:
{1,2,3,4,5},2,4
返回值:
{1,4,3,2,5}
</pre>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *p = dummy, *prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *q = dummy, *next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; i++) &#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        next = q-&gt;next;</span><br><span class="line">        <span class="built_in">pair</span>&lt;ListNode*, ListNode*&gt; res = reverse(prev, p, next);</span><br><span class="line">        prev-&gt;next = res.first;</span><br><span class="line">        res.second-&gt;next = next;</span><br><span class="line">        head = dummy-&gt;next;</span><br><span class="line">        dummy-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pair&lt;ListNode*, ListNode*&gt; reverse(ListNode *prev, ListNode *head, ListNode *tail) &#123;</span><br><span class="line">        ListNode *p = head, *q = prev;</span><br><span class="line">        <span class="keyword">while</span>(p != tail) &#123;</span><br><span class="line">            ListNode *nextNode = p-&gt;next;</span><br><span class="line">            p-&gt;next = q;</span><br><span class="line">            q = p;</span><br><span class="line">            p = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pair</span>&lt;ListNode*, ListNode*&gt; res;</span><br><span class="line">        res.first = q;</span><br><span class="line">        res.second = prev-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="NC24-删除有序链表中重复出现的元素"><a href="#NC24-删除有序链表中重复出现的元素" class="headerlink" title="NC24. 删除有序链表中重复出现的元素"></a>NC24. 删除有序链表中重复出现的元素</h2><p>给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。<br>例如：<br>给出的链表为1→2→3→3→4→4→5, 返回1→2→5.<br>给出的链表为1→1→1→2→3, 返回2→3.</p>
<div class="tabs" id="nc-24"><ul class="nav-tabs"><li class="tab active"><a class="#nc-24-1">Python</a></li><li class="tab"><a class="#nc-24-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="nc-24-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self , head</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        p = dummy</span><br><span class="line">        q = head</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            cur = q</span><br><span class="line">            cur_v = q.val</span><br><span class="line">            cnt = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.val == cur_v:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="number">1</span>:</span><br><span class="line">                p.<span class="built_in">next</span> = cur</span><br><span class="line">                q = cur.<span class="built_in">next</span></span><br><span class="line">                p = cur</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                q = cur.<span class="built_in">next</span></span><br><span class="line">        p = dummy.<span class="built_in">next</span></span><br><span class="line">        dummy.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="nc-24-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head ListNode类 </span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *p = dummy, *q = head;</span><br><span class="line">        <span class="keyword">while</span>(q) &#123;</span><br><span class="line">            ListNode *cur = q;</span><br><span class="line">            <span class="keyword">int</span> curVal = cur-&gt;val;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == curVal) &#123;</span><br><span class="line">                cnt += <span class="number">1</span>;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                p-&gt;next = cur-&gt;next;</span><br><span class="line">                q = cur-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;next = cur;</span><br><span class="line">                q = cur-&gt;next;</span><br><span class="line">                p = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p = dummy-&gt;next;</span><br><span class="line">        dummy-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="NC35-最小编辑代价-n"><a href="#NC35-最小编辑代价-n" class="headerlink" title="NC35. 最小编辑代价 [n]"></a>NC35. 最小编辑代价 [n]</h2><p>给定两个字符串str1和str2，再给定三个整数ic，dc和rc，分别代表插入、删除和替换一个字符的代价，请输出将str1编辑成str2的最小代价。</p>
<p>示例1</p>
<pre>
输入:
"abc","adc",5,3,2
返回值:
2
</pre>

<p>示例2</p>
<pre>
输入:
"abc","adc",5,3,100
返回值:
8
</pre>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minEditCost</span> <span class="params">(String str1, String str2, <span class="keyword">int</span> ic, <span class="keyword">int</span> dc, <span class="keyword">int</span> rc)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> m = str1.length();</span><br><span class="line">        <span class="keyword">int</span> n = str2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i*dc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j*ic;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = str1.charAt(i-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c2 = str2.charAt(j-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(c1 == c2) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> insert = dp[i][j-<span class="number">1</span>] + ic;</span><br><span class="line">                    <span class="keyword">int</span> delete = dp[i-<span class="number">1</span>][j] + dc;</span><br><span class="line">                    <span class="keyword">int</span> replace = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + rc;</span><br><span class="line">                    dp[i][j] = Math.min(replace, Math.min(insert, delete));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NC44-通配符匹配-n"><a href="#NC44-通配符匹配-n" class="headerlink" title="NC44. 通配符匹配 [n]"></a>NC44. 通配符匹配 [n]</h2><p>请实现支持’?’and’*‘.的通配符模式匹配。<br>‘?’ 可以匹配任何单个字符。<br>‘*‘ 可以匹配任何字符序列（包括空序列）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">self , s , p </span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        backi, backj = -<span class="number">1</span>, -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> j &lt; <span class="built_in">len</span>(p) <span class="keyword">and</span> (s[i] == p[j] <span class="keyword">or</span> p[j] == <span class="string">&#x27;?&#x27;</span>):</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> j &lt; <span class="built_in">len</span>(p) <span class="keyword">and</span> p[j] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                backi = i</span><br><span class="line">                backj = j</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> backj != -<span class="number">1</span>:</span><br><span class="line">                i = backi + <span class="number">1</span></span><br><span class="line">                j = backj + <span class="number">1</span></span><br><span class="line">                backi = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(p) <span class="keyword">and</span> p[j] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> j == <span class="built_in">len</span>(p)</span><br></pre></td></tr></table></figure>

<h2 id="NC49-最长的括号子串"><a href="#NC49-最长的括号子串" class="headerlink" title="NC49. 最长的括号子串"></a>NC49. 最长的括号子串</h2><p>给出一个仅包含字符’(‘和’)’的字符串，计算最长的格式正确的括号子串的长度。<br>对于字符串”(()”来说，最长的格式正确的子串是”()”，长度为2.<br>再举一个例子：对于字符串”)()())”,来说，最长的格式正确的子串是”()()”，长度为4.</p>
<pre>
输入:
"(()"
返回值:
2
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span>(<span class="params">self , s </span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        s_len = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> s_len &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        stk = []</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        last = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(s_len):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stk.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(stk) == <span class="number">0</span>:</span><br><span class="line">                    last = i</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stk.pop(-<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(stk) == <span class="number">0</span>:</span><br><span class="line">                        max_len = <span class="built_in">max</span>(max_len, i - last)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        max_len = <span class="built_in">max</span>(max_len, i - stk[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>

<h2 id="NC50-链表中的节点每k个一组翻转-n"><a href="#NC50-链表中的节点每k个一组翻转-n" class="headerlink" title="NC50. 链表中的节点每k个一组翻转 [n]"></a>NC50. 链表中的节点每k个一组翻转 [n]</h2><p>将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表<br>如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样<br>你不能更改节点中的值，只能更改节点本身。<br>要求空间复杂度 O(1)<br>例如：</p>
<pre>
给定的链表是1→2→3→4→5
对于 k=2, 你应该返回 2→1→4→3→5
对于 k=3, 你应该返回 3→2→1→4→5
</pre>


<div class="tabs" id="leetcode-50"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-50-1">Python</a></li><li class="tab"><a class="#leetcode-50-2">Cpp</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-50-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, head, tail</span>):</span></span><br><span class="line">        prev = tail.<span class="built_in">next</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> prev != tail:</span><br><span class="line">            nex = p.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = p</span><br><span class="line">            p = nex</span><br><span class="line">        <span class="keyword">return</span> tail, head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span>(<span class="params">self, head, k</span>):</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        pre = dummy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            tail = pre</span><br><span class="line">            <span class="comment"># 查看剩余部分长度是否大于等于 k</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                tail = tail.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> tail:</span><br><span class="line">                    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line">            nex = tail.<span class="built_in">next</span></span><br><span class="line">            head, tail = self.reverse(head, tail)</span><br><span class="line">            <span class="comment"># 把子链表重新接回原链表</span></span><br><span class="line">            pre.<span class="built_in">next</span> = head</span><br><span class="line">            tail.<span class="built_in">next</span> = nex</span><br><span class="line">            pre = tail</span><br><span class="line">            head = tail.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-50-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *	int val;</span></span><br><span class="line"><span class="comment"> *	struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head ListNode类 </span></span><br><span class="line"><span class="comment">     * @param k int整型 </span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p = head, *q = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(q == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = reverse(p, q);</span><br><span class="line">        p-&gt;next = reverseKGroup(q, k);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode *head, ListNode* end)</span> </span>&#123;</span><br><span class="line">        ListNode* p = head, *q = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(p != end) &#123;</span><br><span class="line">            ListNode *r = p-&gt;next;</span><br><span class="line">            p-&gt;next = q;</span><br><span class="line">            q = p;</span><br><span class="line">            p = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>



<h2 id="NC57-反转数字"><a href="#NC57-反转数字" class="headerlink" title="NC57. 反转数字"></a>NC57. 反转数字</h2><p>将给出的32位整数x翻转。<br>例1:x=123，返回321。<br>例2:x=-123，返回-321。</p>
<p>你有注意到翻转后的整数可能溢出吗？因为给出的是32位整数，则其数值范围为[−2^{31}, 2^{31} − 1]。翻转可能会导致溢出，如果反转后的结果会溢出就返回 0。</p>
<pre>
输入:
-123
返回值:
-321
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self , x </span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        INT_MIN = -(<span class="number">1</span> &lt;&lt; <span class="number">31</span>)</span><br><span class="line">        INT_MAX = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span></span><br><span class="line">        sign = x &lt; <span class="number">0</span></span><br><span class="line">        x = <span class="built_in">abs</span>(x)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x:</span><br><span class="line">            v = x % <span class="number">10</span></span><br><span class="line">            x = x // <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> res &gt; INT_MAX / <span class="number">10</span> <span class="keyword">or</span> (res == INT_MAX / <span class="number">10</span> <span class="keyword">and</span> v &gt; <span class="number">7</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> sign <span class="keyword">and</span> (-res &lt; INT_MIN / <span class="number">10</span> <span class="keyword">or</span> (-res == INT_MIN / <span class="number">10</span> <span class="keyword">and</span> v &lt; -<span class="number">8</span>)):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            res = res * <span class="number">10</span> + v</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> <span class="keyword">not</span> sign <span class="keyword">else</span> -res</span><br></pre></td></tr></table></figure>

<h2 id="NC62-平衡二叉树"><a href="#NC62-平衡二叉树" class="headerlink" title="NC62. 平衡二叉树"></a>NC62. 平衡二叉树</h2><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树。</p>
<p>平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<pre>
输入:
{1,2,3,4,5,6,7}
返回值:
true
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span>(<span class="params">self, pRoot</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(pRoot) != -<span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.helper(root.left)</span><br><span class="line">        <span class="keyword">if</span> left == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        right = self.helper(root.right)</span><br><span class="line">        <span class="keyword">if</span> right == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        v = <span class="built_in">abs</span>(left - right)</span><br><span class="line">        <span class="keyword">if</span> v &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="NC64-二叉搜索树与双向链表"><a href="#NC64-二叉搜索树与双向链表" class="headerlink" title="NC64. 二叉搜索树与双向链表"></a>NC64. 二叉搜索树与双向链表</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.last_node = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span>(<span class="params">self, pRootOfTree</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRootOfTree:</span><br><span class="line">            <span class="keyword">return</span> pRootOfTree</span><br><span class="line">        self.last_node = <span class="literal">None</span></span><br><span class="line">        self.helper(pRootOfTree)</span><br><span class="line">        <span class="keyword">while</span> pRootOfTree.left:</span><br><span class="line">            pRootOfTree = pRootOfTree.left</span><br><span class="line">        <span class="keyword">return</span> pRootOfTree</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            self.helper(root.left)</span><br><span class="line">        root.left = self.last_node</span><br><span class="line">        <span class="keyword">if</span> self.last_node:</span><br><span class="line">            self.last_node.right = root</span><br><span class="line">        self.last_node = root</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            self.helper(root.right)</span><br></pre></td></tr></table></figure>

<h2 id="NC75-数组中只出现一次的数字"><a href="#NC75-数组中只出现一次的数字" class="headerlink" title="NC75. 数组中只出现一次的数字"></a>NC75. 数组中只出现一次的数字</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span>(<span class="params">self, array</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> array:</span><br><span class="line">            x ^= n</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">            x &gt;&gt;= <span class="number">1</span></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        n1, n2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> self.f(n, idx):</span><br><span class="line">                n1 ^= n</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                n2 ^= n</span><br><span class="line">        <span class="keyword">return</span> [n1, n2]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">self, n, idx</span>):</span></span><br><span class="line">        n &gt;&gt;= idx</span><br><span class="line">        <span class="keyword">return</span>(n &amp; <span class="number">1</span>) == <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="NC82-滑动窗口的最大值"><a href="#NC82-滑动窗口的最大值" class="headerlink" title="NC82. 滑动窗口的最大值"></a>NC82. 滑动窗口的最大值</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。<br>窗口大于数组长度的时候，返回空</p>
<p>示例1</p>
<pre>
输入:
[2,3,4,2,6,2,5,1],3
返回值:
[4,4,6,6,6,5]
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span>(<span class="params">self, nums, size</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        queue = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> size:</span><br><span class="line">            <span class="keyword">return</span> queue</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">while</span> queue <span class="keyword">and</span> queue[<span class="number">0</span>] &lt;= i - size:</span><br><span class="line">                queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">while</span> queue <span class="keyword">and</span> v &gt; nums[queue[-<span class="number">1</span>]]:</span><br><span class="line">                queue.pop(-<span class="number">1</span>)</span><br><span class="line">            queue.append(i)</span><br><span class="line">            <span class="keyword">if</span> i &gt;= size - <span class="number">1</span>:</span><br><span class="line">                res.append(nums[queue[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="NC88-寻找第K大"><a href="#NC88-寻找第K大" class="headerlink" title="NC88. 寻找第K大"></a>NC88. 寻找第K大</h2><p>有一个整数数组，请你根据快速排序的思路，找出数组中第K大的数。</p>
<p>给定一个整数数组a,同时给定它的大小n和要找的K(K在1到n之间)，请返回第K大的数，保证答案存在。</p>
<p>示例1</p>
<pre>
输入:
[1,3,5,2,2],5,3
返回值:
2
</pre>

<div class="tabs" id="leetcode-88"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-88-1">Python</a></li><li class="tab"><a class="#leetcode-88-2">Cpp</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-88-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Finder</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKth</span>(<span class="params">self, a, n, K</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(a, <span class="number">0</span>, n - <span class="number">1</span>, K)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, a, left, right, K</span>):</span></span><br><span class="line">        idx = self.paritition(a, left, right)</span><br><span class="line">        <span class="keyword">if</span> idx == K - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> a[idx]</span><br><span class="line">        <span class="keyword">elif</span> idx &lt; K - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.helper(a, idx + <span class="number">1</span>, right, K)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.helper(a, left, idx - <span class="number">1</span>, K)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">paritition</span>(<span class="params">self, a, low, high</span>):</span></span><br><span class="line">        pivot = a[low]</span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> a[high] &lt;= pivot:</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">            a[low] = a[high]</span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> a[low] &gt;= pivot:</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">            a[high] = a[low]</span><br><span class="line">        a[low] = pivot</span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-88-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> n, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">return</span> Helper(a, <span class="number">0</span>, n - <span class="number">1</span>, K);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = Partition(arr, left, right);</span><br><span class="line">        <span class="keyword">if</span>(idx + <span class="number">1</span> == K) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(idx + <span class="number">1</span> &lt; K) &#123;</span><br><span class="line">            <span class="keyword">return</span> Helper(arr, idx + <span class="number">1</span>, right, K);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Helper(arr, left, idx - <span class="number">1</span>, K);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &lt;= pivot) &#123;</span><br><span class="line">                right -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &gt;= pivot) &#123;</span><br><span class="line">                left += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[right] = arr[left];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = pivot;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>



<h2 id="NC91-最长递增子序列-n"><a href="#NC91-最长递增子序列-n" class="headerlink" title="NC91. 最长递增子序列 [n]"></a>NC91. 最长递增子序列 [n]</h2><p>给定数组arr，设长度为n，输出arr的最长递增子序列。（如果有多个答案，请输出其中字典序最小的）。</p>
<p>示例1</p>
<pre>
输入:
[2,1,5,3,6,4,8,9,7]
返回值:
[1,3,4,8,9]
</pre>

<p>示例2</p>
<pre>
输入:
[1,2,8,6,4]
返回值:
[1,2,4]
</pre>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">LIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 第一步：利用贪心+二分求最长递增子序列长度</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxLen;</span><br><span class="line">        <span class="keyword">if</span> (arr.size() &lt; <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        res.emplace_back(arr[<span class="number">0</span>]);  <span class="comment">// 注：emplace_back(val)作用同push_back，效率更高</span></span><br><span class="line">        maxLen.emplace_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; res.back()) &#123;</span><br><span class="line">                res.emplace_back(arr[i]);</span><br><span class="line">                maxLen.emplace_back(res.size());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// lower_bound(begin, end, val)包含在&lt;algorithm&gt;中</span></span><br><span class="line">                <span class="comment">// 它的作用是返回有序数组begin..end中第一个大于等于val的元素的迭代器</span></span><br><span class="line">                <span class="keyword">int</span> pos = lower_bound(res.begin(), res.end(), arr[i]) - res.begin();</span><br><span class="line">                res[pos] = arr[i];</span><br><span class="line">                maxLen.emplace_back(pos+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二步：填充最长递增子序列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.size()<span class="number">-1</span>, j = res.size(); j &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxLen[i] == j) &#123;</span><br><span class="line">                res[--j] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="NC92-最长公共子序列-n"><a href="#NC92-最长公共子序列-n" class="headerlink" title="NC92. 最长公共子序列 [n]"></a>NC92. 最长公共子序列 [n]</h2><p>给定两个字符串str1和str2，输出连个字符串的最长公共子序列。如过最长公共子序列为空，则输出-1。</p>
<p>示例1</p>
<pre>
输入:
"1A2C3D4B56","B1D23CA45B6A"
返回值:
"123456"
</pre>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LCS</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(s1.size() == <span class="number">0</span> || s2.size() == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>, start = <span class="number">-1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s2.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s1.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> last = dp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s2.size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = dp[j];</span><br><span class="line">                <span class="keyword">if</span>(s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[j] = last + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                last = tmp;</span><br><span class="line">                <span class="keyword">if</span>(maxLen &lt; dp[j])&#123;</span><br><span class="line">                    maxLen = dp[j];</span><br><span class="line">                    start = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxLen == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> s1.substr(start-maxLen, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="NC108-最大正方形"><a href="#NC108-最大正方形" class="headerlink" title="NC108. 最大正方形"></a>NC108. 最大正方形</h2><p>给定一个由0和1组成的2维矩阵，返回该矩阵中最大的由1组成的正方形的面积</p>
<p>示例1</p>
<pre>
输入:
[[1,0,1,0,0],[1,0,1,1,1],[1,1,1,1,1],[1,0,0,1,0]]
返回值:
4
</pre>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> maxEdge = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size() == <span class="number">0</span> || matrix[<span class="number">0</span>].size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> maxEdge;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.size(), cols = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(rows, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i ==<span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> temp = min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                        dp[i][j] = min(dp[i - <span class="number">1</span>][j], temp) + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                maxEdge = max(maxEdge, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxEdge * maxEdge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="NC116-把数字翻译成字符串"><a href="#NC116-把数字翻译成字符串" class="headerlink" title="NC116. 把数字翻译成字符串"></a>NC116. 把数字翻译成字符串</h2><p>有一种将字母编码成数字的方式：’a’-&gt;1, ‘b-&gt;2’, … , ‘z-&gt;26’。</p>
<p>现在给一串数字，返回有多少种可能的译码结果</p>
<p>示例1</p>
<pre>
输入:
"12"
返回值:
2
</pre>

<p>示例1</p>
<pre>
输入:
"31717126241541717"
返回值:
192
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self , nums </span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span> <span class="keyword">if</span> nums[<span class="number">0</span>] != <span class="string">&#x27;0&#x27;</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            two = nums[i - <span class="number">2</span>: i]</span><br><span class="line">            one = nums[i - <span class="number">1</span>:i]</span><br><span class="line">            <span class="keyword">if</span> <span class="number">10</span> &lt;= <span class="built_in">int</span>(two) &lt;= <span class="number">26</span>:</span><br><span class="line">                dp[i] += dp[i - <span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="number">1</span> &lt;= <span class="built_in">int</span>(one) &lt;= <span class="number">9</span>:</span><br><span class="line">                dp[i] += dp[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<h2 id="NC118-数组中的逆序对"><a href="#NC118-数组中的逆序对" class="headerlink" title="NC118. 数组中的逆序对"></a>NC118. 数组中的逆序对</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<p>示例1</p>
<pre>
输入:
[1,2,3,4,5,6,7,0]
返回值:
7
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InversePairs</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(data)</span><br><span class="line">        tmp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        res = self.mergeSort(data, tmp, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res % <span class="number">1000000007</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">self, data, tmp, left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        res = self.mergeSort(data, tmp, left, mid) + \</span><br><span class="line">            self.mergeSort(data, tmp, mid + <span class="number">1</span>, right)</span><br><span class="line">        i, j = left, mid + <span class="number">1</span></span><br><span class="line">        pos = left</span><br><span class="line">        <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> data[i] &lt;= data[j]:</span><br><span class="line">                tmp[pos] = data[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                res += j - (mid + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp[pos] = data[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> xrange(i, mid + <span class="number">1</span>):</span><br><span class="line">            tmp[pos] = data[k]</span><br><span class="line">            pos += <span class="number">1</span></span><br><span class="line">            res += j - (mid + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> xrange(j, right + <span class="number">1</span>):</span><br><span class="line">            tmp[pos] = data[k]</span><br><span class="line">            pos += <span class="number">1</span></span><br><span class="line">        data[left: right + <span class="number">1</span>] = tmp[left: right + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="NC119-最小的K个数"><a href="#NC119-最小的K个数" class="headerlink" title="NC119. 最小的K个数"></a>NC119. 最小的K个数</h2><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。<br>示例1</p>
<pre>
输入
[4,5,1,6,2,7,3,8],4
返回值
[1,2,3,4]
</pre>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(input.size() &lt; k || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = input.size() - <span class="number">1</span>；</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end) &#123; <span class="comment">//需要细心，要加等号！</span></span><br><span class="line">            <span class="keyword">int</span> idx = Partition(input, start, end);</span><br><span class="line">            <span class="keyword">if</span>(idx + <span class="number">1</span> == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(input.begin(), input.begin() + k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(idx + <span class="number">1</span> &lt; k) &#123;</span><br><span class="line">                start = idx + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                end = idx - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[start];</span><br><span class="line">        <span class="keyword">int</span> left = start, right = end;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &gt;= pivot) &#123;</span><br><span class="line">                right -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123;</span><br><span class="line">                left += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[right] = arr[left];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = pivot;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="NC122-正则表达式匹配-n"><a href="#NC122-正则表达式匹配-n" class="headerlink" title="NC122. 正则表达式匹配 [n]"></a>NC122. 正则表达式匹配 [n]</h2><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p>
<p>示例1</p>
<pre>
输入:
"aaa","a*a"
返回值:
true
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s, pattern都是字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match</span>(<span class="params">self, s, pattern</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> <span class="keyword">not</span> pattern:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        s_len = <span class="built_in">len</span>(s)</span><br><span class="line">        p_len = <span class="built_in">len</span>(pattern)</span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(p_len + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(s_len + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(s_len + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, p_len + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> pattern[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>]</span><br><span class="line">                    <span class="keyword">if</span> self.isOK(s, pattern, i, j - <span class="number">1</span>):</span><br><span class="line">                        dp[i][j] = dp[i][j] <span class="keyword">or</span> dp[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> self.isOK(s, pattern, i, j):</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[s_len][p_len]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isOK</span>(<span class="params">self, s, pattern, i, j</span>):</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> pattern[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> s[i - <span class="number">1</span>] == pattern[j - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="NC126-换钱的最少货币数-n"><a href="#NC126-换钱的最少货币数-n" class="headerlink" title="NC126. 换钱的最少货币数 [n]"></a>NC126. 换钱的最少货币数 [n]</h2><p>给定数组arr，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个aim，代表要找的钱数，求组成aim的最少货币数。<br>如果无解，请返回-1.<br>【要求】<br>时间复杂度O(n×aim)，空间复杂度O(n)。</p>
<p>示例1</p>
<pre>
输入:
[5,2,3],20
返回值:
4
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMoney</span>(<span class="params">self, arr, aim</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        INT_MAX = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span></span><br><span class="line">        dp = [INT_MAX <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(aim + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> xrange(aim + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> arr:</span><br><span class="line">                <span class="keyword">if</span> n &gt;= v:</span><br><span class="line">                    dp[n] = <span class="built_in">min</span>(dp[n], dp[n - v] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[aim] <span class="keyword">if</span> dp[aim] != INT_MAX <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="NC127-最长公共子串-n"><a href="#NC127-最长公共子串-n" class="headerlink" title="NC127. 最长公共子串 [n]"></a>NC127. 最长公共子串 [n]</h2><p>给定两个字符串str1和str2,输出两个字符串的最长公共子串，如果最长公共子串为空，输出-1。</p>
<p>示例1</p>
<pre>
输入:
"1AB2345CD","12345EF"
返回值:
"2345"
</pre>

<p>Python会超时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LCS</span> <span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> m = str1.length();</span><br><span class="line">        <span class="keyword">int</span> n = str2.length();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        String tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(str1.charAt(i - <span class="number">1</span>) == str2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &gt; res) &#123;</span><br><span class="line">                    res = dp[i][j];</span><br><span class="line">                    tmp = str1.substring(i - dp[i][j], i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NC128-容器盛水问题-n"><a href="#NC128-容器盛水问题-n" class="headerlink" title="NC128. 容器盛水问题 [n]"></a>NC128. 容器盛水问题 [n]</h2><p>给定一个整形数组arr，已知其中所有的值都是非负的，将这个数组看作一个容器，请返回容器能装多少水。<br>具体请参考样例解释</p>
<p>示例1</p>
<pre>
输入:
[3,1,2,5,2,4]
返回值:
5
</pre>

<p>示例2</p>
<pre>
输入:
[4,5,1,3,2]
返回值:
2
</pre>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * max water</span></span><br><span class="line"><span class="comment">     * @param arr int整型vector the array</span></span><br><span class="line"><span class="comment">     * @return long长整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">maxWater</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(arr.size() &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = arr.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = getMin(arr[left], arr[right]);</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[left] &lt; arr[right]) &#123;</span><br><span class="line">                left += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(arr[left] &lt; min) &#123;</span><br><span class="line">                    res += min - arr[left];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    min = getMin(arr[left], arr[right]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(arr[right] &lt; min) &#123;</span><br><span class="line">                    res += min - arr[right];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    min = getMin(arr[left], arr[right]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? b: a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="NC138-矩阵最长递增路径"><a href="#NC138-矩阵最长递增路径" class="headerlink" title="NC138. 矩阵最长递增路径"></a>NC138. 矩阵最长递增路径</h2><p>给定一个矩阵，矩阵内所有数均为非负整数。<br>求一条路径，该路径上所有数是递增的。<br>这个路径必须满足以下条件：<br>1、对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外。<br>2、你不能走重复的单元格。即每个格子最多只能走一次。</p>
<p>示例1</p>
<pre>
输入:
[[1,2,3],[4,5,6],[7,8,9]]
返回值:
5
</pre>

<p>示例2</p>
<pre>
输入:
[[1,2],[4,3]]
返回值:
4
</pre>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(matrix.size() == <span class="number">0</span> || matrix[<span class="number">0</span>].size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.size(), cols = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">memo</span><span class="params">(rows, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = dfs(matrix, i, j, rows, cols, memo, dirs);</span><br><span class="line">                res = max(res, cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; memo, <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(memo[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i][j] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> newI = dirs[k][<span class="number">0</span>] + i, newJ = dirs[k][<span class="number">1</span>] + j;</span><br><span class="line">            <span class="keyword">if</span>(newI &gt;= <span class="number">0</span> &amp;&amp; newI &lt; rows &amp;&amp; newJ &gt;= <span class="number">0</span> &amp;&amp; newJ &lt; cols &amp;&amp; matrix[i][j] &lt; matrix[newI][newJ]) &#123;</span><br><span class="line">                memo[i][j] = max(memo[i][j], dfs(matrix, newI, newJ, rows, cols, memo, dirs) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode之二叉树(中等)</title>
    <url>/posts/3ddb3bb0.html</url>
    <content><![CDATA[<p>二叉树(中等)的题目汇总在此了，欢迎大家光顾。</p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="/images/leetcode/hongheishu.png" style="width:600px;height:300px;"/></div></div>

<a id="more"></a>

<h2 id="95-不同的二叉搜索树-II-n"><a href="#95-不同的二叉搜索树-II-n" class="headerlink" title="95. 不同的二叉搜索树 II [n]"></a>95. 不同的二叉搜索树 II [n]</h2><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。</p>
<p>示例:</p>
<pre>
输入: 3
输出:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释:
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[TreeNode]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.helper(<span class="number">1</span>, n)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> [<span class="literal">None</span>]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(start, end + <span class="number">1</span>):</span><br><span class="line">            lefts = self.helper(start, i - <span class="number">1</span>)</span><br><span class="line">            rights = self.helper(i + <span class="number">1</span>, end)</span><br><span class="line">            <span class="keyword">for</span> left <span class="keyword">in</span> lefts:</span><br><span class="line">                <span class="keyword">for</span> right <span class="keyword">in</span> rights:</span><br><span class="line">                    node = TreeNode(i)</span><br><span class="line">                    node.left = left</span><br><span class="line">                    node.right = right</span><br><span class="line">                    res.append(node)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="96-不同的二叉搜索树-n"><a href="#96-不同的二叉搜索树-n" class="headerlink" title="96. 不同的二叉搜索树 [n]"></a>96. 不同的二叉搜索树 [n]</h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<p>示例:</p>
<pre>
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">0</span>, i):</span><br><span class="line">                dp[i] += dp[j] * dp[i - <span class="number">1</span> - j]<span class="comment">#减一是因为根节点</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h2><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>注意:</p>
<ul>
<li>你可以假设树中没有重复的元素。</li>
</ul>
<pre>
例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder, inorder</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> idx, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder):</span><br><span class="line">            m[v] = idx</span><br><span class="line">        <span class="keyword">return</span> self.helper(preorder, <span class="number">0</span>, <span class="built_in">len</span>(preorder) - <span class="number">1</span>, \</span><br><span class="line">            inorder, <span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>, m)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, preorder, pre_s, pre_e, inorder, in_s, in_e, m</span>):</span></span><br><span class="line">        <span class="keyword">if</span> pre_s &gt; pre_e <span class="keyword">or</span> in_s &gt; in_e:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root_v = preorder[pre_s]</span><br><span class="line">        root_idx = m[root_v]</span><br><span class="line">        left_len = root_idx - in_s</span><br><span class="line">        root = TreeNode(root_v)</span><br><span class="line">        root.left = self.helper(preorder, pre_s + <span class="number">1</span>, pre_s + left_len, \ </span><br><span class="line">            inorder, in_s, root_idx - <span class="number">1</span>, m)</span><br><span class="line">        root.right = self.helper(preorder, pre_s + left_len + <span class="number">1</span>, pre_e, \</span><br><span class="line">            inorder, root_idx + <span class="number">1</span>, in_e, m)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a>106. 从中序与后序遍历序列构造二叉树</h2><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:</p>
<ul>
<li>你可以假设树中没有重复的元素。</li>
</ul>
<pre>
例如，给出

中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder, postorder</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :type postorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> idx, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder):</span><br><span class="line">            m[v] = idx</span><br><span class="line">        <span class="keyword">return</span> self.helper(inorder, <span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>, \</span><br><span class="line">            postorder, <span class="number">0</span>, <span class="built_in">len</span>(postorder) - <span class="number">1</span>, m)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, inorder, in_left, in_right, postorder, post_left, post_right, m</span>):</span></span><br><span class="line">        <span class="keyword">if</span> in_left &gt; in_right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root_val = postorder[post_right]</span><br><span class="line">        root_idx = m[root_val]</span><br><span class="line">        left_len = root_idx - in_left</span><br><span class="line">        root = TreeNode(root_val)</span><br><span class="line">        root.left = self.helper(inorder, in_left, root_idx - <span class="number">1</span>, \</span><br><span class="line">            postorder, post_left, post_left + left_len - <span class="number">1</span>, m)</span><br><span class="line">        root.right = self.helper(inorder, root_idx + <span class="number">1</span>, in_right, \</span><br><span class="line">            postorder, post_left + left_len, post_right - <span class="number">1</span>, m)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a>114. 二叉树展开为链表</h2><p>给定一个二叉树，原地将它展开为链表。</p>
<pre>
例如，给定二叉树

    1
   / \
  2   5
 / \   \
3   4   6
将其展开为：

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        items = self.pre_order(root)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(items) - <span class="number">1</span>):</span><br><span class="line">            items[i].left = <span class="literal">None</span></span><br><span class="line">            items[i].right = items[i + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pre_order</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="comment"># 前序遍历</span></span><br><span class="line">        items = []</span><br><span class="line">        p = root</span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">or</span> stk:</span><br><span class="line">            <span class="keyword">while</span> p:</span><br><span class="line">                items.append(p)</span><br><span class="line">                stk.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">            node = stk.pop(-<span class="number">1</span>)</span><br><span class="line">            p = node.right</span><br><span class="line">        <span class="keyword">return</span> items</span><br></pre></td></tr></table></figure>

<h2 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a>117. 填充每个节点的下一个右侧节点指针 II</h2><p>给定一个二叉树</p>
<pre>
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
</pre>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            sz = <span class="built_in">len</span>(queue)</span><br><span class="line">            prev = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(sz):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> prev:</span><br><span class="line">                    prev.<span class="built_in">next</span> = node</span><br><span class="line">                prev = node</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="236-二叉树的最近公共祖先-n"><a href="#236-二叉树的最近公共祖先-n" class="headerlink" title="236. 二叉树的最近公共祖先 [n]"></a>236. 二叉树的最近公共祖先 [n]</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>示例 1:</p>
<pre>
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
</pre>
<p>示例 2:</p>
<pre>
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
</pre>

<p>说明:</p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">if</span> left <span class="keyword">else</span> right</span><br></pre></td></tr></table></figure>


<h2 id="331-验证二叉树的前序序列化-n"><a href="#331-验证二叉树的前序序列化-n" class="headerlink" title="331. 验证二叉树的前序序列化 [n]"></a>331. 验证二叉树的前序序列化 [n]</h2><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。</p>
<pre>
     _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #
</pre>
<p>例如，上面的二叉树可以被序列化为字符串 “9,3,4,#,#,1,#,#,2,#,6,#,#”，其中 # 代表一个空节点。</p>
<p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p>
<p>每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 ‘#’ 。</p>
<p>你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 “1,,3” 。</p>
<p>示例 1:</p>
<pre>
输入: "9,3,4,#,#,1,#,#,2,#,6,#,#"
输出: true
</pre>
<p>示例 2:</p>
<pre>
输入: "1,#"
输出: false
</pre>
<p>示例 3:</p>
<pre>
输入: "9,#,#,1"
输出: false
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSerialization</span>(<span class="params">self, preorder</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type preorder: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> preorder.split(<span class="string">&#x27;,&#x27;</span>):</span><br><span class="line">            stk.append(c)</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(stk) &gt;= <span class="number">3</span> <span class="keyword">and</span> stk[-<span class="number">2</span>:] == [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>] <span class="keyword">and</span> stk[-<span class="number">3</span>] != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                stk = stk[:-<span class="number">3</span>]</span><br><span class="line">                stk.append(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> stk == [<span class="string">&#x27;#&#x27;</span>] </span><br></pre></td></tr></table></figure>

<h2 id="337-打家劫舍-III-n"><a href="#337-打家劫舍-III-n" class="headerlink" title="337. 打家劫舍 III [n]"></a>337. 打家劫舍 III [n]</h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p>示例 1:</p>
<pre>
输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
</pre>
<p>示例 2:</p>
<pre>
输入: [3,4,5,1,3,null,1]

     3
    / \
   4   5
  / \   \ 
 1   3   1

输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> self.helper(root, m)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root, m</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">in</span> m:</span><br><span class="line">            <span class="keyword">return</span> m[root]</span><br><span class="line">        val = root.val</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            val += self.helper(root.left.left, m) + self.helper(root.left.right, m)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            val += self.helper(root.right.left, m) + self.helper(root.right.right, m)</span><br><span class="line">        res = <span class="built_in">max</span>(val, self.helper(root.left, m) + self.helper(root.right, m))</span><br><span class="line">        m[root] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a>437. 路径总和 III</h2><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p>
<p>找出路径和等于给定数值的路径总数。</p>
<p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>
<p>示例：</p>
<pre>
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1.  5 -> 3
2.  5 -> 2 -> 1
3.  -3 -> 11
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            self.dfs(node, target)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, root, target</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> root.val == target:</span><br><span class="line">            self.res += <span class="number">1</span></span><br><span class="line">        self.dfs(root.left, target - root.val)</span><br><span class="line">        self.dfs(root.right, target - root.val)</span><br></pre></td></tr></table></figure>

<h2 id="449-序列化和反序列化二叉搜索树"><a href="#449-序列化和反序列化二叉搜索树" class="headerlink" title="449. 序列化和反序列化二叉搜索树"></a>449. 序列化和反序列化二叉搜索树</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Encodes a tree to a single string.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stk, p = [], root</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stk <span class="keyword">or</span> p:</span><br><span class="line">            <span class="keyword">while</span> p:</span><br><span class="line">                res.append(p.val)</span><br><span class="line">                stk.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">            node = stk.pop(-<span class="number">1</span>)</span><br><span class="line">            p = node.right</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, res))</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        preorder = <span class="built_in">map</span>(<span class="built_in">int</span>, data.split())</span><br><span class="line">        inorder = <span class="built_in">sorted</span>(preorder)</span><br><span class="line">        <span class="keyword">return</span> self.build_tree(preorder, inorder)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_tree</span>(<span class="params">self, preorder, inorder</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root_v = preorder[<span class="number">0</span>]</span><br><span class="line">        idx = inorder.index(root_v)</span><br><span class="line">        root = TreeNode(root_v)</span><br><span class="line">        root.left = self.build_tree(preorder[<span class="number">1</span>:<span class="number">1</span>+idx], inorder[:idx])</span><br><span class="line">        root.right =self.build_tree(preorder[<span class="number">1</span>+idx:], inorder[idx+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="450-删除二叉搜索树中的节点-n"><a href="#450-删除二叉搜索树中的节点-n" class="headerlink" title="450. 删除二叉搜索树中的节点 [n]"></a>450. 删除二叉搜索树中的节点 [n]</h2><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<p>首先找到需要删除的节点；<br>如果找到了，删除它。<br>说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p>
<p>示例:</p>
<pre>
root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。

一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。

    5
   / \
  4   6
 /     \
2       7

另一个正确答案是 [5,2,6,null,4,null,7]。

    5
   / \
  2   6
   \   \
    4   7
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root, key</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> key &lt; root.val:</span><br><span class="line">            root.left = self.deleteNode(root.left, key)</span><br><span class="line">        <span class="keyword">elif</span> key &gt; root.val:</span><br><span class="line">            root.right = self.deleteNode(root.right, key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> root.right</span><br><span class="line">            <span class="keyword">elif</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = self.findMin(root.right)</span><br><span class="line">                root.val = node.val</span><br><span class="line">                root.right = self.deleteNode(root.right, node.val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">while</span> node.left:</span><br><span class="line">            node = node.left</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>

<h2 id="508-出现次数最多的子树元素和"><a href="#508-出现次数最多的子树元素和" class="headerlink" title="508. 出现次数最多的子树元素和"></a>508. 出现次数最多的子树元素和</h2><p>给出二叉树的根，找出出现次数最多的子树元素和。一个结点的子树元素和定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。然后求出出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的元素（不限顺序）。</p>
<p>示例 1</p>
<pre>
输入:

  5
 /  \
2   -3
返回 [2, -3, 4]，所有的值均只出现一次，以任意顺序返回所有值。
</pre>
<p>示例 2</p>
<pre>
输入:

  5
 /  \
2   -5
返回 [2]，只有 2 出现两次，-5 只出现 1 次。
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findFrequentTreeSum</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.m = &#123;&#125;</span><br><span class="line">        self.res = []</span><br><span class="line">        self.cnt = <span class="number">0</span></span><br><span class="line">        self.helper(root)</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.m.iteritems():</span><br><span class="line">            <span class="keyword">if</span> v == self.cnt:</span><br><span class="line">                self.res.append(k)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.helper(root.left)</span><br><span class="line">        right = self.helper(root.right)</span><br><span class="line">        cur_sum = left + right + root.val</span><br><span class="line">        <span class="keyword">if</span> cur_sum <span class="keyword">in</span> self.m:</span><br><span class="line">            self.m[cur_sum] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.m[cur_sum] = <span class="number">1</span></span><br><span class="line">        self.cnt = <span class="built_in">max</span>(self.cnt, self.m[cur_sum])</span><br><span class="line">        <span class="keyword">return</span> cur_sum</span><br></pre></td></tr></table></figure>

<h2 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a>538. 把二叉搜索树转换为累加树</h2><p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p>
<p>例如：</p>
<pre>
输入: 二叉搜索树:
              5
            /   \
           2     13

输出: 转换为累加树:
             18
            /   \
          20     13
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convertBST</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p = root </span><br><span class="line">        stk = []</span><br><span class="line">        prev = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">or</span> stk:</span><br><span class="line">            <span class="keyword">while</span> p:</span><br><span class="line">                stk.append(p)</span><br><span class="line">                p = p.right</span><br><span class="line">            node = stk.pop(-<span class="number">1</span>)</span><br><span class="line">            old_v = node.val</span><br><span class="line">            node.val += prev</span><br><span class="line">            prev += old_v</span><br><span class="line">            p = node.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="623-在二叉树中增加一行"><a href="#623-在二叉树中增加一行" class="headerlink" title="623. 在二叉树中增加一行"></a>623. 在二叉树中增加一行</h2><p>给定一个二叉树，根节点为第1层，深度为 1。在其第 d 层追加一行值为 v 的节点。</p>
<p>添加规则：给定一个深度值 d （正整数），针对深度为 d-1 层的每一非空节点 N，为 N 创建两个值为 v 的左子树和右子树。</p>
<p>将 N 原先的左子树，连接为新节点 v 的左子树；将 N 原先的右子树，连接为新节点 v 的右子树。</p>
<p>如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。</p>
<p>示例 1:</p>
<pre>
输入: 
二叉树如下所示:
       4
     /   \
    2     6
   / \   / 
  3   1 5   

v = 1

d = 2

输出: 
       4
      / \
     1   1
    /     \
   2       6
  / \     / 
 3   1   5   
</pre>
<p>示例 2:</p>
<pre>
输入: 
二叉树如下所示:
      4
     /   
    2    
   / \   
  3   1    

v = 1

d = 3

输出: 
      4
     /   
    2
   / \    
  1   1
 /     \  
3       1
</pre>
<p>注意:</p>
<ul>
<li>输入的深度值 d 的范围是：[1，二叉树最大深度 + 1]。</li>
<li>输入的二叉树至少有一个节点。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addOneRow</span>(<span class="params">self, root, v, d</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type v: int</span></span><br><span class="line"><span class="string">        :type d: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> d == <span class="number">1</span>:</span><br><span class="line">            new_root = TreeNode(v)</span><br><span class="line">            new_root.left = root</span><br><span class="line">            <span class="keyword">return</span> new_root</span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(d - <span class="number">2</span>):</span><br><span class="line">            sz = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(sz):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            tmp = node.left</span><br><span class="line">            new_node = TreeNode(v)</span><br><span class="line">            new_node.left = tmp</span><br><span class="line">            node.left = new_node</span><br><span class="line">            tmp = node.right</span><br><span class="line">            new_node = TreeNode(v)</span><br><span class="line">            new_node.right = tmp</span><br><span class="line">            node.right = new_node</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="652-寻找重复的子树-n"><a href="#652-寻找重复的子树-n" class="headerlink" title="652. 寻找重复的子树 [n]"></a>652. 寻找重复的子树 [n]</h2><p>给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。</p>
<p>两棵树重复是指它们具有相同的结构以及相同的结点值。</p>
<p>示例 1：</p>
<pre>
        1
       / \
      2   3
     /   / \
    4   2   4
       /
      4
下面是两个重复的子树：

      2
     /
    4
和

    4
因此，你需要以列表的形式返回上述重复子树的根结点。
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicateSubtrees</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[TreeNode]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m, res = &#123;&#125;, []</span><br><span class="line">        self.helper(root, m)</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> m.iteritems():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(v) &gt; <span class="number">1</span>:</span><br><span class="line">                res.append(v[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root, m</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        s = <span class="string">&quot;(&quot;</span> + self.helper(root.left, m) + <span class="built_in">str</span>(root.val) + \</span><br><span class="line">            self.helper(root.right, m) + <span class="string">&quot;)&quot;</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">in</span> m:</span><br><span class="line">            m[s].append(root)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            m[s] = [root]</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>

<h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a>654. 最大二叉树</h2><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p>
<ul>
<li>二叉树的根是数组中的最大元素。</li>
<li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li>
<li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li>
</ul>
<p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p>
<p>示例 ：</p>
<pre>
输入：[3,2,1,6,0,5]
输出：返回下面这棵树的根节点：

      6
    /   \
   3     5
    \    / 
     2  0   
       \
        1
</pre>

<p>提示：</p>
<ul>
<li>给定的数组的大小在 [1, 1000] 之间。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> idx, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            m[v] = idx</span><br><span class="line">        <span class="keyword">return</span> self.helper(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>, m)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, nums, left, right, m</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        max_v = <span class="built_in">max</span>(nums[left: right + <span class="number">1</span>])</span><br><span class="line">        max_idx = m[max_v]</span><br><span class="line">        root = TreeNode(max_v)</span><br><span class="line">        root.left = self.helper(nums, left, max_idx - <span class="number">1</span>, m)</span><br><span class="line">        root.right = self.helper(nums, max_idx + <span class="number">1</span>, right, m)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="655-输出二叉树-n"><a href="#655-输出二叉树-n" class="headerlink" title="655. 输出二叉树 [n]"></a>655. 输出二叉树 [n]</h2><p>在一个 m*n 的二维字符串数组中输出二叉树，并遵守以下规则：</p>
<ul>
<li>行数 m 应当等于给定二叉树的高度。</li>
<li>列数 n 应当总是奇数。</li>
<li>根节点的值（以字符串格式给出）应当放在可放置的第一行正中间。根节点所在的行与列会将剩余空间划分为两部分（左下部分和右下部分）。你应该将左子树输出在左下部分，右子树输出在右下部分。左下和右下部分应当有相同的大小。即使一个子树为空而另一个非空，你不需要为空的子树输出任何东西，但仍需要为另一个子树留出足够的空间。然而，如果两个子树都为空则不需要为它们留出任何空间。</li>
<li>每个未使用的空间应包含一个空的字符串””。</li>
<li>使用相同的规则输出子树。</li>
</ul>
<p>示例 1:</p>
<pre>
输入:
     1
    /
   2
输出:
[["", "1", ""],
 ["2", "", ""]]
</pre>
<p>示例 2:</p>
<pre>
输入:
     1
    / \
   2   3
    \
     4
输出:
[["", "", "", "1", "", "", ""],
 ["", "2", "", "", "", "3", ""],
 ["", "", "4", "", "", "", ""]]
</pre>
<p>示例 3:</p>
<pre>
输入:
      1
     / \
    2   5
   / 
  3 
 / 
4 
输出:
[["",  "",  "", "",  "", "", "", "1", "",  "",  "",  "",  "", "", ""]
 ["",  "",  "", "2", "", "", "", "",  "",  "",  "",  "5", "", "", ""]
 ["",  "3", "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]
 ["4", "",  "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]]
注意: 二叉树的高度在范围 [1, 10] 中。
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        height = self.getHeight(root)</span><br><span class="line">        width = (<span class="number">1</span> &lt;&lt; height) - <span class="number">1</span></span><br><span class="line">        res = [[<span class="string">&quot;&quot;</span>] * width <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(height)]</span><br><span class="line">        self.helper(root, <span class="number">0</span>, width - <span class="number">1</span>, <span class="number">0</span>, height, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root, left, right, h, height, res</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> h == height:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mid = (left + right) / <span class="number">2</span></span><br><span class="line">        res[h][mid] = <span class="built_in">str</span>(root.val)</span><br><span class="line">        self.helper(root.left, left, mid - <span class="number">1</span>, h + <span class="number">1</span>, height, res)</span><br><span class="line">        self.helper(root.right, mid + <span class="number">1</span>, right, h + <span class="number">1</span>, height, res)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHeight</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(self.getHeight(root.left), self.getHeight(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="687-最长同值路径-n"><a href="#687-最长同值路径-n" class="headerlink" title="687. 最长同值路径 [n]"></a>687. 最长同值路径 [n]</h2><p>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。</p>
<p>注意：两个节点之间的路径长度由它们之间的边数表示。</p>
<p>示例 1:</p>
<pre>
输入:

              5
             / \
            4   5
           / \   \
          1   1   5
输出:
2
</pre>
<p>示例 2:</p>
<pre>
输入:

              1
             / \
            4   5
           / \   \
          4   4   5
输出:

2
注意: 给定的二叉树不超过10000个结点。 树的高度不超过1000。
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestUnivaluePath</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.helper(root.left)</span><br><span class="line">        right = self.helper(root.right)</span><br><span class="line">        pl, pr = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">and</span> root.left.val == root.val:</span><br><span class="line">            pl = left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> root.right <span class="keyword">and</span> root.right.val == root.val:</span><br><span class="line">            pr = right + <span class="number">1</span></span><br><span class="line">        self.res = <span class="built_in">max</span>(self.res, pl + pr)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(pl, pr)</span><br></pre></td></tr></table></figure>

<h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a>701. 二叉搜索树中的插入操作</h2><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。</p>
<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p>
<p>例如, </p>
<pre>
给定二叉搜索树:

        4
       / \
      2   7
     / \
    1   3

和 插入的值: 5
你可以返回这个二叉搜索树:

         4
       /   \
      2     7
     / \   /
    1   3 5
或者这个树也是有效的:

         5
       /   \
      2     7
     / \   
    1   3
         \
          4
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">            root.left = self.insertIntoBST(root.left, val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root.right = self.insertIntoBST(root.right, val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="814-二叉树剪枝-n"><a href="#814-二叉树剪枝-n" class="headerlink" title="814. 二叉树剪枝 [n]"></a>814. 二叉树剪枝 [n]</h2><p>给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。</p>
<p>返回移除了所有不包含 1 的子树的原二叉树。</p>
<p>( 节点 X 的子树为 X 本身，以及所有 X 的后代。)</p>
<p>示例1:</p>
<pre>
输入: [1,null,0,0,1]
输出: [1,null,0,null,1]

解释: 
只有红色节点满足条件“所有不包含 1 的子树”。
右图为返回的答案。
</pre>

<p>示例2:</p>
<pre>
输入: [1,0,1,0,0,0,1]
输出: [1,null,1,null,1]
</pre>

<p>示例3:</p>
<pre>
输入: [1,1,0,1,1,0,1,0]
输出: [1,1,0,1,1,null,1]
</pre>
<p>说明:</p>
<ul>
<li>给定的二叉树最多有 100 个节点。</li>
<li>每个节点的值只会为 0 或 1 。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pruneTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root.left = self.pruneTree(root.left)</span><br><span class="line">        root.right = self.pruneTree(root.right)</span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.val == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="863-二叉树中所有距离为-K-的结点-n"><a href="#863-二叉树中所有距离为-K-的结点-n" class="headerlink" title="863. 二叉树中所有距离为 K 的结点 [n]"></a>863. 二叉树中所有距离为 K 的结点 [n]</h2><p>给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。</p>
<p>返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。</p>
<p>示例 1：</p>
<pre>
输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2

输出：[7,4,1]

解释：
所求结点为与目标结点（值为 5）距离为 2 的结点，
值分别为 7，4，以及 1
</pre>
<p>提示：</p>
<ul>
<li>给定的树是非空的，且最多有 K 个结点。</li>
<li>树上的每个结点都具有唯一的值 0 &lt;= node.val &lt;= 500 。</li>
<li>目标结点 target 是树上的结点。</li>
<li>0 &lt;= K &lt;= 1000.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distanceK</span>(<span class="params">self, root, target, K</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type target: TreeNode</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        self.helper(<span class="literal">None</span>, root, m)</span><br><span class="line"></span><br><span class="line">        queue = [target.val]</span><br><span class="line">        visited = <span class="built_in">set</span>([target.val])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(K):</span><br><span class="line">            sz = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(sz):</span><br><span class="line">                v = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> m[v]:</span><br><span class="line">                    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited.add(i)</span><br><span class="line">                        queue.append(i)</span><br><span class="line">        <span class="keyword">return</span> queue</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, parent, child, m</span>):</span></span><br><span class="line">        <span class="keyword">if</span> parent <span class="keyword">and</span> child:</span><br><span class="line">            m[child.val].append(parent.val)</span><br><span class="line">            m[parent.val].append(child.val)</span><br><span class="line">        <span class="keyword">if</span> child.left:</span><br><span class="line">            self.helper(child, child.left, m)</span><br><span class="line">        <span class="keyword">if</span> child.right:</span><br><span class="line">            self.helper(child, child.right, m)</span><br></pre></td></tr></table></figure>

<h2 id="865-具有所有最深结点的最小子树-n"><a href="#865-具有所有最深结点的最小子树-n" class="headerlink" title="865. 具有所有最深结点的最小子树 [n]"></a>865. 具有所有最深结点的最小子树 [n]</h2><p>给定一个根为 root 的二叉树，每个结点的深度是它到根的最短距离。</p>
<p>如果一个结点在整个树的任意结点之间具有最大的深度，则该结点是最深的。</p>
<p>一个结点的子树是该结点加上它的所有后代的集合。</p>
<p>返回能满足“以该结点为根的子树中包含所有最深的结点”这一条件的具有最大深度的结点。</p>
<p>示例：</p>
<pre>
输入：[3,5,1,6,2,0,8,null,null,7,4]
输出：[2,7,4]
解释：

我们返回值为 2 的结点，在图中用黄色标记。
在图中用蓝色标记的是树的最深的结点。
输入 "[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]" 是对给定的树的序列化表述。
输出 "[2, 7, 4]" 是对根结点的值为 2 的子树的序列化表述。
输入和输出都具有 TreeNode 类型。
</pre>

<p>提示：</p>
<ul>
<li>树中结点的数量介于 1 和 500 之间。</li>
<li>每个结点的值都是独一无二的。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtreeWithAllDeepest</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        depth, res = self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line">        left_pair = self.helper(root.left)</span><br><span class="line">        right_pair = self.helper(root.right)</span><br><span class="line">        dl, dr = left_pair[<span class="number">0</span>], right_pair[<span class="number">0</span>]</span><br><span class="line">        root_depth =  <span class="built_in">max</span>(dl, dr) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> dl == dr:</span><br><span class="line">            <span class="keyword">return</span> (root_depth, root)</span><br><span class="line">        <span class="keyword">return</span> (root_depth, left_pair[<span class="number">1</span>]) <span class="keyword">if</span> dl &gt; dr <span class="keyword">else</span> (root_depth, right_pair[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h2 id="894-所有可能的满二叉树-n"><a href="#894-所有可能的满二叉树-n" class="headerlink" title="894. 所有可能的满二叉树 [n]"></a>894. 所有可能的满二叉树 [n]</h2><p>满二叉树是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。</p>
<p>返回包含 N 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。</p>
<p>答案中每个树的每个结点都必须有 node.val=0。</p>
<p>你可以按任何顺序返回树的最终列表。</p>
<p>示例：</p>
<pre>
输入：7
输出：
[[0,0,0,null,null,0,0,null,null,0,0],
[0,0,0,null,null,0,0,0,0],
[0,0,0,0,0,0,0],
[0,0,0,0,0,null,null,null,null,0,0],
[0,0,0,0,0,null,null,0,0]]
</pre>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allPossibleFBT</span>(<span class="params">self, N</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: List[TreeNode]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> N % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [TreeNode(<span class="number">0</span>)]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, N, <span class="number">2</span>):</span><br><span class="line">            lefts = self.allPossibleFBT(i)</span><br><span class="line">            rights = self.allPossibleFBT(N - <span class="number">1</span> - i)</span><br><span class="line">            <span class="keyword">for</span> left <span class="keyword">in</span> lefts:</span><br><span class="line">                <span class="keyword">for</span> right <span class="keyword">in</span> rights:</span><br><span class="line">                    root = TreeNode(<span class="number">0</span>)</span><br><span class="line">                    root.left = left</span><br><span class="line">                    root.right = right</span><br><span class="line">                    res.append(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="951-翻转等价二叉树-n"><a href="#951-翻转等价二叉树-n" class="headerlink" title="951. 翻转等价二叉树 [n]"></a>951. 翻转等价二叉树 [n]</h2><p>我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。</p>
<p>只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转等价于二叉树 Y。</p>
<p>编写一个判断两个二叉树是否是翻转等价的函数。这些树由根节点 root1 和 root2 给出。</p>
<p>示例：</p>
<pre>
输入：root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]
输出：true
解释：We flipped at nodes with values 1, 3, and 5.
</pre>

<p>提示：</p>
<ul>
<li>每棵树最多有 100 个节点。</li>
<li>每棵树中的每个值都是唯一的、在 [0, 99] 范围内的整数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flipEquiv</span>(<span class="params">self, root1, root2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root1: TreeNode</span></span><br><span class="line"><span class="string">        :type root2: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root1 == root2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> root1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root2 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root1.val != root2.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        a = self.flipEquiv(root1.left, root2.left) <span class="keyword">and</span> \</span><br><span class="line">            self.flipEquiv(root1.right, root2.right) </span><br><span class="line">        b = self.flipEquiv(root1.left, root2.right) <span class="keyword">and</span> \</span><br><span class="line">            self.flipEquiv(root1.right, root2.left)</span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">or</span> b</span><br></pre></td></tr></table></figure>

<h2 id="958-二叉树的完全性检验"><a href="#958-二叉树的完全性检验" class="headerlink" title="958. 二叉树的完全性检验"></a>958. 二叉树的完全性检验</h2><p>给定一个二叉树，确定它是否是一个完全二叉树。</p>
<p>百度百科中对完全二叉树的定义如下：</p>
<p>若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isCompleteTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="971-翻转二叉树以匹配先序遍历-n"><a href="#971-翻转二叉树以匹配先序遍历-n" class="headerlink" title="971. 翻转二叉树以匹配先序遍历 [n]"></a>971. 翻转二叉树以匹配先序遍历 [n]</h2><p>给定一个有 N 个节点的二叉树，每个节点都有一个不同于其他节点且处于 {1, …, N} 中的值。</p>
<p>通过交换节点的左子节点和右子节点，可以翻转该二叉树中的节点。</p>
<p>考虑从根节点开始的先序遍历报告的 N 值序列。将这一 N 值序列称为树的行程。</p>
<p>（回想一下，节点的先序遍历意味着我们报告当前节点的值，然后先序遍历左子节点，再先序遍历右子节点。）</p>
<p>我们的目标是翻转最少的树中节点，以便树的行程与给定的行程 voyage 相匹配。 </p>
<p>如果可以，则返回翻转的所有节点的值的列表。你可以按任何顺序返回答案。</p>
<p>如果不能，则返回列表 [-1]。</p>
<p>示例 1：</p>
<pre>
输入：root = [1,2], voyage = [2,1]
输出：[-1]
</pre>
<p>示例 2：</p>
<pre>
输入：root = [1,2,3], voyage = [1,3,2]
输出：[1]
</pre>
<p>示例 3：</p>
<pre>
输入：root = [1,2,3], voyage = [1,2,3]
输出：[]
</pre>

<p>提示：</p>
<ul>
<li>1 &lt;= N &lt;= 100</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flipMatchVoyage</span>(<span class="params">self, root, voyage</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type voyage: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.pos, self.res = <span class="number">0</span>, []</span><br><span class="line">        self.dfs(root, voyage)</span><br><span class="line">        print(self.res)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, root, voyage</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> root.val != voyage[self.pos]:</span><br><span class="line">            self.res = [-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> self.res</span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">and</span> root.left.val != voyage[self.pos + <span class="number">1</span>]:</span><br><span class="line">            root.left, root.right = root.right, root.left</span><br><span class="line">            self.res.append(root.val)</span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        self.dfs(root.left, voyage)</span><br><span class="line">        self.dfs(root.right, voyage)</span><br></pre></td></tr></table></figure>


<h2 id="979-在二叉树中分配硬币-n"><a href="#979-在二叉树中分配硬币-n" class="headerlink" title="979. 在二叉树中分配硬币 [n]"></a>979. 在二叉树中分配硬币 [n]</h2><p>给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。</p>
<p>在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。</p>
<p>返回使每个结点上只有一枚硬币所需的移动次数。</p>
<p>示例 1：</p>
<pre>
输入：[3,0,0]
输出：2
解释：从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。
</pre>
<p>示例 2：</p>
<pre>
输入：[0,3,0]
输出：3
解释：从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。
</pre>
<p>示例 3：</p>
<pre>
输入：[1,0,2]
输出：2
</pre>
<p>示例 4：</p>
<pre>
输入：[1,0,0,null,3]
输出：4
</pre>

<p>提示：</p>
<ul>
<li>1&lt;= N &lt;= 100</li>
<li>0 &lt;= node.val &lt;= N</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distributeCoins</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.helper(root.left)</span><br><span class="line">        right = self.helper(root.right)</span><br><span class="line">        self.res += <span class="built_in">abs</span>(left) + <span class="built_in">abs</span>(right)</span><br><span class="line">        <span class="keyword">return</span> root.val - <span class="number">1</span> + left + right</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>剑指Offer选题题解</title>
    <url>/posts/3717340568.html</url>
    <content><![CDATA[<p>把剑指Offer的题过了一遍，在这里汇总一下。</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="/images/tech/jianzhioffer/banner.jpg" style="width:600px;height:300px;"/></div></div>

<a id="more"></a>

<h2 id="面试题07-重建二叉树"><a href="#面试题07-重建二叉树" class="headerlink" title="面试题07. 重建二叉树"></a>面试题07. 重建二叉树</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>例如，给出</p>
<pre>
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
</pre>

<p>限制：</p>
<ul>
<li>0 &lt;= 节点个数 &lt;= 5000</li>
</ul>
<div class="tabs" id="leetcode-07"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-07-1">Python</a></li><li class="tab"><a class="#leetcode-07-2">Cpp</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-07-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder, inorder</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> idx, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder):</span><br><span class="line">            m[v] = idx</span><br><span class="line">        <span class="keyword">return</span> self.helper(preorder, <span class="number">0</span>, <span class="built_in">len</span>(preorder) - <span class="number">1</span>, inorder, <span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>, m)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, preorder, pre_s, pre_e, inorder, in_s, in_e, m</span>):</span></span><br><span class="line">        <span class="keyword">if</span> pre_s &gt; pre_e <span class="keyword">or</span> in_s &gt; in_e:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root_v = preorder[pre_s]</span><br><span class="line">        root_idx = m[root_v]</span><br><span class="line">        left_len = root_idx - in_s</span><br><span class="line">        root = TreeNode(root_v)</span><br><span class="line">        root.left = self.helper(preorder, pre_s + <span class="number">1</span>, pre_s + left_len, inorder, in_s, root_idx - <span class="number">1</span>, m)</span><br><span class="line">        root.right = self.helper(preorder, pre_s + left_len + <span class="number">1</span>, pre_e, inorder, root_idx + <span class="number">1</span>, in_e, m)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-07-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;inorder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(preorder, <span class="number">0</span>, preorder.size() - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.size() - <span class="number">1</span>, m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;preorder, <span class="keyword">int</span> pLeft, <span class="keyword">int</span> pRight, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;inorder,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> iLeft, <span class="keyword">int</span> iRight, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pLeft &gt; pRight || iLeft &gt; iRight)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootV = preorder[pLeft];</span><br><span class="line">        <span class="keyword">int</span> rootIdx = m[rootV];</span><br><span class="line">        <span class="keyword">int</span> leftLen = rootIdx - iLeft;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(rootV);</span><br><span class="line">        root-&gt;left = helper(preorder, pLeft + <span class="number">1</span>, pLeft + leftLen, inorder, iLeft, rootIdx - <span class="number">1</span>, m);</span><br><span class="line">        root-&gt;right = helper(preorder, pLeft + leftLen + <span class="number">1</span>, pRight, inorder, rootIdx + <span class="number">1</span>, iRight, m);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="面试题11-旋转数组的最小数字"><a href="#面试题11-旋转数组的最小数字" class="headerlink" title="面试题11. 旋转数组的最小数字"></a>面试题11. 旋转数组的最小数字</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p>
<p>示例 1：</p>
<pre>
输入：[3,4,5,1,2]
输出：1
</pre>
<p>示例 2：</p>
<pre>
输入：[2,2,2,0,1]
输出：0
</pre>

<div class="tabs" id="leetcode-11"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-11-1">Python</a></li><li class="tab"><a class="#leetcode-11-2">Cpp</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-11-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minArray</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type numbers: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> numbers <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(numbers) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(numbers) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> numbers[mid] &lt; numbers[right]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">elif</span> numbers[mid] == numbers[right]:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> numbers[left]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-11-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;numbers)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = numbers.size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &lt; numbers[right])</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] == numbers[right])</span><br><span class="line">            &#123;</span><br><span class="line">                right -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="面试题14-I-剪绳子-n"><a href="#面试题14-I-剪绳子-n" class="headerlink" title="面试题14- I. 剪绳子 [n]"></a>面试题14- I. 剪绳子 [n]</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 k[0]<em>k[1]</em>…*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>示例 1：</p>
<pre>
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
</pre>
<p>示例 2:</p>
<pre>
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
</pre>
<p>提示：</p>
<ul>
<li>2 &lt;= n &lt;= 58</li>
</ul>
<div class="tabs" id="leetcode-14-1"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-14-1-1">Python</a></li><li class="tab"><a class="#leetcode-14-1-2">Cpp</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-14-1-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cache = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">return</span> self.helper(n, cache)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, n, cache</span>):</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cache[n] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> cache[n]</span><br><span class="line">        res = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            res = <span class="built_in">max</span>(res, i * (n - i), i * self.helper(n - i, cache))</span><br><span class="line">        cache[n] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-14-1-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cache</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> helper(n, cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;cache)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cache[n] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = max(i * (n - i), i * helper(n - i, cache));</span><br><span class="line">            res = max(res, v);</span><br><span class="line">        &#125;</span><br><span class="line">        cache[n] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="面试题19-正则表达式匹配-n"><a href="#面试题19-正则表达式匹配-n" class="headerlink" title="面试题19. 正则表达式匹配 [n]"></a>面试题19. 正则表达式匹配 [n]</h2><p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
<p>示例 1:</p>
<pre>
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
</pre>
<p>示例 2:</p>
<pre>
输入:
s = "aa"
p = "a*"
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
</pre>
<p>示例 3:</p>
<pre>
输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
</pre>
<p>示例 4:</p>
<pre>
输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
</pre>
<p>示例 5:</p>
<pre>
输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
</pre>

<ul>
<li>s 可能为空，且只包含从 a-z 的小写字母。</li>
<li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">self, s, p</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type p: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        first_match = <span class="built_in">bool</span>(s) <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> [s[<span class="number">0</span>], <span class="string">&#x27;.&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(p) &gt;= <span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> (self.isMatch(s, p[<span class="number">2</span>:])) <span class="keyword">or</span> (first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>

<h2 id="面试题26-树的子结构"><a href="#面试题26-树的子结构" class="headerlink" title="面试题26. 树的子结构"></a>面试题26. 树的子结构</h2><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p>例如:</p>
<pre>
给定的树 A:
     3
    / \
   4   5
  / \
 1   2
给定的树 B：

   4 
  /
 1
返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。
</pre>
<p>示例 1：</p>
<pre>
输入：A = [1,2,3], B = [3,1]
输出：false
</pre>
<p>示例 2：</p>
<pre>
输入：A = [3,4,5,1,2], B = [4,1]
输出：true
</pre>
<p>限制：</p>
<ul>
<li>0 &lt;= 节点个数 &lt;= 10000</li>
</ul>
<div class="tabs" id="leetcode-26"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-26-1">Python</a></li><li class="tab"><a class="#leetcode-26-2">Cpp</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-26-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span>(<span class="params">self, A, B</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type A: TreeNode</span></span><br><span class="line"><span class="string">        :type B: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> A <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> B <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(A, B) <span class="keyword">or</span> self.isSubStructure(A.left, B) <span class="keyword">or</span> self.isSubStructure(A.right, B)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, A, B</span>):</span></span><br><span class="line">        <span class="keyword">if</span> A <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> B <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> B <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> A.val != B.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(A.left, B.left) <span class="keyword">and</span> self.helper(A.right, B.right)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-26-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode *A, TreeNode *B)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">nullptr</span> || B == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(A, B) || isSubStructure(A-&gt;left, B) || isSubStructure(A-&gt;right, B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode *A, TreeNode *B)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">nullptr</span> || B == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> B == <span class="literal">nullptr</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (A-&gt;val != B-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(A-&gt;left, B-&gt;left) &amp;&amp; helper(A-&gt;right, B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="面试题27-二叉树的镜像"><a href="#面试题27-二叉树的镜像" class="headerlink" title="面试题27. 二叉树的镜像"></a>面试题27. 二叉树的镜像</h2><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>例如输入：</p>
<pre>
     4
   /   \
  2     7
 / \   / \
1   3 6   9
镜像输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1
</pre>
<p> </p>
<p>示例 1：</p>
<pre>
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
</pre>

<p>限制：</p>
<ul>
<li>0 &lt;= 节点个数 &lt;= 1000</li>
</ul>
<div class="tabs" id="leetcode-27"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-27-1">Python</a></li><li class="tab"><a class="#leetcode-27-2">Cpp</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-27-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            sz = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(sz):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                node.left, node.right = node.right, node.left</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-27-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">mirrorTree</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; treeQ;</span><br><span class="line">        treeQ.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!treeQ.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *node = treeQ.front();</span><br><span class="line">            treeQ.pop();</span><br><span class="line"></span><br><span class="line">            swap(node-&gt;left, node-&gt;right);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                treeQ.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                treeQ.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="面试题28-对称的二叉树"><a href="#面试题28-对称的二叉树" class="headerlink" title="面试题28. 对称的二叉树"></a>面试题28. 对称的二叉树</h2><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre>
    1
   / \
  2   2
 / \ / \
3  4 4  3
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    1
   / \
  2   2
   \   \
   3    3
</pre>
<p> </p>
<p>示例 1：</p>
<pre>
输入：root = [1,2,2,3,4,4,3]
输出：true
</pre>
<p>示例 2：</p>
<pre>
输入：root = [1,2,2,null,3,null,3]
输出：false
</pre>

<p>限制：</p>
<ul>
<li>0 &lt;= 节点个数 &lt;= 1000</li>
</ul>
<div class="tabs" id="leetcode-28"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-28-1">Python</a></li><li class="tab"><a class="#leetcode-28-2">Cpp</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-28-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(root, root)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, rootA, rootB</span>):</span></span><br><span class="line">        <span class="keyword">if</span> rootA <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> rootB <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> rootA <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> rootB <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> rootA.val != rootB.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(rootA.left, rootB.right) <span class="keyword">and</span> self.helper(rootA.right, rootB.left)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-28-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode *p, TreeNode *q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val != q-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(p-&gt;left, q-&gt;right) &amp;&amp; helper(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="面试题29-顺时针打印矩阵"><a href="#面试题29-顺时针打印矩阵" class="headerlink" title="面试题29. 顺时针打印矩阵"></a>面试题29. 顺时针打印矩阵</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>示例 1：</p>
<pre>
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
</pre>
<p>示例 2：</p>
<pre>
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
</pre>

<p>限制：</p>
<ul>
<li>0 &lt;= matrix.length &lt;= 100</li>
<li>0 &lt;= matrix[i].length &lt;= 100</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span>(<span class="params">self, matrix</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> matrix <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        res = []</span><br><span class="line">        top, bottom, left, right = <span class="number">0</span>, m - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(left, right + <span class="number">1</span>):</span><br><span class="line">                res.append(matrix[top][i])</span><br><span class="line">            top += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> top &gt; bottom:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(top, bottom + <span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][right])</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right &lt; left:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(right, left - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[bottom][i])</span><br><span class="line">            bottom -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> bottom &lt; top:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(bottom, top - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][left])</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="面试题33-二叉搜索树的后序遍历序列"><a href="#面试题33-二叉搜索树的后序遍历序列" class="headerlink" title="面试题33. 二叉搜索树的后序遍历序列"></a>面试题33. 二叉搜索树的后序遍历序列</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p>
<p>参考以下这颗二叉搜索树：</p>
<pre>
     5
    / \
   2   6
  / \
 1   3
</pre>
<p>示例 1：</p>
<pre>
输入: [1,6,3,2,5]
输出: false
</pre>
<p>示例 2：</p>
<pre>
输入: [1,3,2,6,5]
输出: true
</pre>

<p>提示：</p>
<ul>
<li>数组长度 &lt;= 1000</li>
</ul>
<div class="tabs" id="leetcode-33"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-33-1">Python</a></li><li class="tab"><a class="#leetcode-33-2">Cpp</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-33-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span>(<span class="params">self, postorder</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type postorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(postorder)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(postorder, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, postorder, left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        root_v = postorder[right]</span><br><span class="line">        i = left</span><br><span class="line">        <span class="keyword">while</span> postorder[i] &lt; root_v:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i, right):</span><br><span class="line">            <span class="keyword">if</span> postorder[j] &lt;= root_v:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(postorder, left, i - <span class="number">1</span>) <span class="keyword">and</span> self.helper(postorder, i, right - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-33-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;postorder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(postorder, <span class="number">0</span>, postorder.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;postorder, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootV = postorder[right];</span><br><span class="line">        <span class="keyword">int</span> left_end = left;</span><br><span class="line">        <span class="keyword">while</span> (left_end &lt; right &amp;&amp; postorder[left_end] &lt; rootV)</span><br><span class="line">        &#123;</span><br><span class="line">            left_end += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left_end; i &lt; right; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (postorder[i] &lt;= rootV)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(postorder, left, left_end - <span class="number">1</span>) &amp;&amp; helper(postorder, left_end, right - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="面试题36-二叉搜索树与双向链表-n"><a href="#面试题36-二叉搜索树与双向链表-n" class="headerlink" title="面试题36. 二叉搜索树与双向链表 [n]"></a>面试题36. 二叉搜索树与双向链表 [n]</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<div class="tabs" id="leetcode-36"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-36-1">Python</a></li><li class="tab"><a class="#leetcode-36-2">Cpp</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-36-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.tail = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        self.inorder(root)</span><br><span class="line">        self.head.left = self.tail</span><br><span class="line">        self.tail.right = self.head</span><br><span class="line">        <span class="keyword">return</span> self.head</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inorder(root.left)</span><br><span class="line">        <span class="keyword">if</span> self.prev <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.head = root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.prev.right = root</span><br><span class="line">        root.left = self.prev</span><br><span class="line">        self.prev = root</span><br><span class="line">        self.tail = root</span><br><span class="line">        self.inorder(root.right)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-36-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node *<span class="title">treeToDoublyList</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root);</span><br><span class="line">        _head-&gt;left = _tail;</span><br><span class="line">        _tail-&gt;right = _head;</span><br><span class="line">        <span class="keyword">return</span> _head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (_prev == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _head = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _prev-&gt;right = root;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left = _prev;</span><br><span class="line">        _prev = root;</span><br><span class="line">        _tail = root;</span><br><span class="line">        inorder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node *_head, *_tail, *_prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="面试题37-序列化二叉树-n"><a href="#面试题37-序列化二叉树-n" class="headerlink" title="面试题37. 序列化二叉树 [n]"></a>面试题37. 序列化二叉树 [n]</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p>示例: </p>
<pre>
你可以将以下二叉树：

    1
   / \
  2   3
     / \
    4   5

序列化为 "[1,2,3,null,null,4,5]"
</pre>

<div class="tabs" id="leetcode-37"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-37-1">Python</a></li><li class="tab"><a class="#leetcode-37-2">Cpp</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-37-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Encodes a tree to a single string.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                res.append(<span class="string">&#x27;null&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="built_in">str</span>(root.val))</span><br><span class="line">                preorder(root.left)</span><br><span class="line">                preorder(root.right)</span><br><span class="line">        preorder(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;,&#x27;</span>.join(res)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = data.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>():</span></span><br><span class="line">            <span class="keyword">if</span> res:</span><br><span class="line">                val = res.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> val == <span class="string">&#x27;null&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">                root = TreeNode(<span class="built_in">int</span>(val))</span><br><span class="line">                root.left = buildTree()</span><br><span class="line">                root.right = buildTree()</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> buildTree()</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-37-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        tree2str(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tree2str</span><span class="params">(TreeNode *root, <span class="built_in">string</span> &amp;res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res += <span class="string">&quot;# &quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += <span class="built_in">std</span>::to_string(root-&gt;val) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        tree2str(root-&gt;left, res);</span><br><span class="line">        tree2str(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode *<span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> str2tree(data, idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">str2tree</span><span class="params">(<span class="built_in">string</span> data, <span class="keyword">int</span> &amp;idx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == data.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> endIdx = idx;</span><br><span class="line">        <span class="keyword">while</span> (data[endIdx] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            endIdx += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data[idx] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            idx = endIdx + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> sign = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(data[idx] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            idx = idx + <span class="number">1</span>;</span><br><span class="line">            sign = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; endIdx; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            val = val * <span class="number">10</span> + (data[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        val = sign ? -val:val;</span><br><span class="line">        idx = endIdx + <span class="number">1</span>;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        root-&gt;left = str2tree(data, idx);</span><br><span class="line">        root-&gt;right = str2tree(data, idx);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="面试题44-数字序列中某一位的数字"><a href="#面试题44-数字序列中某一位的数字" class="headerlink" title="面试题44. 数字序列中某一位的数字"></a>面试题44. 数字序列中某一位的数字</h2><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p>
<p>请写一个函数，求任意第n位对应的数字。</p>
<p>示例 1：</p>
<pre>
输入：n = 3
输出：3
</pre>
<p>示例 2：</p>
<pre>
输入：n = 11
输出：0
</pre>

<p>限制：</p>
<ul>
<li>0 &lt;= n &lt; 2^31</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNthDigit</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        _len = <span class="number">1</span></span><br><span class="line">        cnt = <span class="number">9</span></span><br><span class="line">        start = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; _len * cnt:</span><br><span class="line">            n -= _len * cnt</span><br><span class="line">            _len += <span class="number">1</span></span><br><span class="line">            cnt *= <span class="number">10</span></span><br><span class="line">            start *= <span class="number">10</span></span><br><span class="line">        start += (n - <span class="number">1</span>) / _len</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">str</span>(start)[(n - <span class="number">1</span>) % _len])</span><br></pre></td></tr></table></figure>

<h2 id="面试题46-把数字翻译成字符串-n"><a href="#面试题46-把数字翻译成字符串-n" class="headerlink" title="面试题46. 把数字翻译成字符串 [n]"></a>面试题46. 把数字翻译成字符串 [n]</h2><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p>示例 1:</p>
<pre>
输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
</pre>

<p>提示：</p>
<ul>
<li>0 &lt;= num &lt; 231</li>
</ul>
<div class="tabs" id="leetcode-46"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-46-1">Python</a></li><li class="tab"><a class="#leetcode-46-2">Cpp</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-46-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">translateNum</span>(<span class="params">self, num</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        num_str = <span class="built_in">str</span>(num)</span><br><span class="line">        slen = <span class="built_in">len</span>(num_str)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> xrange(slen + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>, slen + <span class="number">1</span>):</span><br><span class="line">            a = num_str[i - <span class="number">2</span>:i]</span><br><span class="line">            b = num_str[i - <span class="number">1</span>:i]</span><br><span class="line">            <span class="keyword">if</span> <span class="number">10</span> &lt;= <span class="built_in">int</span>(a) &lt;= <span class="number">25</span>:</span><br><span class="line">                dp[i] += dp[i - <span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= <span class="built_in">int</span>(b) &lt;= <span class="number">9</span>:</span><br><span class="line">                dp[i] += dp[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[slen]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-46-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> num_str = <span class="built_in">std</span>::to_string(num);</span><br><span class="line">        <span class="keyword">int</span> sLen = num_str.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(sLen + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= sLen; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> a = num_str.substr(i - <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">string</span> b = num_str.substr(i - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> m = <span class="built_in">std</span>::stoi(a);</span><br><span class="line">            <span class="keyword">int</span> n = <span class="built_in">std</span>::stoi(b);</span><br><span class="line">            <span class="keyword">if</span> (m &gt;= <span class="number">10</span> &amp;&amp; m &lt;= <span class="number">25</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">0</span> &amp;&amp; n &lt;= <span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] += dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sLen];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="面试题49-丑数"><a href="#面试题49-丑数" class="headerlink" title="面试题49. 丑数"></a>面试题49. 丑数</h2><p>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<p>示例:</p>
<pre>
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
</pre>
<p>说明:  </p>
<ul>
<li>1 是丑数。</li>
<li>n 不超过1690。</li>
</ul>
<div class="tabs" id="leetcode-49"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-49-1">Python</a></li><li class="tab"><a class="#leetcode-49-2">Cpp</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-49-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        i2, i3, i5 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            min_v = <span class="built_in">min</span>(dp[i2] * <span class="number">2</span>, dp[i3] * <span class="number">3</span>, dp[i5] * <span class="number">5</span>)</span><br><span class="line">            dp[i] = min_v</span><br><span class="line">            <span class="keyword">if</span> min_v == dp[i2] * <span class="number">2</span>:</span><br><span class="line">                i2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> min_v == dp[i3] * <span class="number">3</span>:</span><br><span class="line">                i3 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> min_v == dp[i5] * <span class="number">5</span>:</span><br><span class="line">                i5 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-49-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">0</span>, i3 = <span class="number">0</span>, i5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> min_v = min(min(dp[i2] * <span class="number">2</span>, dp[i3] * <span class="number">3</span>), dp[i5] * <span class="number">5</span>);</span><br><span class="line">            dp[i] = min_v;</span><br><span class="line">            <span class="keyword">if</span> (min_v == dp[i2] * <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i2 += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (min_v == dp[i3] * <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i3 += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (min_v == dp[i5] * <span class="number">5</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i5 += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="面试题56-II-数组中数字出现的次数-n"><a href="#面试题56-II-数组中数字出现的次数-n" class="headerlink" title="面试题56 - II. 数组中数字出现的次数 [n]"></a>面试题56 - II. 数组中数字出现的次数 [n]</h2><p>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<p>示例 1：</p>
<pre>
输入：nums = [3,4,3,3]
输出：4
</pre>
<p>示例 2：</p>
<pre>
输入：nums = [9,1,7,9,7,9,7]
输出：1
</pre>

<p>限制：</p>
<ul>
<li>1 &lt;= nums.length &lt;= 10000</li>
<li>1 &lt;= nums[i] &lt; 2^31</li>
</ul>
<div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-1">Python</a></li><li class="tab"><a class="#leetcode-2">Cpp</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            cnt = <span class="number">0</span>  <span class="comment"># 记录当前 bit 有多少个1</span></span><br><span class="line">            bit = <span class="number">1</span> &lt;&lt; i  <span class="comment"># 记录当前要操作的 bit</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> num &amp; bit != <span class="number">0</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt % <span class="number">3</span> != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 不等于0说明唯一出现的数字在这个 bit 上是1</span></span><br><span class="line">                res |= bit</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res - <span class="number">2</span> ** <span class="number">32</span> <span class="keyword">if</span> res &gt; <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span> <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((n &amp; bit) != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    cnt += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt % <span class="number">3</span> != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res |= bit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="面试题57-II-和为s的连续正数序列-n"><a href="#面试题57-II-和为s的连续正数序列-n" class="headerlink" title="面试题57 - II. 和为s的连续正数序列 [n]"></a>面试题57 - II. 和为s的连续正数序列 [n]</h2><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<p>示例 1：</p>
<pre>
输入：target = 9
输出：[[2,3,4],[4,5]]
</pre>
<p>示例 2：</p>
<pre>
输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]
</pre>

<p>限制：</p>
<ul>
<li>1 &lt;= target &lt;= 10^5</li>
</ul>
<div class="tabs" id="leetcode-57"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-57-1">Python</a></li><li class="tab"><a class="#leetcode-57-2">Cpp</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-57-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContinuousSequence</span>(<span class="params">self, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left, right, total = <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        flag = (target + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> right &lt;= flag:</span><br><span class="line">            <span class="keyword">if</span> total == target:</span><br><span class="line">                res.append([i <span class="keyword">for</span> i <span class="keyword">in</span> xrange(left, right + <span class="number">1</span>)])</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">                total += right</span><br><span class="line">            <span class="keyword">elif</span> total &lt; target:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">                total += right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                total -= left</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-57-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findContinuousSequence</span><span class="params">(<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">0</span>, total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = (target + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt;= flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (total == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; item;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    item.push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(item);</span><br><span class="line">                right += <span class="number">1</span>;</span><br><span class="line">                total += right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (total &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                right += <span class="number">1</span>;</span><br><span class="line">                total += right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                total -= left;</span><br><span class="line">                left += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="面试题59-I-滑动窗口的最大值-n"><a href="#面试题59-I-滑动窗口的最大值-n" class="headerlink" title="面试题59 - I. 滑动窗口的最大值 [n]"></a>面试题59 - I. 滑动窗口的最大值 [n]</h2><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p>
<p>示例:</p>
<pre>
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
</pre>

<p>提示：</p>
<ul>
<li>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dq = deque()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">while</span> dq <span class="keyword">and</span> dq[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">                dq.popleft()</span><br><span class="line">            <span class="keyword">while</span> dq <span class="keyword">and</span> v &gt; nums[dq[-<span class="number">1</span>]]:</span><br><span class="line">                dq.pop()</span><br><span class="line">            dq.append(i)</span><br><span class="line">            <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">                res.append(nums[dq[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="面试题62-圆圈中最后剩下的数字-n"><a href="#面试题62-圆圈中最后剩下的数字-n" class="headerlink" title="面试题62. 圆圈中最后剩下的数字 [n]"></a>面试题62. 圆圈中最后剩下的数字 [n]</h2><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p>示例 1：</p>
<pre>
输入: n = 5, m = 3
输出: 3
</pre>
<p>示例 2：</p>
<pre>
输入: n = 10, m = 17
输出: 2
</pre>

<p>限制：</p>
<ul>
<li>1 &lt;= n &lt;= 10^5</li>
<li>1 &lt;= m &lt;= 10^6</li>
</ul>
<div class="tabs" id="leetcode-62"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-62-1">Python</a></li><li class="tab"><a class="#leetcode-62-2">Cpp</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-62-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastRemaining</span>(<span class="params">self, n, m</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums = [i <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        c = (m - <span class="number">1</span>) % n</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(nums) != <span class="number">1</span>:</span><br><span class="line">            nums.pop(c)</span><br><span class="line">            c = (c + m - <span class="number">1</span>) % <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-62-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            last = (last + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="面试题68-II-二叉树的最近公共祖先"><a href="#面试题68-II-二叉树的最近公共祖先" class="headerlink" title="面试题68 - II. 二叉树的最近公共祖先"></a>面试题68 - II. 二叉树的最近公共祖先</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<div class="tabs" id="leetcode-68"><ul class="nav-tabs"><li class="tab active"><a class="#leetcode-68-1">Python</a></li><li class="tab"><a class="#leetcode-68-2">Cpp</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-68-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">if</span> left <span class="keyword">else</span> right</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-68-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">lowestCommonAncestor</span><span class="params">(TreeNode *root, TreeNode *p, TreeNode *q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span> || root == p || root == q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode *right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left &amp;&amp; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="literal">nullptr</span> ? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></div></div>





]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
</search>
