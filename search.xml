<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode之哈希表</title>
    <url>/posts/2d8b42bd.html</url>
    <content><![CDATA[<p>哈希表的题目汇总在此了，欢迎大家光顾。</p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<img src="/images/leetcode/hash.jpg" width = 600px height = 300px/>

<a id="more"></a>

<h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><p>编写一个算法来判断一个数是不是“快乐数”。</p>
<p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p>
<p>示例: </p>
<pre>
输入: 19
输出: true
解释: 
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            n = <span class="built_in">str</span>(<span class="built_in">sum</span>([<span class="built_in">int</span>(i) ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>(n)]))</span><br><span class="line">            <span class="keyword">if</span> n == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> m:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            m[n] = <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290. 单词规律"></a>290. 单词规律</h2><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</p>
<p>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p>
<p>示例1:</p>
<pre>
输入: pattern = "abba", str = "dog cat cat dog"
输出: true
</pre>
<p>示例 2:</p>
<pre>
输入:pattern = "abba", str = "dog cat cat fish"
输出: false
</pre>
<p>示例 3:</p>
<pre>
输入: pattern = "aaaa", str = "dog cat cat dog"
输出: false
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordPattern</span>(<span class="params">self, pattern, <span class="built_in">str</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type pattern: str</span></span><br><span class="line"><span class="string">        :type str: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(pattern) == self.helper(<span class="built_in">str</span>.split(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, s_list</span>):</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> s_list:</span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> m:</span><br><span class="line">                m[s] = <span class="built_in">len</span>(m) + <span class="number">1</span></span><br><span class="line">            res.append(m[s])</span><br><span class="line">        ss = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> res])</span><br><span class="line">        <span class="keyword">return</span> ss</span><br></pre></td></tr></table></figure>

<h2 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a>409. 最长回文串</h2><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p>
<p>在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。</p>
<p>注意:<br>假设字符串的长度不会超过 1010。</p>
<p>示例 1:</p>
<pre>
输入:
"abccccdd"

输出:
7

解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> m:</span><br><span class="line">                m[c] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m[c] = <span class="number">1</span></span><br><span class="line">        max_odd = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        has_odd = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> m.iteritems():</span><br><span class="line">            <span class="keyword">if</span> v % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                res += v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += v - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> has_odd:</span><br><span class="line">                    has_odd = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">1</span> <span class="keyword">if</span> has_odd <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure>

<h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. 找到字符串中所有字母异位词</h2><p>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p>
<p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p>
<p>说明：</p>
<ul>
<li>字母异位词指字母相同，但排列不同的字符串。</li>
<li>不考虑答案输出的顺序。</li>
</ul>
<p>示例 1:</p>
<pre>
输入:
s: "cbaebabacd" p: "abc"

输出:
[0, 6]

解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词。
</pre>
<p>示例 2:</p>
<pre>
输入:
s: "abab" p: "ab"

输出:
[0, 1, 2]

解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的字母异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的字母异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的字母异位词。
</pre>

<div class="tabs" id="leetcode438"><ul class="nav-tabs"><li class="tab active"><a href="#leetcode438-1">Python</a></li><li class="tab"><a href="#leetcode438-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode438-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span>(<span class="params">self, s, p</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type p: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ls, lp = <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line">        cp = self.get_counter(p)</span><br><span class="line">        cs = &#123;&#125;</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ls):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> cs:</span><br><span class="line">                cs[s[i]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cs[s[i]] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= lp:</span><br><span class="line">                cs[s[i - lp]] -= <span class="number">1</span> <span class="comment"># start前一个元素</span></span><br><span class="line">                <span class="keyword">if</span> cs[s[i - lp]] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> cs[s[i - lp]]</span><br><span class="line">            <span class="keyword">if</span> cs == cp:</span><br><span class="line">                <span class="comment"># 因为end - start + 1 = len; 所以 start = end + 1 - len</span></span><br><span class="line">                ans.append(i - lp + <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_counter</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> m:</span><br><span class="line">                m[c] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m[c] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode438-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s.isEmpty() || p.length() &gt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">int</span>[] hashS = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span>[] hashP = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">            hashP[p.charAt(i)]++;</span><br><span class="line">            hashS[s.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isSameDict(hashS, hashP)) &#123;</span><br><span class="line">            res.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p.length(); i &lt; s.length(); i++) &#123;</span><br><span class="line">            hashS[s.charAt(i - p.length())]--;</span><br><span class="line">            hashS[s.charAt(i)]++;</span><br><span class="line">            <span class="keyword">if</span> (isSameDict(hashS, hashP)) &#123;</span><br><span class="line">                res.add(i + <span class="number">1</span> - p.length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSameDict</span><span class="params">(<span class="keyword">int</span>[] hashS, <span class="keyword">int</span>[] hashP)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hashS.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashP[i] != hashS[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="454-四数相加-II-n"><a href="#454-四数相加-II-n" class="headerlink" title="454. 四数相加 II[n]"></a>454. 四数相加 II[n]</h2><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</p>
<p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。</p>
<p>例如:</p>
<pre>
输入:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

输出:
2

解释:
两个元组如下:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
</pre>


<div class="tabs" id="leetcode454"><ul class="nav-tabs"><li class="tab active"><a href="#leetcode454-1">Python</a></li><li class="tab"><a href="#leetcode454-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode454-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSumCount</span>(<span class="params">self, A, B, C, D</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type B: List[int]</span></span><br><span class="line"><span class="string">        :type C: List[int]</span></span><br><span class="line"><span class="string">        :type D: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="built_in">len</span>(B)):</span><br><span class="line">                tmp = A[i] + B[j]</span><br><span class="line">                <span class="keyword">if</span> tmp <span class="keyword">in</span> m:</span><br><span class="line">                    m[tmp] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    m[tmp] = <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(C)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="built_in">len</span>(D)):</span><br><span class="line">                tmp = <span class="number">0</span> - (C[i] + D[j])</span><br><span class="line">                <span class="keyword">if</span> tmp <span class="keyword">in</span> m:</span><br><span class="line">                    res += m[tmp]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode454-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; counter = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = A[i] + B[j];</span><br><span class="line">                counter.put(tmp, counter.getOrDefault(tmp, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; D.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = C[i] + D[j];</span><br><span class="line">                <span class="keyword">if</span> (counter.containsKey(-tmp)) &#123;</span><br><span class="line">                    res += counter.get(-tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="525-连续数组"><a href="#525-连续数组" class="headerlink" title="525. 连续数组"></a>525. 连续数组</h2><p>给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。</p>
<p>示例 1:</p>
<pre>
输入: [0,1]
输出: 2
说明: [0, 1] 是具有相同数量0和1的最长连续子数组。
</pre>
<p>示例 2:</p>
<pre>
输入: [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。
</pre>
<p>注意: 给定的二进制数组的长度不会超过50000。</p>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxLength</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;<span class="number">0</span>:-<span class="number">1</span>&#125;</span><br><span class="line">        res, cnt = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            cnt = cnt + <span class="number">1</span> <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">else</span> cnt - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt <span class="keyword">in</span> m:</span><br><span class="line">                res = <span class="built_in">max</span>(res, i - m[cnt])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m[cnt] = i</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="560-和为K的子数组-n"><a href="#560-和为K的子数组-n" class="headerlink" title="560. 和为K的子数组 [n]"></a>560. 和为K的子数组 [n]</h2><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p>
<p>示例 1 :</p>
<pre>
输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
</pre>
<p>说明 :</p>
<ul>
<li>数组的长度为 [1, 20,000]。</li>
<li>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res, cur_sum, pre_sum_map = <span class="number">0</span>, <span class="number">0</span>, &#123;<span class="number">0</span>:<span class="number">1</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            cur_sum += n</span><br><span class="line">            <span class="keyword">if</span> cur_sum - k <span class="keyword">in</span> pre_sum_map:</span><br><span class="line">                res += pre_sum_map[cur_sum - k]</span><br><span class="line">            <span class="keyword">if</span> cur_sum <span class="keyword">in</span> pre_sum_map:</span><br><span class="line">                pre_sum_map[cur_sum] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre_sum_map[cur_sum] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="594-最长和谐子序列-n"><a href="#594-最长和谐子序列-n" class="headerlink" title="594. 最长和谐子序列 [n]"></a>594. 最长和谐子序列 [n]</h2><p>和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。</p>
<p>现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。</p>
<p>示例 1:</p>
<pre>
输入: [1,3,2,2,5,2,3,7]
输出: 5
原因: 最长的和谐数组是：[3,2,2,2,3].
</pre>
<p>说明: 输入的数组长度最大不超过20,000.</p>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLHS</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> m:</span><br><span class="line">                m[n] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m[n] = <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">set</span>(nums):</span><br><span class="line">            a, b = n - <span class="number">1</span>, n + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">in</span> m:</span><br><span class="line">                res = <span class="built_in">max</span>(res, m[a] + m[n])</span><br><span class="line">            <span class="keyword">if</span> b <span class="keyword">in</span> m:</span><br><span class="line">                res = <span class="built_in">max</span>(res, m[b] + m[n])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="648-单词替换-n"><a href="#648-单词替换-n" class="headerlink" title="648. 单词替换 [n]"></a>648. 单词替换 [n]</h2><p>在英语中，我们有一个叫做 词根(root)的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。</p>
<p>现在，给定一个由许多词根组成的词典和一个句子。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。</p>
<p>你需要输出替换之后的句子。</p>
<p>示例 1:</p>
<pre>
输入: dict(词典) = ["cat", "bat", "rat"]
sentence(句子) = "the cattle was rattled by the battery"
输出: "the cat was rat by the bat"
</pre>
<p>注:</p>
<ul>
<li>输入只包含小写字母。</li>
<li>1 &lt;= 字典单词数 &lt;=1000</li>
<li>1 &lt;=  句中词语数 &lt;= 1000</li>
<li>1 &lt;= 词根长度 &lt;= 100</li>
<li>1 &lt;= 句中词语长度 &lt;= 1000</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceWords</span>(<span class="params">self, words, sentence</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :type sentence: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        wordset = <span class="built_in">set</span>(words)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> sentence.split(<span class="string">&#x27; &#x27;</span>):</span><br><span class="line">            res.append(self.replaceWord(word, wordset))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(res)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceWord</span>(<span class="params">self, word, wordset</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(word)):</span><br><span class="line">            <span class="keyword">if</span> word[:i] <span class="keyword">in</span> wordset:</span><br><span class="line">                <span class="keyword">return</span> word[:i]</span><br><span class="line">        <span class="keyword">return</span> word</span><br></pre></td></tr></table></figure>

<h2 id="720-词典中最长的单词-n"><a href="#720-词典中最长的单词-n" class="headerlink" title="720. 词典中最长的单词 [n]"></a>720. 词典中最长的单词 [n]</h2><p>给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。</p>
<p>若无答案，则返回空字符串。</p>
<p>示例 1:</p>
<pre>
输入: 
words = ["w","wo","wor","worl", "world"]
输出: "world"
解释: 
单词"world"可由"w", "wo", "wor", 和 "worl"添加一个字母组成。
</pre>
<p>示例 2:</p>
<pre>
输入: 
words = ["a", "banana", "app", "appl", "ap", "apply", "apple"]
输出: "apple"
解释: 
"apply"和"apple"都能由词典中的单词组成。但是"apple"得字典序小于"apply"。
</pre>
<p>注意:</p>
<ul>
<li>所有输入的字符串都只包含小写字母。</li>
<li>words数组长度范围为[1,1000]。</li>
<li>words[i]的长度范围为[1,30]。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestWord</span>(<span class="params">self, words</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        words = <span class="built_in">sorted</span>(words)</span><br><span class="line">        word_set = <span class="built_in">set</span>([<span class="string">&#x27;&#x27;</span>])<span class="comment"># 巧妙之处</span></span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> word[:-<span class="number">1</span>] <span class="keyword">in</span> word_set:</span><br><span class="line">                word_set.add(word)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(word) &gt; <span class="built_in">len</span>(res):</span><br><span class="line">                    res = word</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode之二叉树(简单)</title>
    <url>/posts/94def828.html</url>
    <content><![CDATA[<p>二叉树(简单)的题目汇总在此了，欢迎大家光顾。</p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<img src="/images/leetcode/bst.jpg" width = 600px height = 300px/>

<a id="more"></a>

<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre>
    1
   / \
  2   2
 / \ / \
3  4 4  3
</pre>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<pre>
    1
   / \
  2   2
   \   \
   3    3
</pre>


<div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><a href="#leetcode-1">Python(BFS)</a></li><li class="tab"><a href="#leetcode-2">Python(递归)</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        queue = [root, root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            t1 = queue.pop(<span class="number">0</span>)</span><br><span class="line">            t2 = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> t1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> t2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> t1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> t2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> t1.val != t2.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            queue.append(t1.left)</span><br><span class="line">            queue.append(t2.right)</span><br><span class="line">            queue.append(t1.right)</span><br><span class="line">            queue.append(t2.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-2"><figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.isMirror(root, root)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMirror</span>(<span class="params">self, p, q</span>):</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> q <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> q <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> self.isMirror(p.left, q.right) \</span><br><span class="line">         <span class="keyword">and</span> self.isMirror(p.right, q.left)</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a>110. 平衡二叉树</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
<p>示例 1:</p>
<pre>
给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7
返回 true 。
</pre>
<p>示例 2:</p>
<pre>
给定二叉树 [1,2,2,3,3,null,null,4,4]

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
返回 false 。
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(root) != -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_height = self.helper(root.left)</span><br><span class="line">        <span class="keyword">if</span> left_height == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        right_height = self.helper(root.right)</span><br><span class="line">        <span class="keyword">if</span> right_height == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(left_height - right_height) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(left_height, right_height)</span><br></pre></td></tr></table></figure>

<h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a>111. 二叉树的最小深度</h2><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:</p>
<pre>
给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回它的最小深度  2.
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">            level += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> level</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br></pre></td></tr></table></figure>

<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h2><p>翻转一棵二叉树。</p>
<p>示例：</p>
<pre>
输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9
输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            node.left, node.right = node.right, node.left</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h2><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:</p>
<p>输入:</p>
<pre>
   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        item, res = [], []</span><br><span class="line">        self.dfs(root, item, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, root, item, res</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            tmp = item[:] + [<span class="built_in">str</span>(root.val)]</span><br><span class="line">            res.append(<span class="string">&#x27;-&gt;&#x27;</span>.join(tmp))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dfs(root.left, item + [<span class="built_in">str</span>(root.val)], res)</span><br><span class="line">        self.dfs(root.right, item + [<span class="built_in">str</span>(root.val)], res)</span><br></pre></td></tr></table></figure>

<h2 id="501-二叉搜索树中的众数-n"><a href="#501-二叉搜索树中的众数-n" class="headerlink" title="501. 二叉搜索树中的众数 [n]"></a>501. 二叉搜索树中的众数 [n]</h2><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>
<p>假定 BST 有如下定义：</p>
<ul>
<li>结点左子树中所含结点的值小于等于当前结点的值</li>
<li>结点右子树中所含结点的值大于等于当前结点的值</li>
<li>左子树和右子树都是二叉搜索树</li>
</ul>
<pre>
例如：
给定 BST [1,null,2,2],

   1
    \
     2
    /
   2

返回[2].
</pre>

<p>提示：如果众数超过1个，不需考虑输出顺序</p>
<p>进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMode</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        self.max_count = <span class="number">0</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.helper(root.left)</span><br><span class="line">        <span class="keyword">if</span> self.prev <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> self.prev.val == root.val:</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.count = <span class="number">1</span></span><br><span class="line">        self.prev = root</span><br><span class="line">        <span class="keyword">if</span> self.count == self.max_count:</span><br><span class="line">            self.res.append(self.prev.val)</span><br><span class="line">        <span class="keyword">if</span> self.count &gt; self.max_count:</span><br><span class="line">            self.max_count = self.count</span><br><span class="line">            self.res = [self.prev.val]</span><br><span class="line">        self.helper(root.right)</span><br></pre></td></tr></table></figure>

<h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a>543. 二叉树的直径</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。</p>
<p>示例 :</p>
<pre>
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
</pre>
<p>注意：两结点之间的路径长度是以它们之间边的数目表示。</p>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.ans = <span class="number">1</span></span><br><span class="line">        self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.helper(root.left)</span><br><span class="line">        right = self.helper(root.right)</span><br><span class="line">        self.ans = <span class="built_in">max</span>(self.ans, left + right + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="563-二叉树的坡度"><a href="#563-二叉树的坡度" class="headerlink" title="563. 二叉树的坡度"></a>563. 二叉树的坡度</h2><p>给定一个二叉树，计算整个树的坡度。</p>
<p>一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。</p>
<p>整个树的坡度就是其所有节点的坡度之和。</p>
<p>示例:</p>
<pre>
输入: 
         1
       /   \
      2     3
输出: 1
解释: 
结点的坡度 2 : 0
结点的坡度 3 : 0
结点的坡度 1 : |2-3| = 1
树的坡度 : 0 + 0 + 1 = 1
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTilt</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        L = self.helper(root.left)</span><br><span class="line">        R = self.helper(root.right)</span><br><span class="line">        self.res += <span class="built_in">abs</span>(L - R)</span><br><span class="line">        <span class="keyword">return</span> L + R + root.val</span><br></pre></td></tr></table></figure>

<h2 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572. 另一个树的子树"></a>572. 另一个树的子树</h2><p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p>
<p>示例 1:</p>
<pre>
给定的树 s:

     3
    / \
   4   5
  / \
 1   2
给定的树 t：

   4 
  / \
 1   2
返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。
</pre>
<p>示例 2:</p>
<pre>
给定的树 s：

     3
    / \
   4   5
  / \
 1   2
    /
   0
给定的树 t：

   4
  / \
 1   2
返回 false。
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubtree</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: TreeNode</span></span><br><span class="line"><span class="string">        :type t: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        queue = [s]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> self.isSameTree(node, t):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> t <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> t <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> s.val != t.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isSameTree(s.left, t.left) \</span><br><span class="line">            <span class="keyword">and</span> self.isSameTree(s.right, t.right)</span><br></pre></td></tr></table></figure>

<h2 id="606-根据二叉树创建字符串-n"><a href="#606-根据二叉树创建字符串-n" class="headerlink" title="606. 根据二叉树创建字符串 [n]"></a>606. 根据二叉树创建字符串 [n]</h2><p>你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。</p>
<p>空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p>
<p>示例 1:</p>
<pre>
输入: 二叉树: [1,2,3,4]
       1
     /   \
    2     3
   /    
  4     

输出: "1(2(4))(3)"

解释: 原本将是“1(2(4)())(3())”，
在你省略所有不必要的空括号对之后，
它将是“1(2(4))(3)”。
</pre>
<p>示例 2:</p>
<pre>
输入: 二叉树: [1,2,3,null,4]
       1
     /   \
    2     3
     \  
      4 

输出: "1(2()(4))(3)"

解释: 和第一个示例相似，
除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tree2str</span>(<span class="params">self, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type t: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> t <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> t.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> t.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">str</span>(t.val)</span><br><span class="line">        left = <span class="string">&#x27;()&#x27;</span> <span class="keyword">if</span> t.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="string">&#x27;(&#x27;</span> + self.tree2str(t.left) + <span class="string">&#x27;)&#x27;</span></span><br><span class="line">        right = <span class="string">&#x27;&#x27;</span> <span class="keyword">if</span> t.right <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="string">&#x27;(&#x27;</span> + self.tree2str(t.right) + <span class="string">&#x27;)&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(t.val) + left + right</span><br></pre></td></tr></table></figure>

<h2 id="897-递增顺序查找树"><a href="#897-递增顺序查找树" class="headerlink" title="897. 递增顺序查找树"></a>897. 递增顺序查找树</h2><p>给定一个树，按中序遍历重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。</p>
<p>示例 ：</p>
<pre>
输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]

       5
      / \
    3    6
   / \    \
  2   4    8
 /        / \ 
1        7   9

输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]

 1
  \
   2
    \
     3
      \
       4
        \
         5
          \
           6
            \
             7
              \
               8
                \
                 9  
</pre>

<p>提示：</p>
<ul>
<li>给定树中的结点数介于 1 和 100 之间。</li>
<li>每个结点都有一个从 0 到 1000 范围内的唯一整数值。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increasingBST</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = self.inorder(root)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(res) - <span class="number">1</span>):</span><br><span class="line">            res[i].right = res[i + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        res = []</span><br><span class="line">        p = root</span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">or</span> stk:</span><br><span class="line">            <span class="keyword">while</span> p:</span><br><span class="line">                stk.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">            node = stk.pop(-<span class="number">1</span>)</span><br><span class="line">            node.left = <span class="literal">None</span></span><br><span class="line">            res.append(node)</span><br><span class="line">            p = node.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="993-二叉树的堂兄弟节点"><a href="#993-二叉树的堂兄弟节点" class="headerlink" title="993. 二叉树的堂兄弟节点"></a>993. 二叉树的堂兄弟节点</h2><p>在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。</p>
<p>如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。</p>
<p>我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。</p>
<p>只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。</p>
<p>示例 1：</p>
<pre>
输入：root = [1,2,3,4], x = 4, y = 3
输出：false
</pre>
<p>示例 2：</p>
<pre>
输入：root = [1,2,3,null,4,null,5], x = 5, y = 4
输出：true
</pre>
<p>示例 3：</p>
<pre>
输入：root = [1,2,3,null,4], x = 2, y = 3
输出：false
</pre>

<p>提示：</p>
<ul>
<li>二叉树的节点数介于 2 到 100 之间。</li>
<li>每个节点的值都是唯一的、范围为 1 到 100 的整数。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isCousins</span>(<span class="params">self, root, x, y</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :type y: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        queue = [(root, <span class="literal">None</span>)]</span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            sz = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(sz):</span><br><span class="line">                node, parent = queue.pop(<span class="number">0</span>)</span><br><span class="line">                m[node.val] = (parent, depth)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append((node.left, node))</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append((node.right, node))</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        px, dx = m[x]</span><br><span class="line">        py, dy = m[y]</span><br><span class="line">        <span class="keyword">return</span> px != py <span class="keyword">and</span> dx == dy</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode之字符串(简单)</title>
    <url>/posts/c026ad95.html</url>
    <content><![CDATA[<p>字符串(简单)的题目汇总在此了，欢迎大家光顾。</p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<img src="/images/leetcode/string.png" width = 600px height = 300px/>

<a id="more"></a>

<h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 “”。</p>
<p>示例 1:</p>
<pre>
输入: ["flower","flow","flight"]
输出: "fl"
</pre>
<p>示例 2:</p>
<pre>
输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
</pre>
<p>说明:</p>
<ul>
<li>所有输入只包含小写字母 a-z 。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> strs <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(strs) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(strs[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="built_in">len</span>(strs)):</span><br><span class="line">                <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(strs[j]) <span class="keyword">or</span> strs[j][i] != c:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">            res += c</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h2 id="443-压缩字符串"><a href="#443-压缩字符串" class="headerlink" title="443. 压缩字符串"></a>443. 压缩字符串</h2><p>给定一组字符，使用原地算法将其压缩。</p>
<p>压缩后的长度必须始终小于或等于原数组长度。</p>
<p>数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。</p>
<p>在完成原地修改输入数组后，返回数组的新长度。</p>
<p>进阶：</p>
<p>你能否仅使用O(1) 空间解决问题？</p>
<p>示例 1：</p>
<pre>
输入：
["a","a","b","b","c","c","c"]
输出：
返回6，输入数组的前6个字符应该是：["a","2","b","2","c","3"]
说明：
"aa"被"a2"替代。"bb"被"b2"替代。"ccc"被"c3"替代。
</pre>
<p>示例 2：</p>
<pre>
输入：
["a"]
输出：
返回1，输入数组的前1个字符应该是：["a"]
说明：
没有任何字符串被替代。
</pre>
<p>示例 3：</p>
<pre>
输入：
["a","b","b","b","b","b","b","b","b","b","b","b","b"]
输出：
返回4，输入数组的前4个字符应该是：["a","b","1","2"]。
说明：
由于字符"a"不重复，所以不会被压缩。"bbbbbbbbbbbb"被“b12”替代。
</pre>
<p>注意每个数字在数组中都有它自己的位置。</p>
<p>注意：</p>
<ul>
<li>所有字符都有一个ASCII值在[35, 126]区间内。</li>
<li>1 &lt;= len(chars) &lt;= 1000。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compress</span>(<span class="params">self, chars</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type chars: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(chars):</span><br><span class="line">            c, cnt = chars[i], <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(chars) <span class="keyword">and</span> chars[i] == c:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="number">1</span>:</span><br><span class="line">                res.append(c)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(c)</span><br><span class="line">                res.extend([c <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">str</span>(cnt)])</span><br><span class="line">        <span class="keyword">for</span> idx, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(res):</span><br><span class="line">            chars[idx] = c</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(res)</span><br></pre></td></tr></table></figure>

<h2 id="680-验证回文字符串-Ⅱ"><a href="#680-验证回文字符串-Ⅱ" class="headerlink" title="680. 验证回文字符串 Ⅱ"></a>680. 验证回文字符串 Ⅱ</h2><p>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p>
<p>示例 1:</p>
<pre>
输入: "aba"
输出: True
</pre>
<p>示例 2:</p>
<pre>
输入: "abca"
输出: True
解释: 你可以删除c字符。
</pre>
<p>注意:</p>
<ul>
<li>字符串只包含从 a-z 的小写字母。字符串的最大长度是50000</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= j:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> self.isPalindrome(s, i + <span class="number">1</span>, j) <span class="keyword">or</span> self.isPalindrome(s, i, j - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s, i, j</span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; j:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="696-计数二进制子串-n"><a href="#696-计数二进制子串-n" class="headerlink" title="696. 计数二进制子串 [n]"></a>696. 计数二进制子串 [n]</h2><p>给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。</p>
<p>重复出现的子串要计算它们出现的次数。</p>
<p>示例 1 :</p>
<pre>
输入: "00110011"
输出: 6
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。
请注意，一些重复出现的子串要计算它们出现的次数。
另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
</pre>
<p>示例 2 :</p>
<pre>
输入: "10101"
输出: 4
解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
</pre>
<p>注意：</p>
<ul>
<li>s.length 在1到50,000之间。</li>
<li>s 只包含“0”或“1”字符。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBinarySubstrings</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = pre = <span class="number">0</span></span><br><span class="line">        cur = <span class="number">1</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[i - <span class="number">1</span>]:</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pre &gt;= cur:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="788-旋转数字"><a href="#788-旋转数字" class="headerlink" title="788. 旋转数字"></a>788. 旋转数字</h2><p>我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。</p>
<p>如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。</p>
<p>现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？</p>
<p>示例:</p>
<pre>
输入: 10
输出: 4
解释: 
在[1, 10]中有四个好数： 2, 5, 6, 9。
注意 1 和 10 不是好数, 因为他们在旋转之后不变。
</pre>
<p>注意:</p>
<ul>
<li>N 的取值范围是 [1, 10000]。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotatedDigits</span>(<span class="params">self, N</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> self.isGoodNum(i):</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isGoodNum</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">any</span>(x <span class="keyword">in</span> <span class="built_in">str</span>(n) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;7&#x27;</span>]):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">any</span>(x <span class="keyword">in</span> <span class="built_in">str</span>(n) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;9&#x27;</span>]):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="859-亲密字符串"><a href="#859-亲密字符串" class="headerlink" title="859. 亲密字符串"></a>859. 亲密字符串</h2><p>给定两个由小写字母构成的字符串 A 和 B ，只要我们可以通过交换 A 中的两个字母得到与 B 相等的结果，就返回 true ；否则返回 false 。</p>
<p>示例 1：</p>
<pre>
输入： A = "ab", B = "ba"
输出： true
</pre>
<p>示例 2：</p>
<pre>
输入： A = "ab", B = "ab"
输出： false
</pre>
<p>示例 3:</p>
<pre>
输入： A = "aa", B = "aa"
输出： true
</pre>
<p>示例 4：</p>
<pre>
输入： A = "aaaaaaabc", B = "aaaaaaacb"
输出： true
</pre>
<p>示例 5：</p>
<pre>
输入： A = "", B = "aa"
输出： false
</pre>

<p>提示：</p>
<ul>
<li>0 &lt;= A.length &lt;= 20000</li>
<li>0 &lt;= B.length &lt;= 20000</li>
<li>A 和 B 仅由小写字母构成。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buddyStrings</span>(<span class="params">self, A, B</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(A) != <span class="built_in">len</span>(B): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> A == B:</span><br><span class="line">            seen = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> a <span class="keyword">in</span> A:</span><br><span class="line">                <span class="keyword">if</span> a <span class="keyword">in</span> seen:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                seen.add(a)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pairs = []</span><br><span class="line">            <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(A, B):</span><br><span class="line">                <span class="keyword">if</span> a != b:</span><br><span class="line">                    pairs.append((a, b))</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(pairs) &gt; <span class="number">2</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(pairs) == <span class="number">2</span> <span class="keyword">and</span> pairs[<span class="number">0</span>] == pairs[<span class="number">1</span>][::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="925-长按键入"><a href="#925-长按键入" class="headerlink" title="925. 长按键入"></a>925. 长按键入</h2><p>你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。</p>
<p>你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。</p>
<p>示例 1：</p>
<pre>
输入：name = "alex", typed = "aaleex"
输出：true
解释：'alex' 中的 'a' 和 'e' 被长按。
</pre>
<p>示例 2：</p>
<pre>
输入：name = "saeed", typed = "ssaaedd"
输出：false
解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。
</pre>
<p>示例 3：</p>
<pre>
输入：name = "leelee", typed = "lleeelee"
输出：true
</pre>
<p>示例 4：</p>
<pre>
输入：name = "laiden", typed = "laiden"
输出：true
解释：长按名字中的字符并不是必要的。
</pre>

<p>提示：</p>
<ul>
<li>name.length &lt;= 1000</li>
<li>typed.length &lt;= 1000</li>
<li>name 和 typed 的字符都是小写字母。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isLongPressedName</span>(<span class="params">self, name, typed</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type name: str</span></span><br><span class="line"><span class="string">        :type typed: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        a = self.getHelper(name)</span><br><span class="line">        b = self.getHelper(typed)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="built_in">len</span>(b):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="built_in">len</span>(a), <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> a[idx] != b[idx]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> a[idx + <span class="number">1</span>] &gt; b[idx + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHelper</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        res = []</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> idx &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            cur_c, cnt = s[idx], <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> idx &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[idx] == cur_c:</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            res.append(cur_c)</span><br><span class="line">            res.append(cnt)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode之链表</title>
    <url>/posts/fb43e507.html</url>
    <content><![CDATA[<p>链表的题目汇总在此了，欢迎大家光顾。</p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<img src="/images/leetcode/linkedlist.png" width = 600px height = 300px/>

<a id="more"></a>

<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例:</p>
<pre>
给定 1->2->3->4, 你应该返回 2->1->4->3.
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        r = dummy</span><br><span class="line">        p, q = head, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">and</span> q:</span><br><span class="line">            r.<span class="built_in">next</span> = q</span><br><span class="line">            p.<span class="built_in">next</span> = q.<span class="built_in">next</span></span><br><span class="line">            q.<span class="built_in">next</span> = p</span><br><span class="line">            r = p</span><br><span class="line">            p = r.<span class="built_in">next</span></span><br><span class="line">            q = p.<span class="built_in">next</span> <span class="keyword">if</span> p <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        r = dummy.<span class="built_in">next</span></span><br><span class="line">        dummy.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>

<h2 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a>82. 删除排序链表中的重复元素 II</h2><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p>
<p>示例 1:</p>
<pre>
输入: 1->2->3->3->4->4->5
输出: 1->2->5
</pre>
<p>示例 2:</p>
<pre>
输入: 1->1->1->2->3
输出: 2->3
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        p, cur = dummy, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            cnt = <span class="number">1</span></span><br><span class="line">            v = cur.val</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.val == v:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="number">1</span>:</span><br><span class="line">                p.<span class="built_in">next</span> = cur</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        p = dummy.<span class="built_in">next</span></span><br><span class="line">        dummy.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>

<h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h2><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<p>说明:</p>
<ul>
<li>1 ≤ m ≤ n ≤ 链表长度。</li>
</ul>
<p>示例:</p>
<pre>
输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
</pre>

<figure class="highlight java"><figcaption><span>Java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode prev = dummy, cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (step &lt; m - <span class="number">1</span>) &#123;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            step += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - m; i++) &#123;</span><br><span class="line">            ListNode removed = cur.next;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line"></span><br><span class="line">            removed.next = prev.next;</span><br><span class="line">            prev.next = removed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode newHead = dummy.next;</span><br><span class="line">        dummy.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a>109. 有序链表转换二叉搜索树</h2><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<p>示例:</p>
<pre>
给定的有序链表： [-10, -3, 0, 5, 9],

一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
</pre>

<div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><a href="#leetcode-1">Python</a></li><li class="tab"><a href="#leetcode-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.buildTree(head, <span class="literal">None</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, head, tail</span>):</span></span><br><span class="line">        <span class="keyword">if</span> head == tail:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fast = slow = head</span><br><span class="line">        <span class="keyword">while</span> fast != tail <span class="keyword">and</span> fast.<span class="built_in">next</span> != tail:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        root = TreeNode(slow.val)</span><br><span class="line">        root.left = self.buildTree(head, slow)</span><br><span class="line">        root.right = self.buildTree(slow.<span class="built_in">next</span>, tail)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(head, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(ListNode head, ListNode tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != tail &amp;&amp; fast.next != tail) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">        root.left = buildTree(head, slow);</span><br><span class="line">        root.right = buildTree(slow.next, tail);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>说明：不允许修改给定的链表。</p>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        fast, slow = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> fast <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fast = head</span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>

<h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a>143. 重排链表</h2><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例 1:</p>
<pre>
给定链表 1->2->3->4, 重新排列为 1->4->2->3.
</pre>
<p>示例 2:</p>
<pre>
给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify head in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        fast, slow = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            prev = slow</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        prev.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        slow = self.reverseList(slow)</span><br><span class="line"></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> slow <span class="keyword">and</span> head:</span><br><span class="line">            ts, th = slow.<span class="built_in">next</span>, head.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = head</span><br><span class="line">            p.<span class="built_in">next</span>.<span class="built_in">next</span> = slow</span><br><span class="line">            slow = ts</span><br><span class="line">            head = th</span><br><span class="line">            p = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = slow <span class="keyword">if</span> slow <span class="keyword">else</span> head</span><br><span class="line"></span><br><span class="line">        p = dummy.<span class="built_in">next</span></span><br><span class="line">        dummy.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        p, q = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            r = q.<span class="built_in">next</span></span><br><span class="line">            q.<span class="built_in">next</span> = p</span><br><span class="line">            p = q</span><br><span class="line">            q = r</span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>

<h2 id="147-对链表进行插入排序-n"><a href="#147-对链表进行插入排序-n" class="headerlink" title="147. 对链表进行插入排序 [n]"></a>147. 对链表进行插入排序 [n]</h2><figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSortList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="keyword">while</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> head.val &lt;= head.<span class="built_in">next</span>.val:</span><br><span class="line">                head = head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = head.<span class="built_in">next</span></span><br><span class="line">                head.<span class="built_in">next</span> = tmp.<span class="built_in">next</span></span><br><span class="line">                q = dummy</span><br><span class="line">                <span class="keyword">while</span> q.<span class="built_in">next</span> <span class="keyword">and</span> q.<span class="built_in">next</span>.val &lt;= tmp.val:</span><br><span class="line">                    q = q.<span class="built_in">next</span></span><br><span class="line">                tmp.<span class="built_in">next</span> = q.<span class="built_in">next</span></span><br><span class="line">                q.<span class="built_in">next</span> = tmp</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a>148. 排序链表</h2><p>merge sort</p>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        prev, fast, slow = <span class="literal">None</span>, head, head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            prev = slow</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        prev.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        head = self.sortList(head)</span><br><span class="line">        slow = self.sortList(slow)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.merge(head, slow)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, l1, l2</span>):</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                p.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">        p = dummy.<span class="built_in">next</span></span><br><span class="line">        dummy.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>

<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a>234. 回文链表</h2><p>请判断一个链表是否为回文链表。</p>
<p>示例 1:</p>
<pre>
输入: 1->2
输出: false
</pre>
<p>示例 2:</p>
<pre>
输入: 1->2->2->1
输出: true
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        mid = self.get_mid_node(head)</span><br><span class="line">        mid = self.reverse_list(mid)</span><br><span class="line">        <span class="keyword">while</span> mid:</span><br><span class="line">            <span class="keyword">if</span> mid.val != head.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            mid = mid.<span class="built_in">next</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_mid_node</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_list</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        p, q = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            r = q.<span class="built_in">next</span></span><br><span class="line">            q.<span class="built_in">next</span> = p</span><br><span class="line">            p = q</span><br><span class="line">            q = r</span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>

<h2 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a>328. 奇偶链表</h2><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<p>示例 1:</p>
<pre>
输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
</pre>
<p>示例 2:</p>
<pre>
输入: 2->1->3->5->6->4->7->NULL 
输出: 2->3->6->7->1->5->4->NULL
</pre>
<p>说明:</p>
<ul>
<li>应当保持奇数节点和偶数节点的相对顺序。</li>
<li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        new_head_p, new_head_q = head, head.<span class="built_in">next</span></span><br><span class="line">        p, q = head, head.<span class="built_in">next</span></span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            next_p = q.<span class="built_in">next</span> <span class="keyword">if</span> q <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            next_q = next_p.<span class="built_in">next</span> <span class="keyword">if</span> next_p <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            p.<span class="built_in">next</span> = next_p</span><br><span class="line">            <span class="keyword">if</span> q:</span><br><span class="line">                q.<span class="built_in">next</span> = next_q</span><br><span class="line">            prev = p</span><br><span class="line">            p = next_p</span><br><span class="line">            q = next_q</span><br><span class="line"></span><br><span class="line">        prev.<span class="built_in">next</span> = new_head_q</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> new_head_p</span><br></pre></td></tr></table></figure>


<h2 id="430-扁平化多级双向链表-n"><a href="#430-扁平化多级双向链表-n" class="headerlink" title="430. 扁平化多级双向链表 [n]"></a>430. 扁平化多级双向链表 [n]</h2><p>您将获得一个双向链表，除了下一个和前一个指针之外，它还有一个子指针，可能指向单独的双向链表。这些子列表可能有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p>
<p>扁平化列表，使所有结点出现在单级双链表中。您将获得列表第一级的头部。</p>
<p>示例:</p>
<pre>
输入:
 1---2---3---4---5---6--NULL
         |
         7---8---9---10--NULL
             |
             11--12--NULL

输出:
1-2-3-7-8-11-12-9-10-4-5-6-NULL
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.dfs(head)</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.child:</span><br><span class="line">                <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = cur.child</span><br><span class="line">                cur.<span class="built_in">next</span>.prev = cur</span><br><span class="line">                child_last = self.dfs(cur.child)</span><br><span class="line">                child_last.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">next</span>:</span><br><span class="line">                    <span class="built_in">next</span>.prev = child_last</span><br><span class="line">                cur.child = <span class="literal">None</span></span><br><span class="line">            head = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

<h2 id="1019-链表中的下一个更大节点"><a href="#1019-链表中的下一个更大节点" class="headerlink" title="1019. 链表中的下一个更大节点"></a>1019. 链表中的下一个更大节点</h2><p>给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, … 。</p>
<p>每个节点都可能有下一个更大值（next larger value）：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j &gt; i 且  node_j.val &gt; node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。</p>
<p>返回整数答案数组 answer，其中 answer[i] = next_larger(node_{i+1}) 。</p>
<p>注意：在下面的示例中，诸如 [2,1,5] 这样的输入（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。</p>
<p>示例 1：</p>
<pre>
输入：[2,1,5]
输出：[5,5,0]
</pre>
<p>示例 2：</p>
<pre>
输入：[2,7,4,3,5]
输出：[7,0,5,5,0]
</pre>
<p>示例 3：</p>
<pre>
输入：[1,7,5,1,9,2,5,1]
输出：[7,9,9,9,0,5,0,0]
</pre>

<p>提示：</p>
<ul>
<li>对于链表中的每个节点，1 &lt;= node.val &lt;= 10^9</li>
<li>给定列表的长度在 [0, 10000] 范围内</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextLargerNodes</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            nums.append(head.val)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        res = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> nums[stk[-<span class="number">1</span>]] &lt; v:</span><br><span class="line">                res[stk.pop()] = v</span><br><span class="line">            stk.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="1171-从链表中删去总和值为零的连续节点-n"><a href="#1171-从链表中删去总和值为零的连续节点-n" class="headerlink" title="1171. 从链表中删去总和值为零的连续节点 [n]"></a>1171. 从链表中删去总和值为零的连续节点 [n]</h2><p>给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。</p>
<p>删除完毕后，请你返回最终结果链表的头节点。</p>
<p>你可以返回任何满足题目要求的答案。</p>
<p>（注意，下面示例中的所有序列，都是对 ListNode 对象序列化的表示。）</p>
<p>示例 1：</p>
<pre>
输入：head = [1,2,-3,3,1]
输出：[3,1]
提示：答案 [1,2,1] 也是正确的。
</pre>
<p>示例 2：</p>
<pre>
输入：head = [1,2,3,-3,4]
输出：[1,2,4]
</pre>
<p>示例 3：</p>
<pre>
输入：head = [1,2,3,-3,-2]
输出：[1]
</pre>

<p>提示：</p>
<ul>
<li>给你的链表中可能有 1 到 1000 个节点。</li>
<li>对于链表中的每个节点，节点的值：-1000 &lt;= node.val &lt;= 1000.</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeZeroSumSublists</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line"></span><br><span class="line">        p = dummy</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            total += p.val</span><br><span class="line">            m[total] = p</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            total += p.val</span><br><span class="line">            p.<span class="built_in">next</span> = m[total].<span class="built_in">next</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        p = dummy.<span class="built_in">next</span> </span><br><span class="line">        dummy.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode刷题指南(持续更新中)</title>
    <url>/posts/af9ea9dd.html</url>
    <content><![CDATA[<p>这个LeetCode分类是我刷题过程中整理出来的值得刷的题目。</p>
<p>因为我对Python比较熟练，所以大部分代码是用Python实现的😬。</p>
<img src="/images/leetcode/leetcode_note.jpg" width = 600px height = 300px/>

<a id="more"></a>

<p>首先需要说明的是，本人不做大而全的刷题目录，题目现在实在太多了，而且网上已经有一些人这么做了，对于刚开始刷题的你其实并不是十分友好。如果需要我可以在结尾给出一些链接，基本涵盖了所有题目，而且也有一些详细的解释。本人也不做题解，因为代码能看懂的话基本上不需要再阐释了，如果你需要，可以参考我给出的链接，我在刷题过程中也参考了别人的解法。总之三人行，必有我师。希望你的刷题之路顺利。</p>
<p>本人刷题一开始是按照官方上Tag来刷了，因为自己的算法基础比较薄弱，就采取了相对比较容易的路子。同时按照Tag刷，暗示了题目可能会用到的算法和数据结构，本人又只选取了简单和中等的题目，所以刷起来相对轻松一点。为了方便，这里列出了一些本人认为非常重要的Tag(✅表示已完成)：</p>
<table>
<th>Tag类别</th><th>完成状态</th><th>防迷路链接</th>
<tr><td>字符串(简单)</td><td>✅</td><td><a href="/posts/c026ad95.html" title="LeetCode之字符串(简单)">LeetCode之字符串(简单)</a></td></tr>
<tr><td>字符串(中等)</td><td>✅</td><td><a href="/posts/723701661.html" title="LeetCode之字符串(中等)">LeetCode之字符串(中等)</a></td></tr>
<tr><td>二叉树(简单)</td><td>✅</td><td><a href="/posts/94def828.html" title="LeetCode之二叉树(简单)">LeetCode之二叉树(简单)</a></td></tr>
<tr><td>二叉树(中等)</td><td>✅</td><td><a href="/posts/3ddb3bb0.html" title="LeetCode之二叉树(中等)">LeetCode之二叉树(中等)</a></td></tr>
<tr><td>链表</td><td>✅</td><td><a href="/posts/fb43e507.html" title="LeetCode之链表">LeetCode之链表</a></td></tr>
<tr><td>哈希表</td><td>✅</td><td><a href="/posts/2d8b42bd.html" title="LeetCode之哈希表">LeetCode之哈希表</a></td></tr>
<tr><td>栈和队列</td><td>✅</td><td><a href="/posts/1ccb8d85.html" title="LeetCode之栈和队列">LeetCode之栈和队列</a></td></tr>
</table>

<ul>
<li>数组</li>
<li>堆</li>
<li>图</li>
<li>二分查找</li>
<li>深度优先遍历</li>
<li>广度优先遍历</li>
<li>双指针</li>
<li>回溯</li>
<li>动态规划(如果你很厉害，可以直接上，本人是最后统一刷的🤦‍♂️)</li>
</ul>
<p>如果按照这些Tag来刷，并选择简单和中等的题目，大概可以刷400-500的题目，基础和经典的题目基本都能覆盖到，对于首次刷题的你还是很友好的。</p>
<p>另一种刷的方式就是按照公司来刷，比如你心意的FLAG(Facebook,Linkedin,Amazon,Google)和Microsoft。可以小试牛刀，看下各家面试题的风格。这里罗列几个比较出名的公司：</p>
<ul>
<li>Google [✅]</li>
<li>Microsoft [✅]</li>
<li>Linkedin [✅]</li>
<li>Facebook [✅]</li>
<li>Amazon [✅]</li>
</ul>
<p>最后的最后，给出本人认为比较好的几个人的刷题链接，在刷题的过程中可以看下别人的解法，对自己写代码的能力提升会很有帮助，废话不多讲，传送门如下：</p>
<ol>
<li>首推花花酱：<a href="https://zxi.mytechroad.com/blog/">https://zxi.mytechroad.com/blog/</a></li>
<li>grandyang的博客： <a href="https://www.cnblogs.com/grandyang/p/4606334.html">https://www.cnblogs.com/grandyang/p/4606334.html</a></li>
<li><a href="https://github.com/luliyucoordinate/Leetcode">https://github.com/luliyucoordinate/Leetcode</a></li>
<li><a href="https://github.com/WuLC/LeetCode/tree/master/Algorithm/Python">https://github.com/WuLC/LeetCode/tree/master/Algorithm/Python</a></li>
<li><a href="http://bookshadow.com/leetcode/">http://bookshadow.com/leetcode/</a></li>
<li><a href="https://blog.csdn.net/fuxuemingzhu">https://blog.csdn.net/fuxuemingzhu</a></li>
</ol>
<p>如果你需要的话，可以联系我，把你的刷题链接附上来，方便大家你我他😁。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>那些我认为不错的计算机专业书(仅面向后台开发)</title>
    <url>/posts/4f424561.html</url>
    <content><![CDATA[<p>如果你是程序员新人，那么这篇文章对你很有用，能让你少走一些弯路，多看一些经典书籍，打下扎实的计算机基础。</p>
<p>如果你是职场老鸟，那么这篇文章可能适合选读。有些书还是不错的，值得多读几遍。</p>
<p>友情提示：点击图书可以跳转到豆瓣，查看相应图书的目录内容和用户评价。</p>
<img src="/images/book/cs_book_rec/cs_banner.png" width = 600px height = 300px/>

<a id="more"></a>

<h2 id="前言，那些我想对你说的话"><a href="#前言，那些我想对你说的话" class="headerlink" title="前言，那些我想对你说的话"></a>前言，那些我想对你说的话</h2><p>作为一名程序员，猿龄有四五年了。断断续续看了不少专业书，有些书还是让我成长了不少的，所以安耐不住内心的冲动，非常想分享一波，正好借本人的博客与大家交流一下☺️。</p>
<p>可以这么说，每个分类都是本人精心挑选过的，本人也有看过才会推荐。不过一千个读者眼里有一千个哈姆雷特，每个人的经历和认知差异比较大，很难满足每个人的口味。所以这里只是挑选出每个分类下个人认为不错的top3。</p>
<p>再次提示：<strong>点击图书可以跳转到豆瓣，查看相应图书的目录内容和用户评价哦~</strong></p>
<h2 id="慢着，看XX语言之前你可能需要先看这里，嘿嘿"><a href="#慢着，看XX语言之前你可能需要先看这里，嘿嘿" class="headerlink" title="慢着，看XX语言之前你可能需要先看这里，嘿嘿"></a>慢着，看XX语言之前你可能需要先看这里，嘿嘿</h2><p>我想你的脑子里肯定蹦出来一句话:”你给我推荐这么多语言的书看虾米，我看不过来啊!“。是的，你看不过来的，我也看不过来，但是我为了推荐的完整性，就都罗列出来了。</p>
<p>不瞒你说，你需要从上述基本语言挑出你自己喜欢的主力语言和辅助语言了，因为不同语言可以满足不同的需求，有它自身的一些特点。选择的话你可以考虑以下几点:</p>
<ul>
<li>不会就选C。所以说它是必修课!(是的，你没看错就是C语言！你没得选，因为计算机软件专业课，第一门要学的语言就是它！这里强调一点，Linux操作系统就是C语言实现的哦！)</li>
<li>这门语言好学吗？我现在很想快点上手写一些代码呢？！(这条我推Python，只此一家，别无分店)</li>
<li>简单的我不想学，我想先学有难度的，因为难得东西好哈哈！(这条不说了，大家都明白，选C++吧，你会爱上它的o(<em>￣︶￣</em>)o)</li>
<li>我只想学一门语言，而且我想在这门语言深耕。(嗯不错，专一挺好的，那我推荐C++或者Java)</li>
<li>我已经会了C，也学了一门面向对象的语言(C++或者Java)，我想扩展一下，那可以学下Go看看。</li>
</ul>
<p>时间是有限的，你不可能上来就什么都学，那样的话你什么都没有学会，还有可能因为学太多而走火入魔。早点做选择也没有坏处，需要做选择的时候就要果断点。当然你可以先大概了解一下每一门语言然后再深入学你喜欢的，这样也没问题的。</p>
<p>废话少说，快开始你的表演吧~，那我就开始咯，show time!</p>
<h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><table>
    <tr>
        <td>
            <a href="https://book.douban.com/subject/1139336/"><img src="/images/book/cs_book_rec/c1.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/20432061/"><img src="/images/book/cs_book_rec/c2.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/2377310/"><img src="/images/book/cs_book_rec/c3.jpg" width = 240px height = 320px/></a>
        </td>
    </tr>
</table>

<h2 id="C-语言"><a href="#C-语言" class="headerlink" title="C++语言"></a>C++语言</h2><p>因为C++很难，所以这里多推荐一些书，哈哈，可能这里就劝退了一波人啦，坚持下来的人加油哦！高精尖技术等着你开发呢😀~</p>
<table>
    <tr>
        <td>
            <a href="https://book.douban.com/subject/25708312/"><img src="/images/book/cs_book_rec/cpp1.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/10789789/"><img src="/images/book/cs_book_rec/cpp2.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/5387403/"><img src="/images/book/cs_book_rec/cpp3.jpg" width = 240px height = 320px/></a>
        </td>
    </tr>
        <tr>
        <td>
            <a href="https://book.douban.com/subject/1110934/"><img src="/images/book/cs_book_rec/cpp4.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/1792179/"><img src="/images/book/cs_book_rec/cpp5.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/10427315/"><img src="/images/book/cs_book_rec/cpp6.jpg" width = 240px height = 320px/></a>
        </td>
    </tr>
</table>

<h2 id="Java语言"><a href="#Java语言" class="headerlink" title="Java语言"></a>Java语言</h2><p>老实说，Java要推荐的书也不少。</p>
<table>
    <tr>
        <td>
            <a href="https://book.douban.com/subject/2130190/"><img src="/images/book/cs_book_rec/java1.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/26880667/"><img src="/images/book/cs_book_rec/java2.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/30412517/"><img src="/images/book/cs_book_rec/java3.jpg" width = 240px height = 320px/></a>
        </td>
    </tr>
        <tr>
        <td>
            <a href="https://book.douban.com/subject/34907497/"><img src="/images/book/cs_book_rec/java4.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/10484692/"><img src="/images/book/cs_book_rec/java5.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/26740520/"><img src="/images/book/cs_book_rec/java6.jpg" width = 240px height = 320px/></a>
        </td>
    </tr>
</table>

<h2 id="Python语言"><a href="#Python语言" class="headerlink" title="Python语言"></a>Python语言</h2><p>Python版本有2和3之分，2的话官方好像已经停止维护了，所以推荐直接学Python3吧。</p>
<table>
    <tr>
        <td>
            <a href="https://book.douban.com/subject/3112503/"><img src="/images/book/cs_book_rec/python1.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/26381341/"><img src="/images/book/cs_book_rec/python2.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/27028517/"><img src="/images/book/cs_book_rec/python3.jpg" width = 240px height = 320px/></a>
        </td>
    </tr>
</table>

<h2 id="Go语言"><a href="#Go语言" class="headerlink" title="Go语言"></a>Go语言</h2><table>
    <tr>
        <td>
            <a href="https://book.douban.com/subject/27044219/"><img src="/images/book/cs_book_rec/go1.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/30424330/"><img src="/images/book/cs_book_rec/go2.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/27016236/"><img src="/images/book/cs_book_rec/go3.jpg" width = 240px height = 320px/></a>
        </td>
    </tr>
</table>

<h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><table>
    <tr>
        <td>
            <a href="https://book.douban.com/subject/19952400/"><img src="/images/book/cs_book_rec/algorithm1.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/20432061/"><img src="/images/book/cs_book_rec/algorithm2.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/26337727/"><img src="/images/book/cs_book_rec/algorithm3.jpg" width = 240px height = 320px/></a>
        </td>
    </tr>
</table>

<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>这几本操作系统书内容比较全面，对本科生来说深度也可以。需要重点关注的章节是进程、内存和IO。</p>
<table>
    <tr>
        <td>
            <a href="https://book.douban.com/subject/30297919/"><img src="/images/book/cs_book_rec/os1.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/5064311/"><img src="/images/book/cs_book_rec/os2.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/5064311/"><img src="/images/book/cs_book_rec/os3.jpg" width = 240px height = 320px/></a>
        </td>
    </tr>
</table>


<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>现在的应用程序可以说都离不开网络，无论什么客户端，都需要和server进行交互去拿相应的数据。因此掌握计算机网络相关知识就显得尤为重要。</p>
<p>对与《TCP/IP详解 卷1：协议》和《计算机网络》这两本书，需要重点关注的是运输层和应用层。也就是TCP/UDP和HTTP这几个协议。毕竟和程序员打交道最多的就是这两层了。希望同学能认真读完并掌握哦~</p>
<p>对于《UNIX网络编程 卷1》。最需要掌握的是C/S编程范式(主要是tcp的socket编程，包括多进程、多线程和I/O复用)。</p>
<table>
    <tr>
        <td>
            <a href="https://book.douban.com/subject/26825411/"><img src="/images/book/cs_book_rec/network2.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/26960678/"><img src="/images/book/cs_book_rec/network1.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/4859464/"><img src="/images/book/cs_book_rec/network3.jpg" width = 240px height = 320px/></a>
        </td>
    </tr>
</table>

<h2 id="Linux编程"><a href="#Linux编程" class="headerlink" title="Linux编程"></a>Linux编程</h2><table>
    <tr>
        <td>
            <a href="https://book.douban.com/subject/25900403/"><img src="/images/book/cs_book_rec/linux1.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/1219329/"><img src="/images/book/cs_book_rec/linux2.jpg" width = 240px height = 320px/></a>
        </td>
        <td>
            <a href="https://book.douban.com/subject/24722611/"><img src="/images/book/cs_book_rec/linux3.jpg" width = 240px height = 320px/></a>
        </td>
    </tr>
</table>

<h2 id="后记，既然看到这里了，再听我唠叨几句又何妨-手动狗头"><a href="#后记，既然看到这里了，再听我唠叨几句又何妨-手动狗头" class="headerlink" title="后记，既然看到这里了，再听我唠叨几句又何妨(手动狗头)"></a>后记，既然看到这里了，再听我唠叨几句又何妨(手动狗头)</h2><p>如果你认真看完了上面所列的书籍，除了运气成分外，面大厂你的基础应该是很扎实了，但是有句话还是要讲一下就是”纸上得来终觉浅，绝知此事要躬行”，这句话对看这篇文章的人讲，也是对我自己讲。实践是1，看书是0，有了实践再看书相当于往1后面添加0，如果不实践看再多的书也是0。希望和大家一起共勉把！</p>
]]></content>
      <categories>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>谈一谈你对进程和线程的认识(未完待续...)</title>
    <url>/posts/3970838420.html</url>
    <content><![CDATA[<p>这是自己看完几本操作系统书和网上一些博客后，为了加深自己对进程和线程的认识，写的总结性的文章，也希望这篇文章能让你耳目一新^_^。</p>
<p>这篇文章只谈概念，不谈代码。如果你理解了概念，写代码的时候思路就会变得很清晰，不会陷入我也不知道自己在写神马的困境。</p>
<img src="/images/tech/process_and_thread/process_and_thread_preivew.png" width = 600px height = 300px/>

<a id="more"></a>

<h2 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h2><ol>
<li><p>进程是执行中的程序，是<strong>操作系统分配资源的基本单位</strong>。</p>
</li>
<li><p>内存中的进程结构如图所示:</p>
<img src="/images/tech/process_and_thread/process1.png" width = 240px height = 360px/></li>
<li><p>进程在执行时会改变状态，每个进程可能处于下列状态中的某一个，如图所示:</p>
 <img src="/images/tech/process_and_thread/process2.png" width = 600px height = 300px/></li>
<li><p>每个进程在操作系统内用程序控制块(PCB)来表示。PCB通常包含了以下几类信息:</p>
<ul>
<li><p>程序状态:包括新的、就绪、运行、等待、停止等。</p>
</li>
<li><p>程序计数器:计数器表示进程要执行的下个指令的地址。</p>
</li>
<li><p>CPU寄存器:与程序计数器一起，寄存器的状态信息在出现中断时也需要保存，以便进程以后能正确地继续执行。</p>
</li>
<li><p>CPU调度信息:包括进程优先级、调度队列的指针和其他调度参数。</p>
</li>
<li><p>内存管理信息:包括基址和界限寄存器的值、页表或段表。</p>
</li>
<li><p>记账信息:包括CPU时间、实际使用时间、时间界限、记账数据、作业或进程数量等。</p>
</li>
<li><p>I/O状态信息:包括分配给进程的I/O设备列表、打开的文件列表等。</p>
<img src="/images/tech/process_and_thread/process3.png" width = 500px height = 500px/>
</li>
</ul>
</li>
<li><p>驻留在内存中就绪的、等待运行的进程保存在就绪队列中，该队列通常用双向链表来实现。等待特定I/O设备的进程列表称为设备队列，每个设备都有自己的设备队列。</p>
 <img src="/images/tech/process_and_thread/process4.png" width = 540px height = 500px/>
</li>
<li><p>绝大多数进程可以分为I/O密集型或CPU密集型。I/O密集型的进程在执行I/O方面比执行计算要花费更多的时间。CPU密集型的进程将更多的时间用在计算上。</p>
</li>
<li><p>将CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态，这一任务被称为<strong>上下文切换</strong>。上下文切换时间是额外开销，因为切换时系统并不能做什么有用的工作。</p>
</li>
<li><p>进程在执行过程中，能够通过创建进程系统调用创建多个新进程。大多数操作系统根据一个唯一的进程标识符来识别进程，pid(process identifier)通常是一个整数值。</p>
</li>
<li><p>进程间通信有两种基本模式:共享内存和消息传递。在共享内存模式中，建立起一块共进程共享的内存区域，进程通过向此共享区域读或写入数据来交换信息。在消息传递模式中，通过在进程间交换消息来实现通信。</p>
 <img src="/images/tech/process_and_thread/process5.png" width = 580px height = 440px/>

</li>
</ol>
<p>消息传递对于交换较少数量的数据很有用，因为不需要避免冲突。对于计算机间的通信，消息传递也比共享内存更易于实现。共享内存允许以最快的速度进行方便的通信，在计算机中它可以达到内存的速度。共享内存比消息传递快，消息传递系统通常用系统调用来实现，因此需要更多的内核介入的时间消耗。共享内存系统中仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有的访问都被处理为常规的内存访问，不需要内核的帮助。(<strong>共享内存和消息传递的比较</strong>)</p>
<h2 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h2><ol>
<li><p>线程是<strong>操作系统调度的基本单位</strong>，由线程ID、程序计数器、寄存器集合和栈组成。它与属于同一进程的其他线程共享代码段、数据段和其他操作系统资源，如打开文件和信号。</p>
 <img src="/images/tech/process_and_thread/thread1.png" width = 580px height = 400px/>
</li>
<li><p>多线程编程有4个优点:</p>
<ul>
<li>响应度高:如果对一个交互程序采用多线程，那么即使其他部分阻塞或执行较冗长的操作，该程序仍能继续执行，从而增加了对用户的响应程度。</li>
<li>资源共享:线程默认共享它们所属进程的内存和资源。</li>
<li>经济:进程创建所需要的内存和资源的分配比较昂贵。由于线程共享它们所属进程的资源，所以创建和切换线程会更为经济。</li>
<li>多处理器体系结构的利用:能充分利用多处理器体系结构，以便每个进程能并行运行在不同的处理器上。<strong>在多CPU上使用多线程加强了并发功能</strong>。</li>
</ul>
</li>
<li><p><strong>线程池</strong>的主要思想是在进程开始时创建一定数量的线程，并放入到池中以等待工作。当服务器收到请求时，它会唤醒池中的一个线程，并将要处理的请求传递给它。一旦线程完成了服务，它会返回池中再等待工作。如果池中没有可用的线程，那么服务器会一直等到有空线程为止。<strong>线程池有如下几个优点</strong>:</p>
<ul>
<li>通常用现有线程处理请求要比等待创建新的线程要快。</li>
<li>线程池限制了在任何时候可用线程的数量。这对那些不能支持大量并发线程的系统非常重要。</li>
</ul>
</li>
</ol>
<p>线程池中的线程数量由系统CPU的数量、物理内存的大小和并发客户请求的期望值等因素决定。</p>
<h2 id="进程和线程有哪些联系和区别？"><a href="#进程和线程有哪些联系和区别？" class="headerlink" title="进程和线程有哪些联系和区别？"></a>进程和线程有哪些联系和区别？</h2><h2 id="多进程还是多线程？我该怎么选择呢？"><a href="#多进程还是多线程？我该怎么选择呢？" class="headerlink" title="多进程还是多线程？我该怎么选择呢？"></a>多进程还是多线程？我该怎么选择呢？</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《操作系统概念》</li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode之字符串(中等)</title>
    <url>/posts/723701661.html</url>
    <content><![CDATA[<p>字符串(中等)的题目汇总在此了，欢迎大家光顾。</p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<img src="/images/leetcode/string2.png" width = 600px height = 300px/>

<a id="more"></a>

<h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h2><p>给定一个字符串，请你找出其中不含有重复字符的<code>最长子串</code>的长度。</p>
<p>示例 1:</p>
<pre>
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
</pre>
<p>示例 2:</p>
<pre>
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
</pre>
<p>示例 3:</p>
<pre>
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
</pre>


<div class="tabs" id="leetcode"><ul class="nav-tabs"><li class="tab active"><a href="#leetcode-1">Python</a></li><li class="tab"><a href="#leetcode-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        cset = <span class="built_in">set</span>()</span><br><span class="line">        i, j, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; n:</span><br><span class="line">            <span class="keyword">if</span> s[j] <span class="keyword">not</span> <span class="keyword">in</span> cset:</span><br><span class="line">                cset.add(s[j])</span><br><span class="line">                res = <span class="built_in">max</span>(res, j - i + <span class="number">1</span>)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cset.remove(s[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Character&gt; hashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashSet.contains(s.charAt(i))) &#123;</span><br><span class="line">                hashSet.remove(s.charAt(j));</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hashSet.add(s.charAt(i));</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, i - j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p>示例 1：</p>
<pre>
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
</pre>
<p>示例 2：</p>
<pre>
输入: "cbbd"
输出: "bb"
</pre>


<div class="tabs" id="leetcode_5"><ul class="nav-tabs"><li class="tab active"><a href="#leetcode_5-1">Python</a></li><li class="tab"><a href="#leetcode_5-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode_5-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        res_left, res_right, res_len = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            l1, r1, len1 = self.helper(s, i, i)</span><br><span class="line">            l2, r2, len2 = self.helper(s, i, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> len1 &gt; len2:</span><br><span class="line">                <span class="keyword">if</span> len1 &gt; res_len:</span><br><span class="line">                    res_left, res_right, res_len = l1, r1, len1</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> len2 &gt; res_len:</span><br><span class="line">                    res_left, res_right, res_len = l2, r2, len2</span><br><span class="line">        res_str = s[res_left:res_right + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res_str</span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, s, left, right</span>):</span></span><br><span class="line">        L, R = left, right</span><br><span class="line">        <span class="keyword">while</span> L &gt;= <span class="number">0</span> <span class="keyword">and</span> R &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[L] == s[R]:</span><br><span class="line">            L -= <span class="number">1</span></span><br><span class="line">            R += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> L + <span class="number">1</span>, R - <span class="number">1</span>, R - L - <span class="number">1</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode_5-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">private</span> String res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            helper(s, i, i);</span><br><span class="line">            helper(s, i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left, j = right;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">while</span> (i &gt; -<span class="number">1</span> &amp;&amp; j &lt; n &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">            i -= <span class="number">1</span>;</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j - i - <span class="number">1</span> &gt; len) &#123;</span><br><span class="line">            len = j - i - <span class="number">1</span>;</span><br><span class="line">            res = s.substring(i + <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="6-ZZ-字形变换"><a href="#6-ZZ-字形变换" class="headerlink" title="6. ZZ 字形变换"></a>6. ZZ 字形变换</h2><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>
<pre>
L   C   I   R
E T O E S I I G
E   D   H   N
</pre>
<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<pre>
string convert(string s, int numRows);
</pre>
<p>示例 1:</p>
<pre>
输入: s = "LEETCODEISHIRING", numRows = 3
输出: "LCIRETOESIIGEDHN"
</pre>
<p>示例 2:</p>
<pre>
输入: s = "LEETCODEISHIRING", numRows = 4
输出: "LDREOEIIECIHNTSG"
解释:

L     D     R
E   O E   I I
E C   I H   N
T     S     G
</pre>


<div class="tabs" id="leetcode_6"><ul class="nav-tabs"><li class="tab active"><a href="#leetcode_6-1">Python</a></li><li class="tab"><a href="#leetcode_6-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode_6-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span>(<span class="params">self, s, numRows</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type numRows: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        s_list = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(numRows)]</span><br><span class="line">        i, n = <span class="number">0</span>, <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">0</span>, numRows):</span><br><span class="line">                <span class="keyword">if</span> i &lt; n:</span><br><span class="line">                    s_list[j].append(s[i])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(numRows - <span class="number">2</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i &lt; n:</span><br><span class="line">                    s_list[j].append(s[i])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(numRows):</span><br><span class="line">            res.extend(s_list[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(res)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode_6-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        List&lt;StringBuilder&gt; sbs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numRows; j++) &#123;</span><br><span class="line">            sbs.add(<span class="keyword">new</span> StringBuilder());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sbs.size());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, n = s.length();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numRows; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">                    sbs.get(j).append(s.charAt(i));</span><br><span class="line">                    i += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = numRows - <span class="number">2</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">                    sbs.get(j).append(s.charAt(i));</span><br><span class="line">                    i += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (StringBuilder sb : sbs) &#123;</span><br><span class="line">            res.append(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h2><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
<p>例如，给出 n = 3，生成结果为：</p>
<pre>
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
</pre>


<div class="tabs" id="leetcode_22"><ul class="nav-tabs"><li class="tab active"><a href="#leetcode_22-1">Python</a></li><li class="tab"><a href="#leetcode_22-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode_22-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        item, res = <span class="string">&#x27;&#x27;</span>, []</span><br><span class="line">        self.helper(res, item, <span class="number">0</span>, <span class="number">0</span>, n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, res, item, left, right, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left == n <span class="keyword">and</span> right == n:</span><br><span class="line">            res.append(item)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; n:</span><br><span class="line">            self.helper(res, item + <span class="string">&#x27;(&#x27;</span>, left + <span class="number">1</span>, right, n)</span><br><span class="line">        <span class="keyword">if</span> right &lt; left:</span><br><span class="line">            self.helper(res, item + <span class="string">&#x27;)&#x27;</span>, left, right + <span class="number">1</span>, n)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode_22-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(n, n, <span class="string">&quot;&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, String cur, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            helper(left - <span class="number">1</span>, right, cur + <span class="string">&quot;(&quot;</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">            helper(left, right - <span class="number">1</span>, cur + <span class="string">&quot;)&quot;</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a>91. 解码方法</h2><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p>
<pre>
'A' -> 1
'B' -> 2
...
'Z' -> 26
</pre>
<p>给定一个只包含数字的非空字符串，请计算解码方法的总数。</p>
<p>示例 1:</p>
<pre>
输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
</pre>
<p>示例 2:</p>
<pre>
输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
</pre>


<div class="tabs" id="leetcode_91"><ul class="nav-tabs"><li class="tab active"><a href="#leetcode_91-1">Python</a></li><li class="tab"><a href="#leetcode_91-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode_91-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span> <span class="keyword">if</span> s[<span class="number">0</span>] != <span class="string">&#x27;0&#x27;</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            one_c = <span class="built_in">int</span>(s[i - <span class="number">1</span>:i])</span><br><span class="line">            two_c = <span class="built_in">int</span>(s[i - <span class="number">2</span>:i])</span><br><span class="line">            <span class="keyword">if</span> <span class="number">1</span> &lt;= one_c &lt;= <span class="number">9</span>:</span><br><span class="line">                dp[i] += dp[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="number">10</span> &lt;= two_c &lt;= <span class="number">26</span>:</span><br><span class="line">                dp[i] += dp[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode_91-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            String one_s = s.substring(i - <span class="number">1</span>, i);</span><br><span class="line">            String two_s = s.substring(i - <span class="number">2</span>, i);</span><br><span class="line">            <span class="keyword">int</span> one = Integer.parseInt(one_s);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;= one &amp;&amp; one &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">                dp[i] += dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> two = Integer.parseInt(two_s);</span><br><span class="line">            <span class="keyword">if</span> (two &gt;= <span class="number">10</span> &amp;&amp; two &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">                dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93. 复原IP地址"></a>93. 复原IP地址</h2><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p>示例:</p>
<pre>
输入: "25525511135"
输出: ["255.255.11.135", "255.255.111.35"]
</pre>


<div class="tabs" id="leetcode_93"><ul class="nav-tabs"><li class="tab active"><a href="#leetcode_93-1">Python</a></li><li class="tab"><a href="#leetcode_93-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode_93-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        item, res = [], []</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(s) &lt; <span class="number">4</span> <span class="keyword">or</span> <span class="built_in">len</span>(s) &gt; <span class="number">12</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        self.helper(s, item, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, s, item, res</span>):</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> <span class="built_in">len</span>(item) == <span class="number">4</span>:</span><br><span class="line">            res.append(<span class="string">&#x27;.&#x27;</span>.join(item[:]))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">            sub_s = s[:i]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(sub_s) == i <span class="keyword">and</span> self.ok(sub_s):</span><br><span class="line">                item.append(sub_s)</span><br><span class="line">                self.helper(s[i:], item, res)</span><br><span class="line">                item.pop(-<span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ok</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">1</span> <span class="keyword">and</span> s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        n = <span class="built_in">int</span>(s)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= n &lt;= <span class="number">255</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode_93-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span> || n &gt; <span class="number">12</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; item = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(s, <span class="number">0</span>, item, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span> idx, List&lt;String&gt; item, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;String&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            tmp.addAll(item);</span><br><span class="line">            res.add(String.join(<span class="string">&quot;.&quot;</span>, tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.length() &lt; i) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String substr = s.substring(<span class="number">0</span>, i);</span><br><span class="line">            <span class="keyword">if</span> (isOK(substr)) &#123;</span><br><span class="line">                item.add(substr);</span><br><span class="line">                helper(s.substring(i), idx + <span class="number">1</span>, item, res);</span><br><span class="line">                item.remove(item.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOK</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span> || s.length() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &gt; <span class="number">1</span> &amp;&amp; s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(s);</span><br><span class="line">        <span class="keyword">return</span> n &gt;= <span class="number">0</span> &amp;&amp; n &lt;= <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="316-去除重复字母-n"><a href="#316-去除重复字母-n" class="headerlink" title="316. 去除重复字母 [n]"></a>316. 去除重复字母 [n]</h2><p>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p>
<p>示例 1：</p>
<pre>
输入：s = "bcabc"
输出："abc"
</pre>
<p>示例 2：</p>
<pre>
输入：s = "cbacdcbc"
输出："acdb"
</pre>

<p>提示：</p>
<ul>
<li>1 &lt;= s.length &lt;= 10^4</li>
<li>s 由小写英文字母组成</li>
</ul>
<div class="tabs" id="leetcode_316"><ul class="nav-tabs"><li class="tab active"><a href="#leetcode_316-1">Python</a></li><li class="tab"><a href="#leetcode_316-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode_316-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicateLetters</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stk = []</span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        m = &#123;c: i <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s)&#125;</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">while</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>] &gt; c <span class="keyword">and</span> m[stk[-<span class="number">1</span>]] &gt; i:</span><br><span class="line">                    rm_c = stk.pop(-<span class="number">1</span>)</span><br><span class="line">                    seen.discard(rm_c)</span><br><span class="line">                seen.add(c)</span><br><span class="line">                stk.append(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stk)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode_316-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stk = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Set&lt;Character&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            m.put(s.charAt(i), i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!seen.contains(c)) &#123;</span><br><span class="line">                <span class="keyword">while</span> (stk.size() &gt; <span class="number">0</span> &amp;&amp; stk.peek() &gt; c &amp;&amp; m.get(stk.peek()) &gt; i) &#123;</span><br><span class="line">                    <span class="keyword">char</span> rm_c = stk.pop().charValue();</span><br><span class="line">                    seen.remove(rm_c);</span><br><span class="line">                &#125;</span><br><span class="line">                seen.add(c);</span><br><span class="line">                stk.add(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(stk.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stk.size(); i++) &#123;</span><br><span class="line">            res.append(stk.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="402-移掉K位数字"><a href="#402-移掉K位数字" class="headerlink" title="402. 移掉K位数字"></a>402. 移掉K位数字</h2><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p>
<p>注意:</p>
<ul>
<li>num 的长度小于 10002 且 ≥ k。</li>
<li>num 不会包含任何前导零。</li>
</ul>
<p>示例 1 :</p>
<pre>
输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
</pre>
<p>示例 2 :</p>
<pre>
输入: num = "10200", k = 1
输出: "200"
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
</pre>
<p>示例 3 :</p>
<pre>
输入: num = "10", k = 2
输出: "0"
解释: 从原数字移除所有的数字，剩余为空就是0。
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeKdigits</span>(<span class="params">self, num, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num: str</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> num:</span><br><span class="line">            <span class="keyword">while</span> k <span class="keyword">and</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>] &gt; c:</span><br><span class="line">                stk.pop(-<span class="number">1</span>)</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            stk.append(c)</span><br><span class="line">        <span class="keyword">while</span> k:</span><br><span class="line">            stk.pop(-<span class="number">1</span>)</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stk:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(stk)))</span><br></pre></td></tr></table></figure>

<h2 id="424-替换后的最长重复字符-n"><a href="#424-替换后的最长重复字符-n" class="headerlink" title="424. 替换后的最长重复字符[n]"></a>424. 替换后的最长重复字符[n]</h2><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p>
<p>注意:</p>
<ul>
<li>字符串长度 和 k 不会超过 104。</li>
</ul>
<p>示例 1:</p>
<pre>
输入:
s = "ABAB", k = 2
输出:
4
解释:
用两个'A'替换为两个'B',反之亦然。
</pre>
<p>示例 2:</p>
<pre>
输入:
s = "AABABBA", k = 1
输出:
4
解释:
将中间的一个'A'替换为'B',字符串变为 "AABBBBA"。
子串 "BBBB" 有最长重复字母, 答案为 4。
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">characterReplacement</span>(<span class="params">self, s, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        start, end, max_freq, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> end &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            m[s[end]] = <span class="number">1</span> <span class="keyword">if</span> s[end] <span class="keyword">not</span> <span class="keyword">in</span> m <span class="keyword">else</span> m[s[end]] + <span class="number">1</span></span><br><span class="line">            max_freq = <span class="built_in">max</span>(max_freq, m[s[end]])</span><br><span class="line">            <span class="keyword">if</span> end - start + <span class="number">1</span> - max_freq &gt; k:</span><br><span class="line">                m[s[start]] -= <span class="number">1</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, end - start + <span class="number">1</span>)</span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h2 id="556-Next-Greater-Element-III-n"><a href="#556-Next-Greater-Element-III-n" class="headerlink" title="556. Next Greater Element III [n]"></a>556. Next Greater Element III [n]</h2><p>给定一个32位正整数 n，你需要找到最小的32位整数，其与 n 中存在的位数完全相同，并且其值大于n。如果不存在这样的32位整数，则返回-1。</p>
<p>示例 1:</p>
<pre>
输入: 12
输出: 21
</pre>
<p>示例 2:</p>
<pre>
输入: 21
输出: -1
</pre>


<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        max_val = (<span class="number">1</span> &lt;&lt; <span class="number">32</span>) - <span class="number">1</span></span><br><span class="line">        nums = [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>(n)]</span><br><span class="line">        i = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[i - <span class="number">1</span>] &lt; nums[i]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        x = nums[i - <span class="number">1</span>]</span><br><span class="line">        smallest = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i + <span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; x <span class="keyword">and</span> nums[j] &lt; nums[smallest]:</span><br><span class="line">                smallest = j</span><br><span class="line">        nums[i - <span class="number">1</span>], nums[smallest] = nums[smallest], nums[i - <span class="number">1</span>]</span><br><span class="line">        left = nums[:i]</span><br><span class="line">        right = <span class="built_in">sorted</span>(nums[i:])</span><br><span class="line">        nums = left + right</span><br><span class="line">        v = <span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> nums]))</span><br><span class="line">        <span class="keyword">return</span> v <span class="keyword">if</span> v &lt; max_val <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="583-两个字符串的删除操作-n"><a href="#583-两个字符串的删除操作-n" class="headerlink" title="583. 两个字符串的删除操作 [n]"></a>583. 两个字符串的删除操作 [n]</h2><p>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p>
<p>示例 1:</p>
<pre>
输入: "sea", "eat"
输出: 2
解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"
</pre>
<p>说明:</p>
<ul>
<li>给定单词的长度不超过500。</li>
<li>给定单词中的字符只含有小写字母。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, word1, word2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type word1: str</span></span><br><span class="line"><span class="string">        :type word2: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        len1, len2 = <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(len2 + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(len1 + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len1 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(len2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">        lcs = dp[len1][len2]</span><br><span class="line">        <span class="keyword">return</span> len1 + len2 - <span class="number">2</span> * lcs</span><br></pre></td></tr></table></figure>

<h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a>647. 回文子串</h2><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。</p>
<p>示例 1:</p>
<pre>
输入: "abc"
输出: 3
解释: 三个回文子串: "a", "b", "c".
</pre>
<p>示例 2:</p>
<pre>
输入: "aaa"
输出: 6
说明: 6个回文子串: "a", "a", "a", "aa", "aa", "aaa".
</pre>
<p>注意:</p>
<ul>
<li>输入的字符串长度不会超过1000。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            self.helper(s, i, i)</span><br><span class="line">            self.helper(s, i, i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, s, left, right</span>):</span></span><br><span class="line">        <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">            self.res += <span class="number">1</span></span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="678-有效的括号字符串-n"><a href="#678-有效的括号字符串-n" class="headerlink" title="678. 有效的括号字符串 [n]"></a>678. 有效的括号字符串 [n]</h2><p>给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p>
<ul>
<li>任何左括号 ( 必须有相应的右括号 )。</li>
<li>任何右括号 ) 必须有相应的左括号 ( 。</li>
<li>左括号 ( 必须在对应的右括号之前 )。</li>
<li>* 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。</li>
<li>一个空字符串也被视为有效字符串。</li>
</ul>
<p>示例 1:</p>
<pre>
输入: "()"
输出: True
</pre>
<p>示例 2:</p>
<pre>
输入: "(*)"
输出: True
</pre>
<p>示例 3:</p>
<pre>
输入: "(*))"
输出: True
</pre>
<p>注意:</p>
<ul>
<li>字符串大小将在 [1，100] 范围内。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkValidString</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        low, high = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                low, high = low +<span class="number">1</span>, high + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> low &gt; <span class="number">0</span>:</span><br><span class="line">                    low -= <span class="number">1</span></span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> low &gt; <span class="number">0</span>:</span><br><span class="line">                    low -= <span class="number">1</span></span><br><span class="line">                high += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> high &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> low == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="767-重构字符串"><a href="#767-重构字符串" class="headerlink" title="767. 重构字符串"></a>767. 重构字符串</h2><p>给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。</p>
<p>若可行，输出任意可行的结果。若不可行，返回空字符串。</p>
<p>示例 1:</p>
<pre>
输入: S = "aab"
输出: "aba"
</pre>
<p>示例 2:</p>
<pre>
输入: S = "aaab"
输出: ""
</pre>
<p>注意:</p>
<ul>
<li>S 只包含小写字母并且长度在[1, 500]区间内。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorganizeString</span>(<span class="params">self, S</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        char_cnt = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">26</span>)]</span><br><span class="line">        max_char = <span class="literal">None</span></span><br><span class="line">        i_a = <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">            i = <span class="built_in">ord</span>(c) - i_a</span><br><span class="line">            char_cnt[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> max_char <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                max_char = c</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = <span class="built_in">ord</span>(max_char) - i_a</span><br><span class="line">                <span class="keyword">if</span> char_cnt[i] &gt; char_cnt[j]:</span><br><span class="line">                    max_char = c</span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span> * char_cnt[<span class="built_in">ord</span>(max_char) - i_a] -<span class="number">1</span> &gt; <span class="built_in">len</span>(S):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        res = [<span class="string">&#x27;&#x27;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="built_in">len</span>(S))]</span><br><span class="line">        i_max_char = <span class="built_in">ord</span>(max_char) - i_a</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange (char_cnt[i_max_char]):</span><br><span class="line">            res[i] = max_char</span><br><span class="line">            i += <span class="number">2</span></span><br><span class="line">        char_cnt[i_max_char] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">26</span>):</span><br><span class="line">            <span class="keyword">if</span> char_cnt[j] &gt; <span class="number">0</span>:</span><br><span class="line">                c = <span class="built_in">chr</span>(j + i_a)</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> xrange(char_cnt[j]):</span><br><span class="line">                    <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(S):</span><br><span class="line">                        i = <span class="number">1</span></span><br><span class="line">                    res[i] = c</span><br><span class="line">                    i += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(res)</span><br></pre></td></tr></table></figure>

<h2 id="856-括号的分数"><a href="#856-括号的分数" class="headerlink" title="856. 括号的分数"></a>856. 括号的分数</h2><p>给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：</p>
<p>() 得 1 分。<br>AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。<br>(A) 得 2 * A 分，其中 A 是平衡括号字符串。</p>
<p>示例 1：</p>
<pre>
输入： "()"
输出： 1
</pre>
<p>示例 2：</p>
<pre>
输入： "(())"
输出： 2
</pre>
<p>示例 3：</p>
<pre>
输入： "()()"
输出： 2
</pre>
<p>示例 4：</p>
<pre>
输入： "(()(()))"
输出： 6
</pre>
<p>提示：</p>
<ul>
<li>S 是平衡括号字符串，且只含有 ( 和 ) 。</li>
<li>2 &lt;= S.length &lt;= 50</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scoreOfParentheses</span>(<span class="params">self, S</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stk.append(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> stk[-<span class="number">1</span>] != -<span class="number">1</span>:</span><br><span class="line">                    cnt += stk[-<span class="number">1</span>]</span><br><span class="line">                    stk.pop(-<span class="number">1</span>)</span><br><span class="line">                stk.pop(-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">                    stk.append(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stk.append(<span class="number">2</span> * cnt)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(stk)</span><br></pre></td></tr></table></figure>

<h2 id="890-查找和替换模式"><a href="#890-查找和替换模式" class="headerlink" title="890. 查找和替换模式"></a>890. 查找和替换模式</h2><p>你有一个单词列表 words 和一个模式  pattern，你想知道 words 中的哪些单词与模式匹配。</p>
<p>如果存在字母的排列 p ，使得将模式中的每个字母 x 替换为 p(x) 之后，我们就得到了所需的单词，那么单词与模式是匹配的。</p>
<p>（回想一下，字母的排列是从字母到字母的双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母。）</p>
<p>返回 words 中与给定模式匹配的单词列表。</p>
<p>你可以按任何顺序返回答案。</p>
<p>示例：</p>
<pre>
输入：words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb"
输出：["mee","aqq"]
解释：
"mee" 与模式匹配，因为存在排列 {a -> m, b -> e, ...}。
"ccc" 与模式不匹配，因为 {a -> c, b -> c, ...} 不是排列。
因为 a 和 b 映射到同一个字母。
</pre>
<p>提示：</p>
<ul>
<li>1 &lt;= words.length &lt;= 50</li>
<li>1 &lt;= pattern.length = words[i].length &lt;= 20</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAndReplacePattern</span>(<span class="params">self, words, pattern</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :type pattern: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        p = self.helper(pattern)</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            pw = self.helper(w)</span><br><span class="line">            <span class="keyword">if</span> pw == p:</span><br><span class="line">                res.append(w)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, pattern</span>):</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> pattern:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> m:</span><br><span class="line">                res.append(m[c])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m[c] = <span class="built_in">len</span>(m) + <span class="number">1</span></span><br><span class="line">                res.append(m[c])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> res])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode之栈和队列</title>
    <url>/posts/1ccb8d85.html</url>
    <content><![CDATA[<p>栈与队列的题目汇总在此了，欢迎大家光顾。</p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<img src="/images/leetcode/queue_and_stack.png" width = 600px height = 300px/>

<a id="more"></a>

<h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a>394. 字符串解码</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<p>示例:</p>
<pre>
s = "3[a]2[bc]", 返回 "aaabcbc".
s = "3[a2[c]]", 返回 "accaccacc".
s = "2[abc]3[cd]ef", 返回 "abcabccdcdcdef".
</pre>

<div class="tabs" id="leetcode394"><ul class="nav-tabs"><li class="tab active"><a href="#leetcode394-1">Python</a></li><li class="tab"><a href="#leetcode394-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode394-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>   </span><br><span class="line">        stack, res, multi = [], <span class="string">&quot;&quot;</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                stack.append([multi, res])</span><br><span class="line">                res, multi = <span class="string">&quot;&quot;</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                cur_multi, last_res = stack.pop()</span><br><span class="line">                res = last_res + cur_multi * res</span><br><span class="line">            <span class="keyword">elif</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">                multi = multi * <span class="number">10</span> + <span class="built_in">int</span>(c)            </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += c</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode394-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">public</span> String str;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Item</span><span class="params">(<span class="keyword">int</span> n, String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = n;</span><br><span class="line">            <span class="keyword">this</span>.str = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> multi = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Item&gt; stk = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                stk.add(<span class="keyword">new</span> Item(multi, res));</span><br><span class="line">                res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                multi = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                Item item = stk.pop();</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; item.num; k++) &#123;</span><br><span class="line">                    sb.append(res);</span><br><span class="line">                &#125;</span><br><span class="line">                res = item.str + sb.toString();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                multi = multi * <span class="number">10</span> + Integer.parseInt(c + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="402-移掉K位数字"><a href="#402-移掉K位数字" class="headerlink" title="402. 移掉K位数字"></a>402. 移掉K位数字</h2><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p>
<p>注意:</p>
<ul>
<li>num 的长度小于 10002 且 ≥ k。</li>
<li>num 不会包含任何前导零。</li>
</ul>
<p>示例 1 :</p>
<pre>
输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
</pre>
<p>示例 2 :</p>
<pre>
输入: num = "10200", k = 1
输出: "200"
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
</pre>
<p>示例 3 :</p>
<pre>
输入: num = "10", k = 2
输出: "0"
解释: 从原数字移除所有的数字，剩余为空就是0。
</pre>


<div class="tabs" id="leetcode402"><ul class="nav-tabs"><li class="tab active"><a href="#leetcode402-1">Python</a></li><li class="tab"><a href="#leetcode402-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode402-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeKdigits</span>(<span class="params">self, num, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num: str</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> num:</span><br><span class="line">            <span class="keyword">while</span> k <span class="keyword">and</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>] &gt; c:</span><br><span class="line">                stk.pop(-<span class="number">1</span>)</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            stk.append(c)</span><br><span class="line">        <span class="keyword">while</span> k:</span><br><span class="line">            stk.pop(-<span class="number">1</span>)</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stk:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(stk)))</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode402-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stk = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = num.charAt(i);</span><br><span class="line">            <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; !stk.empty() &amp;&amp; stk.peek() &gt; c) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">                k -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            stk.pop();</span><br><span class="line">            k -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.get(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            stk.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stk.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stk.size(); i++) &#123;</span><br><span class="line">            sb.append(stk.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="456-132模式"><a href="#456-132模式" class="headerlink" title="456. 132模式"></a>456. 132模式</h2><p>给定一个整数序列：a1, a2, …, an，一个132模式的子序列 ai, aj, ak 被定义为：当 i &lt; j &lt; k 时，ai &lt; ak &lt; aj。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。</p>
<p>注意：n 的值小于15000。</p>
<p>示例1:</p>
<pre>
输入: [1, 2, 3, 4]
输出: False
解释: 序列中不存在132模式的子序列。
</pre>
<p>示例 2:</p>
<pre>
输入: [3, 1, 4, 2]
输出: True
解释: 序列中有 1 个132模式的子序列： [1, 4, 2].
</pre>
<p>示例 3:</p>
<pre>
输入: [-1, 3, 2, 0]
输出: True
解释: 序列中有 3 个132模式的的子序列: [-1, 3, 2], [-1, 3, 0] 和 [-1, 2, 0].
</pre>


<div class="tabs" id="leetcode456"><ul class="nav-tabs"><li class="tab active"><a href="#leetcode456-1">Python</a></li><li class="tab"><a href="#leetcode456-2">Java</a></li></ul><div class="tab-content"><div class="tab-pane active" id="leetcode456-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find132pattern</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stk = []</span><br><span class="line">        INT_MIN = -(<span class="number">1</span> &lt;&lt; <span class="number">31</span>)</span><br><span class="line">        third = INT_MIN</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> xrange(<span class="built_in">len</span>(nums) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[idx] &lt; third:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>] &lt; nums[idx]:</span><br><span class="line">                third = stk.pop(-<span class="number">1</span>)</span><br><span class="line">            stk.append(nums[idx])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="leetcode456-2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> INT_MIN = -(<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">        <span class="keyword">int</span> third = INT_MIN;</span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; third) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.peek() &lt; nums[i]) &#123;</span><br><span class="line">                third = stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>


<h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a>496. 下一个更大元素 I</h2><p>给定两个没有重复元素的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。</p>
<p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。</p>
<p>示例 1:</p>
<pre>
输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:
    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。
    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。
    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。
</pre>
<p>示例 2:</p>
<pre>
输入: nums1 = [2,4], nums2 = [1,2,3,4].
输出: [3,-1]
解释:
    对于num1中的数字2，第二个数组中的下一个较大数字是3。
    对于num1中的数字4，第二个数组中没有下一个更大的数字，因此输出 -1。
</pre>

<p>注意:</p>
<ul>
<li>nums1和nums2中所有元素是唯一的。</li>
<li>nums1和nums2 的数组大小都不超过1000。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span>(<span class="params">self, nums1, nums2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        stk = []</span><br><span class="line">        res = [-<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="built_in">len</span>(nums1))]</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(stk) &gt; <span class="number">0</span> <span class="keyword">and</span> stk[-<span class="number">1</span>] &lt; n:</span><br><span class="line">                m[stk[-<span class="number">1</span>]] = n</span><br><span class="line">                stk.pop(-<span class="number">1</span>)</span><br><span class="line">            stk.append(n)</span><br><span class="line">        <span class="keyword">for</span> idx, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums1):</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> m:</span><br><span class="line">                res[idx] = m[n]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[idx] = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="503-下一个更大元素-II-n"><a href="#503-下一个更大元素-II-n" class="headerlink" title="503. 下一个更大元素 II [n]"></a>503. 下一个更大元素 II [n]</h2><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
<p>示例 1:</p>
<pre>
输入: [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
</pre>
<p>注意: 输入数组的长度不会超过 10000。</p>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElements</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [-<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> xrange(n * <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>] &lt;= nums[idx % n]:</span><br><span class="line">                stk.pop(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stk) == <span class="number">0</span>:</span><br><span class="line">                res[idx % n] = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[idx % n] = stk[-<span class="number">1</span>]</span><br><span class="line">            stk.append(nums[idx % n])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="622-设计循环队列"><a href="#622-设计循环队列" class="headerlink" title="622. 设计循环队列"></a>622. 设计循环队列</h2><figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here. Set the size of the queue to be k.</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.queue = [<span class="literal">None</span>] * k</span><br><span class="line">        self.size = k</span><br><span class="line">        self.real_cnt = <span class="number">0</span></span><br><span class="line">        self.head = <span class="number">0</span></span><br><span class="line">        self.tail = <span class="number">0</span> <span class="comment"># 有效元素尾部的下一个位置</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enQueue</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Insert an element into the circular queue. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.queue[self.tail] = value</span><br><span class="line">        self.tail = (self.tail + <span class="number">1</span>) % self.size</span><br><span class="line">        self.real_cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deQueue</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Delete an element from the circular queue. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.head = (self.head + <span class="number">1</span>) % self.size</span><br><span class="line">        self.real_cnt -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Front</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the front item from the queue.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.queue[self.head]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Rear</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the last item from the queue.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.tail == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.queue[self.size - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> self.queue[self.tail - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Checks whether the circular queue is empty or not.</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.real_cnt == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFull</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Checks whether the circular queue is full or not.</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.real_cnt == self.size</span><br></pre></td></tr></table></figure>

<h2 id="641-设计循环双端队列"><a href="#641-设计循环双端队列" class="headerlink" title="641. 设计循环双端队列"></a>641. 设计循环双端队列</h2><figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularDeque</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here. Set the size of the deque to be k.</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.deque = [<span class="literal">None</span>] * k</span><br><span class="line">        self.size = k</span><br><span class="line">        self.real_cnt = <span class="number">0</span></span><br><span class="line">        self.head = <span class="number">0</span></span><br><span class="line">        self.tail = <span class="number">0</span> <span class="comment"># 有效元素尾部的下一个位置</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertFront</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Adds an item at the front of Deque. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> self.head == <span class="number">0</span>:</span><br><span class="line">            self.head = self.size - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.head = self.head - <span class="number">1</span></span><br><span class="line">        self.deque[self.head] = value</span><br><span class="line">        self.real_cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertLast</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Adds an item at the rear of Deque. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.deque[self.tail] = value</span><br><span class="line">        self.tail = (self.tail + <span class="number">1</span>) % self.size</span><br><span class="line">        self.real_cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteFront</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Deletes an item from the front of Deque. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.head = (self.head + <span class="number">1</span>) % self.size</span><br><span class="line">        self.real_cnt -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteLast</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Deletes an item from the rear of Deque. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> self.tail == <span class="number">0</span>:</span><br><span class="line">            self.tail = self.size - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.tail = self.tail - <span class="number">1</span></span><br><span class="line">        self.real_cnt -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getFront</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the front item from the deque.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.deque[self.head]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRear</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the last item from the deque.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.tail == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.deque[self.size - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.deque[self.tail - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Checks whether the circular deque is empty or not.</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.real_cnt == <span class="number">0</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFull</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Checks whether the circular deque is full or not.</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.real_cnt == self.size</span><br></pre></td></tr></table></figure>

<h2 id="739-每日温度-n"><a href="#739-每日温度-n" class="headerlink" title="739. 每日温度 [n]"></a>739. 每日温度 [n]</h2><p>根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, T</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type T: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="built_in">len</span>(T))]</span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(T) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> T[stk[-<span class="number">1</span>]] &lt;= T[i]:</span><br><span class="line">                stk.pop(-<span class="number">1</span>)</span><br><span class="line">            res[i] = <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> stk <span class="keyword">else</span> stk[-<span class="number">1</span>] - i</span><br><span class="line">            stk.append(i)</span><br><span class="line">        <span class="keyword">return</span> res        </span><br></pre></td></tr></table></figure>

<h2 id="856-括号的分数"><a href="#856-括号的分数" class="headerlink" title="856. 括号的分数"></a>856. 括号的分数</h2><p>给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：</p>
<p>() 得 1 分。<br>AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。<br>(A) 得 2 * A 分，其中 A 是平衡括号字符串。
 </p>
<p>示例 1：</p>
<pre>
输入： "()"
输出： 1
</pre>
<p>示例 2：</p>
<pre>
输入： "(())"
输出： 2
</pre>
<p>示例 3：</p>
<pre>
输入： "()()"
输出： 2
</pre>
<p>示例 4：</p>
<pre>
输入： "(()(()))"
输出： 6
</pre>

<p>提示：</p>
<ul>
<li>S 是平衡括号字符串，且只含有 ( 和 ) 。</li>
<li>2 &lt;= S.length &lt;= 50</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scoreOfParentheses</span>(<span class="params">self, S</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stk.append(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> stk[-<span class="number">1</span>] != -<span class="number">1</span>:</span><br><span class="line">                    cnt += stk[-<span class="number">1</span>]</span><br><span class="line">                    stk.pop(-<span class="number">1</span>)</span><br><span class="line">                stk.pop(-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">                    stk.append(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stk.append(<span class="number">2</span> * cnt)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(stk)</span><br></pre></td></tr></table></figure>

<h2 id="880-索引处的解码字符串-n"><a href="#880-索引处的解码字符串-n" class="headerlink" title="880. 索引处的解码字符串 [n]"></a>880. 索引处的解码字符串 [n]</h2><p>给定一个编码字符串 S。为了找出解码字符串并将其写入磁带，从编码字符串中每次读取一个字符，并采取以下步骤：</p>
<p>如果所读的字符是字母，则将该字母写在磁带上。<br>如果所读的字符是数字（例如 d），则整个当前磁带总共会被重复写 d-1 次。<br>现在，对于给定的编码字符串 S 和索引 K，查找并返回解码字符串中的第 K 个字母。</p>
<p>示例 1：</p>
<pre>
输入：S = "leet2code3", K = 10
输出："o"
解释：
解码后的字符串为 "leetleetcodeleetleetcodeleetleetcode"。
字符串中的第 10 个字母是 "o"。
</pre>
<p>示例 2：</p>
<pre>
输入：S = "ha22", K = 5
输出："h"
解释：
解码后的字符串为 "hahahaha"。第 5 个字母是 "h"。
</pre>
<p>示例 3：</p>
<pre>
输入：S = "a2345678999999999999999", K = 1
输出："a"
解释：
解码后的字符串为 "a" 重复 8301530446056247680 次。第 1 个字母是 "a"。
</pre>

<p>提示：</p>
<ul>
<li>2 &lt;= S.length &lt;= 100</li>
<li>S 只包含小写字母与数字 2 到 9 。</li>
<li>S 以字母开头。</li>
<li>1 &lt;= K &lt;= 10^9</li>
<li>解码后的字符串保证少于 2^63 个字母。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeAtIndex</span>(<span class="params">self, S, K</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        sz = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                sz *= <span class="built_in">int</span>(c)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sz += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S[::-<span class="number">1</span>]:</span><br><span class="line">            K %= sz</span><br><span class="line">            <span class="keyword">if</span> K == <span class="number">0</span> <span class="keyword">and</span> c.isalpha():</span><br><span class="line">                <span class="keyword">return</span> c</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                sz /= <span class="built_in">int</span>(c)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sz -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="907-子数组的最小值之和-n"><a href="#907-子数组的最小值之和-n" class="headerlink" title="907. 子数组的最小值之和 [n]"></a>907. 子数组的最小值之和 [n]</h2><p>给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。</p>
<p>由于答案可能很大，因此返回答案模 10^9 + 7。</p>
<p>示例：</p>
<pre>
输入：[3,1,2,4]
输出：17
解释：
子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 
最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。
</pre>

<p>提示：</p>
<ul>
<li>1 &lt;= A &lt;= 30000</li>
<li>1 &lt;= A[i] &lt;= 30000</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumSubarrayMins</span>(<span class="params">self, A</span>):</span></span><br><span class="line">        MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        N = <span class="built_in">len</span>(A)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># prev has i* - 1 in increasing order of A[i* - 1]</span></span><br><span class="line">        <span class="comment"># where i* is the answer to query j</span></span><br><span class="line">        stack = []</span><br><span class="line">        prev = [<span class="literal">None</span>] * N</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(N):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> A[i] &lt;= A[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            prev[i] = stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># next has k* + 1 in increasing order of A[k* + 1]</span></span><br><span class="line">        <span class="comment"># where k* is the answer to query j</span></span><br><span class="line">        stack = []</span><br><span class="line">        next_ = [<span class="literal">None</span>] * N</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> xrange(N-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> A[k] &lt; A[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            next_[k] = stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> N</span><br><span class="line">            stack.append(k)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Use prev/next array to count answer</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>((i - prev[i]) * (next_[i] - i) * A[i]</span><br><span class="line">                   <span class="keyword">for</span> i <span class="keyword">in</span> xrange(N)) % MOD</span><br></pre></td></tr></table></figure>

<h2 id="946-验证栈序列"><a href="#946-验证栈序列" class="headerlink" title="946. 验证栈序列"></a>946. 验证栈序列</h2><p>给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。</p>
<p>示例 1：</p>
<pre>
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
</pre>
<p>示例 2：</p>
<pre>
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
</pre>

<p>提示：</p>
<ul>
<li>0 &lt;= pushed.length == popped.length &lt;= 1000</li>
<li>0 &lt;= pushed[i], popped[i] &lt; 1000</li>
<li>pushed 是 popped 的排列。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span>(<span class="params">self, pushed, popped</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type pushed: List[int]</span></span><br><span class="line"><span class="string">        :type popped: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stk = []</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(pushed)</span><br><span class="line">        m = <span class="built_in">len</span>(popped)</span><br><span class="line">        <span class="keyword">if</span> m != n :</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            stk.append(pushed[i])</span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>] == popped[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                stk.pop(-<span class="number">1</span>)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stk) == <span class="number">0</span> <span class="keyword">and</span> j == n</span><br></pre></td></tr></table></figure>


<h2 id="1019-链表中的下一个更大节点-n"><a href="#1019-链表中的下一个更大节点-n" class="headerlink" title="1019. 链表中的下一个更大节点 [n]"></a>1019. 链表中的下一个更大节点 [n]</h2><p>给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, … 。</p>
<p>每个节点都可能有下一个更大值（next larger value）：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j &gt; i 且  node_j.val &gt; node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。</p>
<p>返回整数答案数组 answer，其中 answer[i] = next_larger(node_{i+1}) 。</p>
<p>注意：在下面的示例中，诸如 [2,1,5] 这样的输入（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。</p>
<p>示例 1：</p>
<pre>
输入：[2,1,5]
输出：[5,5,0]
</pre>
<p>示例 2：</p>
<pre>
输入：[2,7,4,3,5]
输出：[7,0,5,5,0]
</pre>
<p>示例 3：</p>
<pre>
输入：[1,7,5,1,9,2,5,1]
输出：[7,9,9,9,0,5,0,0]
</pre>

<p>提示：</p>
<ul>
<li>对于链表中的每个节点，1 &lt;= node.val &lt;= 10^9</li>
<li>给定列表的长度在 [0, 10000] 范围内</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextLargerNodes</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            nums.append(head.val)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        res = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> nums[stk[-<span class="number">1</span>]] &lt; v:</span><br><span class="line">                res[stk.pop()] = v</span><br><span class="line">            stk.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="1209-删除字符串中的所有相邻重复项-II"><a href="#1209-删除字符串中的所有相邻重复项-II" class="headerlink" title="1209. 删除字符串中的所有相邻重复项 II"></a>1209. 删除字符串中的所有相邻重复项 II</h2><p>给你一个字符串 s，「k 倍重复项删除操作」将会从 s 中选择 k 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。</p>
<p>你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。</p>
<p>在执行完所有删除操作后，返回最终得到的字符串。</p>
<p>本题答案保证唯一。</p>
<p>示例 1：</p>
<pre>
输入：s = "abcd", k = 2
输出："abcd"
解释：没有要删除的内容。
</pre>
<p>示例 2：</p>
<pre>
输入：s = "deeedbbcccbdaa", k = 3
输出："aa"
解释： 
先删除 "eee" 和 "ccc"，得到 "ddbbbdaa"
再删除 "bbb"，得到 "dddaa"
最后删除 "ddd"，得到 "aa"
</pre>
<p>示例 3：</p>
<pre>
输入：s = "pbbcggttciiippooaais", k = 2
输出："ps"
</pre>

<p>提示：</p>
<ul>
<li>1 &lt;= s.length &lt;= 10^5</li>
<li>2 &lt;= k &lt;= 10^4</li>
<li>s 中只含有小写英文字母。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, s, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>][<span class="number">0</span>] == c:</span><br><span class="line">                stk[-<span class="number">1</span>][<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> stk[-<span class="number">1</span>][<span class="number">1</span>] == k:</span><br><span class="line">                    stk.pop(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stk.append([c, <span class="number">1</span>])</span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> v, i <span class="keyword">in</span> stk:</span><br><span class="line">            res += i * v</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="1249-移除无效的括号-n"><a href="#1249-移除无效的括号-n" class="headerlink" title="1249. 移除无效的括号 [n]"></a>1249. 移除无效的括号 [n]</h2><p>给你一个由 ‘(‘、’)’ 和小写字母组成的字符串 s。</p>
<p>你需要从字符串中删除最少数目的 ‘(‘ 或者 ‘)’ （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。</p>
<p>请返回任意一个合法字符串。</p>
<p>有效「括号字符串」应当符合以下 任意一条 要求：</p>
<ul>
<li>空字符串或只包含小写字母的字符串</li>
<li>可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」</li>
<li>可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」</li>
</ul>
<p>示例 1：</p>
<pre>
输入：s = "lee(t(c)o)de)"
输出："lee(t(c)o)de"
解释："lee(t(co)de)" , "lee(t(c)ode)" 也是一个可行答案。
</pre>
<p>示例 2：</p>
<pre>
输入：s = "a)b(c)d"
输出："ab(c)d"
</pre>
<p>示例 3：</p>
<pre>
输入：s = "))(("
输出：""
解释：空字符串也是有效的
</pre>
<p>示例 4：</p>
<pre>
输入：s = "(a(b(c)d)"
输出："a(b(c)d)"
</pre>

<p>提示：</p>
<ul>
<li>1 &lt;= s.length &lt;= 10^5</li>
<li>s[i] 可能是 ‘(‘、’)’ 或英文小写字母</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minRemoveToMakeValid</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> v == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stk.append((i, v))</span><br><span class="line">            <span class="keyword">elif</span> v == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    stk.pop(-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stk.append((i, v))</span><br><span class="line">        res, j = <span class="string">&quot;&quot;</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> j &lt; <span class="built_in">len</span>(stk) <span class="keyword">and</span> i == stk[j][<span class="number">0</span>]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += v</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode之二叉树(中等)</title>
    <url>/posts/3ddb3bb0.html</url>
    <content><![CDATA[<p>二叉树(中等)的题目汇总在此了，欢迎大家光顾。</p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<img src="/images/leetcode/hongheishu.png" width = 600px height = 300px/>

<a id="more"></a>

<h2 id="95-不同的二叉搜索树-II-n"><a href="#95-不同的二叉搜索树-II-n" class="headerlink" title="95. 不同的二叉搜索树 II [n]"></a>95. 不同的二叉搜索树 II [n]</h2><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。</p>
<p>示例:</p>
<pre>
输入: 3
输出:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释:
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[TreeNode]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.helper(<span class="number">1</span>, n)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> [<span class="literal">None</span>]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(start, end + <span class="number">1</span>):</span><br><span class="line">            lefts = self.helper(start, i - <span class="number">1</span>)</span><br><span class="line">            rights = self.helper(i + <span class="number">1</span>, end)</span><br><span class="line">            <span class="keyword">for</span> left <span class="keyword">in</span> lefts:</span><br><span class="line">                <span class="keyword">for</span> right <span class="keyword">in</span> rights:</span><br><span class="line">                    node = TreeNode(i)</span><br><span class="line">                    node.left = left</span><br><span class="line">                    node.right = right</span><br><span class="line">                    res.append(node)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="96-不同的二叉搜索树-n"><a href="#96-不同的二叉搜索树-n" class="headerlink" title="96. 不同的二叉搜索树 [n]"></a>96. 不同的二叉搜索树 [n]</h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<p>示例:</p>
<pre>
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">0</span>, i):</span><br><span class="line">                dp[i] += dp[j] * dp[i - <span class="number">1</span> - j]<span class="comment">#减一是因为根节点</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h2><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>注意:</p>
<ul>
<li>你可以假设树中没有重复的元素。</li>
</ul>
<pre>
例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder, inorder</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> idx, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder):</span><br><span class="line">            m[v] = idx</span><br><span class="line">        <span class="keyword">return</span> self.helper(preorder, <span class="number">0</span>, <span class="built_in">len</span>(preorder) - <span class="number">1</span>, \</span><br><span class="line">            inorder, <span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>, m)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, preorder, pre_s, pre_e, inorder, in_s, in_e, m</span>):</span></span><br><span class="line">        <span class="keyword">if</span> pre_s &gt; pre_e <span class="keyword">or</span> in_s &gt; in_e:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root_v = preorder[pre_s]</span><br><span class="line">        root_idx = m[root_v]</span><br><span class="line">        left_len = root_idx - in_s</span><br><span class="line">        root = TreeNode(root_v)</span><br><span class="line">        root.left = self.helper(preorder, pre_s + <span class="number">1</span>, pre_s + left_len, \ </span><br><span class="line">            inorder, in_s, root_idx - <span class="number">1</span>, m)</span><br><span class="line">        root.right = self.helper(preorder, pre_s + left_len + <span class="number">1</span>, pre_e, \</span><br><span class="line">            inorder, root_idx + <span class="number">1</span>, in_e, m)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a>106. 从中序与后序遍历序列构造二叉树</h2><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:</p>
<ul>
<li>你可以假设树中没有重复的元素。</li>
</ul>
<pre>
例如，给出

中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder, postorder</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :type postorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> idx, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder):</span><br><span class="line">            m[v] = idx</span><br><span class="line">        <span class="keyword">return</span> self.helper(inorder, <span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>, \</span><br><span class="line">            postorder, <span class="number">0</span>, <span class="built_in">len</span>(postorder) - <span class="number">1</span>, m)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, inorder, in_left, in_right, postorder, post_left, post_right, m</span>):</span></span><br><span class="line">        <span class="keyword">if</span> in_left &gt; in_right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root_val = postorder[post_right]</span><br><span class="line">        root_idx = m[root_val]</span><br><span class="line">        left_len = root_idx - in_left</span><br><span class="line">        root = TreeNode(root_val)</span><br><span class="line">        root.left = self.helper(inorder, in_left, root_idx - <span class="number">1</span>, \</span><br><span class="line">            postorder, post_left, post_left + left_len - <span class="number">1</span>, m)</span><br><span class="line">        root.right = self.helper(inorder, root_idx + <span class="number">1</span>, in_right, \</span><br><span class="line">            postorder, post_left + left_len, post_right - <span class="number">1</span>, m)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a>114. 二叉树展开为链表</h2><p>给定一个二叉树，原地将它展开为链表。</p>
<pre>
例如，给定二叉树

    1
   / \
  2   5
 / \   \
3   4   6
将其展开为：

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        items = self.pre_order(root)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(items) - <span class="number">1</span>):</span><br><span class="line">            items[i].left = <span class="literal">None</span></span><br><span class="line">            items[i].right = items[i + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pre_order</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="comment"># 前序遍历</span></span><br><span class="line">        items = []</span><br><span class="line">        p = root</span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">or</span> stk:</span><br><span class="line">            <span class="keyword">while</span> p:</span><br><span class="line">                items.append(p)</span><br><span class="line">                stk.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">            node = stk.pop(-<span class="number">1</span>)</span><br><span class="line">            p = node.right</span><br><span class="line">        <span class="keyword">return</span> items</span><br></pre></td></tr></table></figure>

<h2 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a>117. 填充每个节点的下一个右侧节点指针 II</h2><p>给定一个二叉树</p>
<pre>
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
</pre>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            sz = <span class="built_in">len</span>(queue)</span><br><span class="line">            prev = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(sz):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> prev:</span><br><span class="line">                    prev.<span class="built_in">next</span> = node</span><br><span class="line">                prev = node</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="236-二叉树的最近公共祖先-n"><a href="#236-二叉树的最近公共祖先-n" class="headerlink" title="236. 二叉树的最近公共祖先 [n]"></a>236. 二叉树的最近公共祖先 [n]</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>示例 1:</p>
<pre>
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
</pre>
<p>示例 2:</p>
<pre>
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
</pre>

<p>说明:</p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">if</span> left <span class="keyword">else</span> right</span><br></pre></td></tr></table></figure>


<h2 id="331-验证二叉树的前序序列化-n"><a href="#331-验证二叉树的前序序列化-n" class="headerlink" title="331. 验证二叉树的前序序列化 [n]"></a>331. 验证二叉树的前序序列化 [n]</h2><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。</p>
<pre>
     _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #
</pre>
<p>例如，上面的二叉树可以被序列化为字符串 “9,3,4,#,#,1,#,#,2,#,6,#,#”，其中 # 代表一个空节点。</p>
<p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p>
<p>每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 ‘#’ 。</p>
<p>你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 “1,,3” 。</p>
<p>示例 1:</p>
<pre>
输入: "9,3,4,#,#,1,#,#,2,#,6,#,#"
输出: true
</pre>
<p>示例 2:</p>
<pre>
输入: "1,#"
输出: false
</pre>
<p>示例 3:</p>
<pre>
输入: "9,#,#,1"
输出: false
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSerialization</span>(<span class="params">self, preorder</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type preorder: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> preorder.split(<span class="string">&#x27;,&#x27;</span>):</span><br><span class="line">            stk.append(c)</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(stk) &gt;= <span class="number">3</span> <span class="keyword">and</span> stk[-<span class="number">2</span>:] == [<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>] <span class="keyword">and</span> stk[-<span class="number">3</span>] != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                stk = stk[:-<span class="number">3</span>]</span><br><span class="line">                stk.append(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> stk == [<span class="string">&#x27;#&#x27;</span>] </span><br></pre></td></tr></table></figure>

<h2 id="337-打家劫舍-III-n"><a href="#337-打家劫舍-III-n" class="headerlink" title="337. 打家劫舍 III [n]"></a>337. 打家劫舍 III [n]</h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p>示例 1:</p>
<pre>
输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
</pre>
<p>示例 2:</p>
<pre>
输入: [3,4,5,1,3,null,1]

     3
    / \
   4   5
  / \   \ 
 1   3   1

输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> self.helper(root, m)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root, m</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">in</span> m:</span><br><span class="line">            <span class="keyword">return</span> m[root]</span><br><span class="line">        val = root.val</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            val += self.helper(root.left.left, m) + self.helper(root.left.right, m)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            val += self.helper(root.right.left, m) + self.helper(root.right.right, m)</span><br><span class="line">        res = <span class="built_in">max</span>(val, self.helper(root.left, m) + self.helper(root.right, m))</span><br><span class="line">        m[root] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a>437. 路径总和 III</h2><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p>
<p>找出路径和等于给定数值的路径总数。</p>
<p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>
<p>示例：</p>
<pre>
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1.  5 -> 3
2.  5 -> 2 -> 1
3.  -3 -> 11
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            self.dfs(node, target)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, root, target</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> root.val == target:</span><br><span class="line">            self.res += <span class="number">1</span></span><br><span class="line">        self.dfs(root.left, target - root.val)</span><br><span class="line">        self.dfs(root.right, target - root.val)</span><br></pre></td></tr></table></figure>

<h2 id="449-序列化和反序列化二叉搜索树"><a href="#449-序列化和反序列化二叉搜索树" class="headerlink" title="449. 序列化和反序列化二叉搜索树"></a>449. 序列化和反序列化二叉搜索树</h2><figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Encodes a tree to a single string.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stk, p = [], root</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stk <span class="keyword">or</span> p:</span><br><span class="line">            <span class="keyword">while</span> p:</span><br><span class="line">                res.append(p.val)</span><br><span class="line">                stk.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">            node = stk.pop(-<span class="number">1</span>)</span><br><span class="line">            p = node.right</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, res))</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        preorder = <span class="built_in">map</span>(<span class="built_in">int</span>, data.split())</span><br><span class="line">        inorder = <span class="built_in">sorted</span>(preorder)</span><br><span class="line">        <span class="keyword">return</span> self.build_tree(preorder, inorder)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_tree</span>(<span class="params">self, preorder, inorder</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root_v = preorder[<span class="number">0</span>]</span><br><span class="line">        idx = inorder.index(root_v)</span><br><span class="line">        root = TreeNode(root_v)</span><br><span class="line">        root.left = self.build_tree(preorder[<span class="number">1</span>:<span class="number">1</span>+idx], inorder[:idx])</span><br><span class="line">        root.right =self.build_tree(preorder[<span class="number">1</span>+idx:], inorder[idx+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="450-删除二叉搜索树中的节点-n"><a href="#450-删除二叉搜索树中的节点-n" class="headerlink" title="450. 删除二叉搜索树中的节点 [n]"></a>450. 删除二叉搜索树中的节点 [n]</h2><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<p>首先找到需要删除的节点；<br>如果找到了，删除它。<br>说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p>
<p>示例:</p>
<pre>
root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。

一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。

    5
   / \
  4   6
 /     \
2       7

另一个正确答案是 [5,2,6,null,4,null,7]。

    5
   / \
  2   6
   \   \
    4   7
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root, key</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> key &lt; root.val:</span><br><span class="line">            root.left = self.deleteNode(root.left, key)</span><br><span class="line">        <span class="keyword">elif</span> key &gt; root.val:</span><br><span class="line">            root.right = self.deleteNode(root.right, key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> root.right</span><br><span class="line">            <span class="keyword">elif</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = self.findMin(root.right)</span><br><span class="line">                root.val = node.val</span><br><span class="line">                root.right = self.deleteNode(root.right, node.val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">while</span> node.left:</span><br><span class="line">            node = node.left</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>

<h2 id="508-出现次数最多的子树元素和"><a href="#508-出现次数最多的子树元素和" class="headerlink" title="508. 出现次数最多的子树元素和"></a>508. 出现次数最多的子树元素和</h2><p>给出二叉树的根，找出出现次数最多的子树元素和。一个结点的子树元素和定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。然后求出出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的元素（不限顺序）。</p>
<p>示例 1</p>
<pre>
输入:

  5
 /  \
2   -3
返回 [2, -3, 4]，所有的值均只出现一次，以任意顺序返回所有值。
</pre>
<p>示例 2</p>
<pre>
输入:

  5
 /  \
2   -5
返回 [2]，只有 2 出现两次，-5 只出现 1 次。
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findFrequentTreeSum</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.m = &#123;&#125;</span><br><span class="line">        self.res = []</span><br><span class="line">        self.cnt = <span class="number">0</span></span><br><span class="line">        self.helper(root)</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.m.iteritems():</span><br><span class="line">            <span class="keyword">if</span> v == self.cnt:</span><br><span class="line">                self.res.append(k)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.helper(root.left)</span><br><span class="line">        right = self.helper(root.right)</span><br><span class="line">        cur_sum = left + right + root.val</span><br><span class="line">        <span class="keyword">if</span> cur_sum <span class="keyword">in</span> self.m:</span><br><span class="line">            self.m[cur_sum] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.m[cur_sum] = <span class="number">1</span></span><br><span class="line">        self.cnt = <span class="built_in">max</span>(self.cnt, self.m[cur_sum])</span><br><span class="line">        <span class="keyword">return</span> cur_sum</span><br></pre></td></tr></table></figure>

<h2 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a>538. 把二叉搜索树转换为累加树</h2><p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p>
<p>例如：</p>
<pre>
输入: 二叉搜索树:
              5
            /   \
           2     13

输出: 转换为累加树:
             18
            /   \
          20     13
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convertBST</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p = root </span><br><span class="line">        stk = []</span><br><span class="line">        prev = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">or</span> stk:</span><br><span class="line">            <span class="keyword">while</span> p:</span><br><span class="line">                stk.append(p)</span><br><span class="line">                p = p.right</span><br><span class="line">            node = stk.pop(-<span class="number">1</span>)</span><br><span class="line">            old_v = node.val</span><br><span class="line">            node.val += prev</span><br><span class="line">            prev += old_v</span><br><span class="line">            p = node.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="623-在二叉树中增加一行"><a href="#623-在二叉树中增加一行" class="headerlink" title="623. 在二叉树中增加一行"></a>623. 在二叉树中增加一行</h2><p>给定一个二叉树，根节点为第1层，深度为 1。在其第 d 层追加一行值为 v 的节点。</p>
<p>添加规则：给定一个深度值 d （正整数），针对深度为 d-1 层的每一非空节点 N，为 N 创建两个值为 v 的左子树和右子树。</p>
<p>将 N 原先的左子树，连接为新节点 v 的左子树；将 N 原先的右子树，连接为新节点 v 的右子树。</p>
<p>如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。</p>
<p>示例 1:</p>
<pre>
输入: 
二叉树如下所示:
       4
     /   \
    2     6
   / \   / 
  3   1 5   

v = 1

d = 2

输出: 
       4
      / \
     1   1
    /     \
   2       6
  / \     / 
 3   1   5   
</pre>
<p>示例 2:</p>
<pre>
输入: 
二叉树如下所示:
      4
     /   
    2    
   / \   
  3   1    

v = 1

d = 3

输出: 
      4
     /   
    2
   / \    
  1   1
 /     \  
3       1
</pre>
<p>注意:</p>
<ul>
<li>输入的深度值 d 的范围是：[1，二叉树最大深度 + 1]。</li>
<li>输入的二叉树至少有一个节点。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addOneRow</span>(<span class="params">self, root, v, d</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type v: int</span></span><br><span class="line"><span class="string">        :type d: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> d == <span class="number">1</span>:</span><br><span class="line">            new_root = TreeNode(v)</span><br><span class="line">            new_root.left = root</span><br><span class="line">            <span class="keyword">return</span> new_root</span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(d - <span class="number">2</span>):</span><br><span class="line">            sz = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(sz):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            tmp = node.left</span><br><span class="line">            new_node = TreeNode(v)</span><br><span class="line">            new_node.left = tmp</span><br><span class="line">            node.left = new_node</span><br><span class="line">            tmp = node.right</span><br><span class="line">            new_node = TreeNode(v)</span><br><span class="line">            new_node.right = tmp</span><br><span class="line">            node.right = new_node</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="652-寻找重复的子树-n"><a href="#652-寻找重复的子树-n" class="headerlink" title="652. 寻找重复的子树 [n]"></a>652. 寻找重复的子树 [n]</h2><p>给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。</p>
<p>两棵树重复是指它们具有相同的结构以及相同的结点值。</p>
<p>示例 1：</p>
<pre>
        1
       / \
      2   3
     /   / \
    4   2   4
       /
      4
下面是两个重复的子树：

      2
     /
    4
和

    4
因此，你需要以列表的形式返回上述重复子树的根结点。
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicateSubtrees</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[TreeNode]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m, res = &#123;&#125;, []</span><br><span class="line">        self.helper(root, m)</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> m.iteritems():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(v) &gt; <span class="number">1</span>:</span><br><span class="line">                res.append(v[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root, m</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        s = <span class="string">&quot;(&quot;</span> + self.helper(root.left, m) + <span class="built_in">str</span>(root.val) + \</span><br><span class="line">            self.helper(root.right, m) + <span class="string">&quot;)&quot;</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">in</span> m:</span><br><span class="line">            m[s].append(root)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            m[s] = [root]</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>

<h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a>654. 最大二叉树</h2><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p>
<ul>
<li>二叉树的根是数组中的最大元素。</li>
<li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li>
<li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li>
</ul>
<p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p>
<p>示例 ：</p>
<pre>
输入：[3,2,1,6,0,5]
输出：返回下面这棵树的根节点：

      6
    /   \
   3     5
    \    / 
     2  0   
       \
        1
</pre>

<p>提示：</p>
<ul>
<li>给定的数组的大小在 [1, 1000] 之间。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> idx, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            m[v] = idx</span><br><span class="line">        <span class="keyword">return</span> self.helper(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>, m)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, nums, left, right, m</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        max_v = <span class="built_in">max</span>(nums[left: right + <span class="number">1</span>])</span><br><span class="line">        max_idx = m[max_v]</span><br><span class="line">        root = TreeNode(max_v)</span><br><span class="line">        root.left = self.helper(nums, left, max_idx - <span class="number">1</span>, m)</span><br><span class="line">        root.right = self.helper(nums, max_idx + <span class="number">1</span>, right, m)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="655-输出二叉树-n"><a href="#655-输出二叉树-n" class="headerlink" title="655. 输出二叉树 [n]"></a>655. 输出二叉树 [n]</h2><p>在一个 m*n 的二维字符串数组中输出二叉树，并遵守以下规则：</p>
<ul>
<li>行数 m 应当等于给定二叉树的高度。</li>
<li>列数 n 应当总是奇数。</li>
<li>根节点的值（以字符串格式给出）应当放在可放置的第一行正中间。根节点所在的行与列会将剩余空间划分为两部分（左下部分和右下部分）。你应该将左子树输出在左下部分，右子树输出在右下部分。左下和右下部分应当有相同的大小。即使一个子树为空而另一个非空，你不需要为空的子树输出任何东西，但仍需要为另一个子树留出足够的空间。然而，如果两个子树都为空则不需要为它们留出任何空间。</li>
<li>每个未使用的空间应包含一个空的字符串””。</li>
<li>使用相同的规则输出子树。</li>
</ul>
<p>示例 1:</p>
<pre>
输入:
     1
    /
   2
输出:
[["", "1", ""],
 ["2", "", ""]]
</pre>
<p>示例 2:</p>
<pre>
输入:
     1
    / \
   2   3
    \
     4
输出:
[["", "", "", "1", "", "", ""],
 ["", "2", "", "", "", "3", ""],
 ["", "", "4", "", "", "", ""]]
</pre>
<p>示例 3:</p>
<pre>
输入:
      1
     / \
    2   5
   / 
  3 
 / 
4 
输出:
[["",  "",  "", "",  "", "", "", "1", "",  "",  "",  "",  "", "", ""]
 ["",  "",  "", "2", "", "", "", "",  "",  "",  "",  "5", "", "", ""]
 ["",  "3", "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]
 ["4", "",  "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]]
注意: 二叉树的高度在范围 [1, 10] 中。
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        height = self.getHeight(root)</span><br><span class="line">        width = (<span class="number">1</span> &lt;&lt; height) - <span class="number">1</span></span><br><span class="line">        res = [[<span class="string">&quot;&quot;</span>] * width <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(height)]</span><br><span class="line">        self.helper(root, <span class="number">0</span>, width - <span class="number">1</span>, <span class="number">0</span>, height, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root, left, right, h, height, res</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> h == height:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mid = (left + right) / <span class="number">2</span></span><br><span class="line">        res[h][mid] = <span class="built_in">str</span>(root.val)</span><br><span class="line">        self.helper(root.left, left, mid - <span class="number">1</span>, h + <span class="number">1</span>, height, res)</span><br><span class="line">        self.helper(root.right, mid + <span class="number">1</span>, right, h + <span class="number">1</span>, height, res)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHeight</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(self.getHeight(root.left), self.getHeight(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="687-最长同值路径-n"><a href="#687-最长同值路径-n" class="headerlink" title="687. 最长同值路径 [n]"></a>687. 最长同值路径 [n]</h2><p>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。</p>
<p>注意：两个节点之间的路径长度由它们之间的边数表示。</p>
<p>示例 1:</p>
<pre>
输入:

              5
             / \
            4   5
           / \   \
          1   1   5
输出:
2
</pre>
<p>示例 2:</p>
<pre>
输入:

              1
             / \
            4   5
           / \   \
          4   4   5
输出:

2
注意: 给定的二叉树不超过10000个结点。 树的高度不超过1000。
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestUnivaluePath</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.helper(root.left)</span><br><span class="line">        right = self.helper(root.right)</span><br><span class="line">        pl, pr = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">and</span> root.left.val == root.val:</span><br><span class="line">            pl = left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> root.right <span class="keyword">and</span> root.right.val == root.val:</span><br><span class="line">            pr = right + <span class="number">1</span></span><br><span class="line">        self.res = <span class="built_in">max</span>(self.res, pl + pr)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(pl, pr)</span><br></pre></td></tr></table></figure>

<h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a>701. 二叉搜索树中的插入操作</h2><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。</p>
<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p>
<p>例如, </p>
<pre>
给定二叉搜索树:

        4
       / \
      2   7
     / \
    1   3

和 插入的值: 5
你可以返回这个二叉搜索树:

         4
       /   \
      2     7
     / \   /
    1   3 5
或者这个树也是有效的:

         5
       /   \
      2     7
     / \   
    1   3
         \
          4
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">            root.left = self.insertIntoBST(root.left, val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root.right = self.insertIntoBST(root.right, val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="814-二叉树剪枝-n"><a href="#814-二叉树剪枝-n" class="headerlink" title="814. 二叉树剪枝 [n]"></a>814. 二叉树剪枝 [n]</h2><p>给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。</p>
<p>返回移除了所有不包含 1 的子树的原二叉树。</p>
<p>( 节点 X 的子树为 X 本身，以及所有 X 的后代。)</p>
<p>示例1:</p>
<pre>
输入: [1,null,0,0,1]
输出: [1,null,0,null,1]

解释: 
只有红色节点满足条件“所有不包含 1 的子树”。
右图为返回的答案。
</pre>

<p>示例2:</p>
<pre>
输入: [1,0,1,0,0,0,1]
输出: [1,null,1,null,1]
</pre>

<p>示例3:</p>
<pre>
输入: [1,1,0,1,1,0,1,0]
输出: [1,1,0,1,1,null,1]
</pre>
<p>说明:</p>
<ul>
<li>给定的二叉树最多有 100 个节点。</li>
<li>每个节点的值只会为 0 或 1 。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pruneTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root.left = self.pruneTree(root.left)</span><br><span class="line">        root.right = self.pruneTree(root.right)</span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.val == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="863-二叉树中所有距离为-K-的结点-n"><a href="#863-二叉树中所有距离为-K-的结点-n" class="headerlink" title="863. 二叉树中所有距离为 K 的结点 [n]"></a>863. 二叉树中所有距离为 K 的结点 [n]</h2><p>给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。</p>
<p>返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。</p>
<p>示例 1：</p>
<pre>
输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2

输出：[7,4,1]

解释：
所求结点为与目标结点（值为 5）距离为 2 的结点，
值分别为 7，4，以及 1
</pre>
<p>提示：</p>
<ul>
<li>给定的树是非空的，且最多有 K 个结点。</li>
<li>树上的每个结点都具有唯一的值 0 &lt;= node.val &lt;= 500 。</li>
<li>目标结点 target 是树上的结点。</li>
<li>0 &lt;= K &lt;= 1000.</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distanceK</span>(<span class="params">self, root, target, K</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type target: TreeNode</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        self.helper(<span class="literal">None</span>, root, m)</span><br><span class="line"></span><br><span class="line">        queue = [target.val]</span><br><span class="line">        visited = <span class="built_in">set</span>([target.val])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(K):</span><br><span class="line">            sz = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(sz):</span><br><span class="line">                v = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> m[v]:</span><br><span class="line">                    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited.add(i)</span><br><span class="line">                        queue.append(i)</span><br><span class="line">        <span class="keyword">return</span> queue</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, parent, child, m</span>):</span></span><br><span class="line">        <span class="keyword">if</span> parent <span class="keyword">and</span> child:</span><br><span class="line">            m[child.val].append(parent.val)</span><br><span class="line">            m[parent.val].append(child.val)</span><br><span class="line">        <span class="keyword">if</span> child.left:</span><br><span class="line">            self.helper(child, child.left, m)</span><br><span class="line">        <span class="keyword">if</span> child.right:</span><br><span class="line">            self.helper(child, child.right, m)</span><br></pre></td></tr></table></figure>

<h2 id="865-具有所有最深结点的最小子树-n"><a href="#865-具有所有最深结点的最小子树-n" class="headerlink" title="865. 具有所有最深结点的最小子树 [n]"></a>865. 具有所有最深结点的最小子树 [n]</h2><p>给定一个根为 root 的二叉树，每个结点的深度是它到根的最短距离。</p>
<p>如果一个结点在整个树的任意结点之间具有最大的深度，则该结点是最深的。</p>
<p>一个结点的子树是该结点加上它的所有后代的集合。</p>
<p>返回能满足“以该结点为根的子树中包含所有最深的结点”这一条件的具有最大深度的结点。</p>
<p>示例：</p>
<pre>
输入：[3,5,1,6,2,0,8,null,null,7,4]
输出：[2,7,4]
解释：

我们返回值为 2 的结点，在图中用黄色标记。
在图中用蓝色标记的是树的最深的结点。
输入 "[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]" 是对给定的树的序列化表述。
输出 "[2, 7, 4]" 是对根结点的值为 2 的子树的序列化表述。
输入和输出都具有 TreeNode 类型。
</pre>

<p>提示：</p>
<ul>
<li>树中结点的数量介于 1 和 500 之间。</li>
<li>每个结点的值都是独一无二的。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtreeWithAllDeepest</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        depth, res = self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line">        left_pair = self.helper(root.left)</span><br><span class="line">        right_pair = self.helper(root.right)</span><br><span class="line">        dl, dr = left_pair[<span class="number">0</span>], right_pair[<span class="number">0</span>]</span><br><span class="line">        root_depth =  <span class="built_in">max</span>(dl, dr) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> dl == dr:</span><br><span class="line">            <span class="keyword">return</span> (root_depth, root)</span><br><span class="line">        <span class="keyword">return</span> (root_depth, left_pair[<span class="number">1</span>]) <span class="keyword">if</span> dl &gt; dr <span class="keyword">else</span> (root_depth, right_pair[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h2 id="894-所有可能的满二叉树-n"><a href="#894-所有可能的满二叉树-n" class="headerlink" title="894. 所有可能的满二叉树 [n]"></a>894. 所有可能的满二叉树 [n]</h2><p>满二叉树是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。</p>
<p>返回包含 N 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。</p>
<p>答案中每个树的每个结点都必须有 node.val=0。</p>
<p>你可以按任何顺序返回树的最终列表。</p>
<p>示例：</p>
<pre>
输入：7
输出：
[[0,0,0,null,null,0,0,null,null,0,0],
[0,0,0,null,null,0,0,0,0],
[0,0,0,0,0,0,0],
[0,0,0,0,0,null,null,null,null,0,0],
[0,0,0,0,0,null,null,0,0]]
</pre>

<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allPossibleFBT</span>(<span class="params">self, N</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: List[TreeNode]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> N % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [TreeNode(<span class="number">0</span>)]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, N, <span class="number">2</span>):</span><br><span class="line">            lefts = self.allPossibleFBT(i)</span><br><span class="line">            rights = self.allPossibleFBT(N - <span class="number">1</span> - i)</span><br><span class="line">            <span class="keyword">for</span> left <span class="keyword">in</span> lefts:</span><br><span class="line">                <span class="keyword">for</span> right <span class="keyword">in</span> rights:</span><br><span class="line">                    root = TreeNode(<span class="number">0</span>)</span><br><span class="line">                    root.left = left</span><br><span class="line">                    root.right = right</span><br><span class="line">                    res.append(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="951-翻转等价二叉树-n"><a href="#951-翻转等价二叉树-n" class="headerlink" title="951. 翻转等价二叉树 [n]"></a>951. 翻转等价二叉树 [n]</h2><p>我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。</p>
<p>只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转等价于二叉树 Y。</p>
<p>编写一个判断两个二叉树是否是翻转等价的函数。这些树由根节点 root1 和 root2 给出。</p>
<p>示例：</p>
<pre>
输入：root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]
输出：true
解释：We flipped at nodes with values 1, 3, and 5.
</pre>

<p>提示：</p>
<ul>
<li>每棵树最多有 100 个节点。</li>
<li>每棵树中的每个值都是唯一的、在 [0, 99] 范围内的整数。</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flipEquiv</span>(<span class="params">self, root1, root2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root1: TreeNode</span></span><br><span class="line"><span class="string">        :type root2: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root1 == root2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> root1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root2 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root1.val != root2.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        a = self.flipEquiv(root1.left, root2.left) <span class="keyword">and</span> \</span><br><span class="line">            self.flipEquiv(root1.right, root2.right) </span><br><span class="line">        b = self.flipEquiv(root1.left, root2.right) <span class="keyword">and</span> \</span><br><span class="line">            self.flipEquiv(root1.right, root2.left)</span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">or</span> b</span><br></pre></td></tr></table></figure>

<h2 id="958-二叉树的完全性检验"><a href="#958-二叉树的完全性检验" class="headerlink" title="958. 二叉树的完全性检验"></a>958. 二叉树的完全性检验</h2><p>给定一个二叉树，确定它是否是一个完全二叉树。</p>
<p>百度百科中对完全二叉树的定义如下：</p>
<p>若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。）</p>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isCompleteTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="971-翻转二叉树以匹配先序遍历-n"><a href="#971-翻转二叉树以匹配先序遍历-n" class="headerlink" title="971. 翻转二叉树以匹配先序遍历 [n]"></a>971. 翻转二叉树以匹配先序遍历 [n]</h2><p>给定一个有 N 个节点的二叉树，每个节点都有一个不同于其他节点且处于 {1, …, N} 中的值。</p>
<p>通过交换节点的左子节点和右子节点，可以翻转该二叉树中的节点。</p>
<p>考虑从根节点开始的先序遍历报告的 N 值序列。将这一 N 值序列称为树的行程。</p>
<p>（回想一下，节点的先序遍历意味着我们报告当前节点的值，然后先序遍历左子节点，再先序遍历右子节点。）</p>
<p>我们的目标是翻转最少的树中节点，以便树的行程与给定的行程 voyage 相匹配。 </p>
<p>如果可以，则返回翻转的所有节点的值的列表。你可以按任何顺序返回答案。</p>
<p>如果不能，则返回列表 [-1]。</p>
<p>示例 1：</p>
<pre>
输入：root = [1,2], voyage = [2,1]
输出：[-1]
</pre>
<p>示例 2：</p>
<pre>
输入：root = [1,2,3], voyage = [1,3,2]
输出：[1]
</pre>
<p>示例 3：</p>
<pre>
输入：root = [1,2,3], voyage = [1,2,3]
输出：[]
</pre>

<p>提示：</p>
<ul>
<li>1 &lt;= N &lt;= 100</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flipMatchVoyage</span>(<span class="params">self, root, voyage</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type voyage: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.pos, self.res = <span class="number">0</span>, []</span><br><span class="line">        self.dfs(root, voyage)</span><br><span class="line">        print(self.res)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, root, voyage</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> root.val != voyage[self.pos]:</span><br><span class="line">            self.res = [-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> self.res</span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">and</span> root.left.val != voyage[self.pos + <span class="number">1</span>]:</span><br><span class="line">            root.left, root.right = root.right, root.left</span><br><span class="line">            self.res.append(root.val)</span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        self.dfs(root.left, voyage)</span><br><span class="line">        self.dfs(root.right, voyage)</span><br></pre></td></tr></table></figure>


<h2 id="979-在二叉树中分配硬币-n"><a href="#979-在二叉树中分配硬币-n" class="headerlink" title="979. 在二叉树中分配硬币 [n]"></a>979. 在二叉树中分配硬币 [n]</h2><p>给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。</p>
<p>在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。</p>
<p>返回使每个结点上只有一枚硬币所需的移动次数。</p>
<p>示例 1：</p>
<pre>
输入：[3,0,0]
输出：2
解释：从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。
</pre>
<p>示例 2：</p>
<pre>
输入：[0,3,0]
输出：3
解释：从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。
</pre>
<p>示例 3：</p>
<pre>
输入：[1,0,2]
输出：2
</pre>
<p>示例 4：</p>
<pre>
输入：[1,0,0,null,3]
输出：4
</pre>

<p>提示：</p>
<ul>
<li>1&lt;= N &lt;= 100</li>
<li>0 &lt;= node.val &lt;= N</li>
</ul>
<figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distributeCoins</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.helper(root.left)</span><br><span class="line">        right = self.helper(root.right)</span><br><span class="line">        self.res += <span class="built_in">abs</span>(left) + <span class="built_in">abs</span>(right)</span><br><span class="line">        <span class="keyword">return</span> root.val - <span class="number">1</span> + left + right</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
</search>
